<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HDRI Studio 编辑器 - 免费在线HDR编辑器</title>
    <script src="menu.js" defer></script>
    <link rel="icon" href="img/gongjuxiang.svg" type="image/svg">
    <script defer src="https://cloud.umami.is/script.js" data-website-id="5a2e10cd-bf73-47df-be48-079c9ba7783c" data-domains="designtool.site"></script>
    <style>
        :root {
            --main-color: #8080FF;
            --line: #7878784d;
            --main-bg: #222228;
            --panel-bg: #2E2E33;
            --bt-gradient: linear-gradient(to left, #6450ff, #8f56fa);
            --add-gradient: linear-gradient(to left, #50c878, #56fa8f);
            --octagon-gradient: linear-gradient(to left, #ff7e5f, #feb47b);
            --text1: #ffffff;
            --text2: #c7d1e2;
            --text3: #969dbb;
            --input-bg: #3a3a42;
            --scrollbar-thumb: #4a4a5a;
            --scrollbar-track: #2a2a33;
            --success: #50c878;
            --warning: #ff7e5f;
        }
        * { 
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0; 
            background-color: var(--main-bg); 
            color: var(--text2);
            display: flex; 
            justify-content: center; 
            align-items: flex-start; 
            min-height: 100vh; 
            overflow: hidden;
        }
        .icon {
    display: inline-block;
    width: 1.2em;
    height: 1.2em;
    fill: currentColor;
}
        .scripts {
            margin-left: 10px; 
            font-size: 14px; 
            font-weight: 400; 
            color: var(--text3);
        }
        #resizeHandle {
            position: relative;
            height: 10px;
            background: #00000000;
            cursor: ns-resize;
            z-index: 50;
            transition: background .2s;
        }
        .editor-container { 
            display: flex; 
            gap: 10px; 
            width: 100%; 
            height: calc(100vh - 40px); 
            position: relative; 
            margin: 20px 20px 20px 60px;
        }
        .controls-panel {
            width: 400px; 
            background-color: var(--panel-bg); 
            border: 1px solid var(--line); 
            border-radius: 8px;
            padding: 20px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.3); 
            flex-shrink: 0; 
            display: flex; 
            flex-direction: column; 
            height: 100%;
        }
        .controls-header {
            position: sticky;
            top: 0;
            background-color: var(--panel-bg);
            z-index: 10;
        }

        .controls-content {
            overflow-y: auto;
            flex-grow: 1;
            margin-top: 15px;
        }

        .preview-panel {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
            position: relative;
        }

        .preview-box {
            background-color: var(--panel-bg);
            border: 1px solid var(--line);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            padding: 15px;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .top-preview {
            height: 50%;
        }
        
        .top-preview-content {
            display: flex;
            flex-grow: 1;
            height: calc(100% - 38px);
        }
        
        #hdr-canvas-wrapper {
            flex: 0.75 1 0%;
            position: relative;
            min-width: 200px;
        }
        #hdrCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        #vertical-resize-handle {
            width: 10px;
            background: #00000000;
            cursor: ew-resize;
            flex-shrink: 0;
            transition: background .2s;
        }
        #vertical-resize-handle:hover {
            background: #ffffff1a;
        }
        
        #light-list-panel {
            flex: 0.25 1 0%;
            min-width: 200px;
            height: 100%;
            display: flex;
            flex-direction: column;
            border-left: 1px solid var(--line);
            padding-left: 10px;
            overflow: hidden;
        }
        
        .light-list-header h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: var(--text2);
            font-weight: 500;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--line);
        }

        #light-list-items {
            list-style: none;
            padding: 0;
            margin: 0;
            overflow-y: auto;
            flex-grow: 1;
            background: var(--main-bg);
            border-radius: 4px;
            padding: 8px;
        }
        
        .light-item {
            display: flex;
            align-items: center;
            padding: 8px 5px;
            border-radius: 4px;
            margin-bottom: 4px;
            cursor: pointer;
            transition: background-color .2s;
            font-size: 14px;
            border: 1px solid #00000000;
        }
 
        .light-item:nth-child(even) {
            background: var(--panel-bg)
        }
        .light-item:hover {
            background-color: #8080ff1a;
        }

        .light-item.active {
            background-color: #8080ff30;
            border: 1px solid var(--main-color);
        }
        
        .light-item .icon {
            margin-right: 10px;
            width: 16px;
            text-align: center;
        }

        .light-item .name {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .light-item .actions {
            display: flex;
            gap: 8px;
        }

        .light-item .actions button {
            background: none;
            border: none;
            color: var(--text3);
            cursor: pointer;
            padding: 2px;
            font-size: 14px;
            line-height: 1;
            transition: color .2s;
        }
        
        .light-item .actions button:hover {
            color: var(--text1);
        }


        .bottom-preview {
            height: 50%;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 14px;
            color: var(--text3);
            flex-shrink: 0;
        }

        .preview-header h3 {
            margin: 0;
            color: var(--text2);
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .import-model-button {
            padding: 4px 12px;
            border: 1px solid var(--line);
            border-radius: 5px;
            background: var(--input-bg);
            color: var(--text2);
            cursor: pointer;
            transition: all .2s ease;
            font-size: 12px;
            margin-left: auto;
            display: flex;
    align-items: center;
    gap: 4px;
        }
        .import-model-button:hover {
            border-color: var(--main-color);
            color: var(--main-color);
        }

        canvas { 
            display:block; 
            background-color:#000; 
            border-radius:4px; 
            height:100%; 
            margin:0 auto; 
            width:100%; 
            border: 1px solid var(--main-bg);
        }
        canvas:hover {
            border: 1px solid #8080ff75;
        } 
        h2.main-title { 
            margin-top:0; 
            border-bottom:1px solid var(--line); 
            padding-bottom:15px; 
            font-size:22px; 
            color: var(--main-color); 
            font-weight:600; 
            display:flex; 
            align-items:center; 
            gap:10px; 
            justify-content:space-between; 
        }
        .button-group {
            display: grid;
            grid-template-columns: repeat(4,1fr);
            gap: 10px;
        }
        .button-group button {
            padding:10px 12px; 
            border:none; 
            border-radius:5px; 
            color: var(--text1); 
            cursor:pointer; 
            transition:all .2s ease;
            font-size:14px; 
            display:flex; 
            align-items:center; 
            justify-content:center; 
            gap:8px; 
            background:var(--line); 
            border:1px solid #969dbb00;
            flex-direction: column;
        }
        .button-group button.active {
            border:1px solid var(--main-color); 
            color: var(--main-color); 
            background:#8080ff30;
            box-shadow: 0 0 10px rgba(128, 128, 255, 0.5);
        }
        .button-group button:hover {
            border: 1px solid var(--main-color);
            color: var(--main-color);
            background: #8080ff30;
        }

        .export-button {
            padding: 10px 22px;
            border: none;
            border-radius: 25px;
            background: var(--bt-gradient);
            color: var(--text1);
            cursor: pointer;
            transition: all .2s ease-in-out;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .export-button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            opacity: 0.86;
        }

        .control-section {
            background-color: rgba(0,0,0,0.1);
            border: 1px solid var(--line);
            border-radius: 6px;
            padding: 15px;
            margin-top: 10px;
        }

        #modelControls {
            display: none; 
        }

        .control-group {
            margin: 16px 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .control-group label { 
            display:block;  
            font-size:14px; 
            color: var(--text2); 
            width: 100px;
        }
        .control-group input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background:var(--line);
            border-radius: 2px;
            outline: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--main-color);
            cursor: pointer;
            border: 2px solid var(--panel-bg);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--main-color);
            cursor: pointer;
            border: 2px solid var(--panel-bg);
        }

        .color-input-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group input[type="color"] {
            min-width: 40px;
            height: 30px;
            border: 1px solid var(--line);
            border-radius: 4px;
            padding: 2px;
            cursor: pointer;
            background: none;
        }

        .control-group input[type="text"], .control-group input[type="number"], #resolutionSelector {
            flex-grow: 1;
            background-color: var(--main-bg);
            color: var(--text1);
            border: 1px solid var(--line);
            border-radius: 4px;
            padding: 6px 8px;
            min-width: 70px;
        }

        .value-display {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }

        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--line);
        }

        .control-header h3 {
            margin: 0;
            font-size: 16px;
            color: #f59e0b;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .delete-button {
            background: none;
            border: none;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
        }

        .delete-button:hover {
            color: #ff4757;
        }

        .tab-buttons {
            display: flex;
            background-color: var(--line);
            border-radius: 6px;
            padding: 4px;
            margin-bottom: 15px;
            gap: 4px;
        }

        .tab-button {
            flex: 1;
            padding: 6px 0;
            background: none;
            border: none;
            color: var(--text1);
            cursor: pointer;
            border-radius: 4px;
            transition: all .2s ease;
        }
        .tab-button:hover {
            background: var(--line);
            box-shadow: 0 2px 4px #27272b3d;
        }
        .tab-button.active {
            background: #babac5;
            color: var(--main-bg);
            font-weight: 600;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }
        #imageUploadLabel { 
            display:block; 
            padding:10px; 
            text-align:center; 
            background-color: var(--input-bg); 
            border:1px dashed var(--line); 
            border-radius:4px; 
            cursor:pointer;    
            flex: 1;
            display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
        }
        #imageUploadLabel:hover {
            background-color: #44444c;
        }

        #imageUpload {
            display: none;
        }
        #modelUpload {
            display: none;
        }

        .status-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
        }

        .status-ok {
            color: var(--success);
            border: 1px solid var(--success);
        }

        .status-error {
            color: var(--warning);
            border: 1px solid var(--warning);
        }

        .cursor-dashed {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="none" stroke="white" stroke-width="1" stroke-dasharray="4,4"/></svg>') 12 12, auto;
        }

        .cursor-ring {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="none" stroke="white" stroke-width="1"/><circle cx="12" cy="12" r="6" fill="none" stroke="white" stroke-width="1" stroke-dasharray="4,4"/></svg>') 12 12, auto;
        }

        .cursor-square {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect x="4" y="4" width="16" height="16" fill="none" stroke="white" stroke-width="1" stroke-dasharray="4,4"/></svg>') 12 12, auto;
        }

        .cursor-octagon {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><polygon points="8.5,4 15.5,4 20,8.5 20,15.5 15.5,20 8.5,20 4,15.5 4,8.5" fill="none" stroke="white" stroke-width="1" stroke-dasharray="4,4"/></svg>') 12 12, auto;
        }
        
        .controls-content::-webkit-scrollbar, #light-list-items::-webkit-scrollbar {
            width: 8px;
        }

        .controls-content::-webkit-scrollbar-track, #light-list-items::-webkit-scrollbar-track {
            background: var(--scrollbar-track);
        }

        .controls-content::-webkit-scrollbar-thumb, #light-list-items::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb);
            border-radius: 4px;
        }
        
        @media (max-width: 768px) {
            .editor-container { flex-direction: column;         overflow-y: auto; margin: 0;}
            .controls-panel { width: 100%; padding: 10px;        height: auto; }
            .button-group { grid-template-columns: repeat(2, 1fr); }
            .button-group button {
                flex-direction: row;
            }
            h2.main-title {
                flex-direction: column;
            }
            .top-preview-content {
                flex-direction: column;
            }
            #hdr-canvas-wrapper, #light-list-panel {
                width: 100%;
                height: 224px;
            }
            .bottom-preview {    height: 35%;}
            #light-list-panel {
                height: 150px;
                border-left: none;
                border-top: 1px solid var(--line);
                padding-left: 0;
                margin-top: 10px;
            }
            #vertical-resize-handle {
                display: none;
            }
        }
        
        .temperature-control { 
            display: none; 
        }
        .temperature-control.active {
            display: block;
        }
        .temperature-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .temperature-toggle label {
            margin-bottom: 0;
            cursor: pointer;
            width: auto;
        }
        .disabled-color {
            opacity: 0.6;
            pointer-events: none;
        }
        .material-info {
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            margin-top: 10px;
            font-size: 12px;
        }
    </style>
</head>
<body>
<svg width="0" height="0" class="hidden">
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="arrow-rotate-left-solid-full">
    <path d="M320 128C263.2 128 212.1 152.7 176.9 192L224 192C241.7 192 256 206.3 256 224C256 241.7 241.7 256 224 256L96 256C78.3 256 64 241.7 64 224L64 96C64 78.3 78.3 64 96 64C113.7 64 128 78.3 128 96L128 150.7C174.9 97.6 243.5 64 320 64C461.4 64 576 178.6 576 320C576 461.4 461.4 576 320 576C233 576 156.1 532.6 109.9 466.3C99.8 451.8 103.3 431.9 117.8 421.7C132.3 411.5 152.2 415.1 162.4 429.6C197.2 479.4 254.8 511.9 320 511.9C426 511.9 512 425.9 512 319.9C512 213.9 426 128 320 128z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="box-solid-full">
    <path d="M465.4 192L431.1 144L209 144L174.7 192L465.4 192zM96 212.5C96 199.2 100.2 186.2 107.9 175.3L156.9 106.8C168.9 90 188.3 80 208.9 80L431 80C451.7 80 471.1 90 483.1 106.8L532 175.3C539.8 186.2 543.9 199.2 543.9 212.5L544 480C544 515.3 515.3 544 480 544L160 544C124.7 544 96 515.3 96 480L96 212.5z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="cloud-arrow-up-solid-full">
    <path d="M176 544C96.5 544 32 479.5 32 400C32 336.6 73 282.8 129.9 263.5C128.6 255.8 128 248 128 240C128 160.5 192.5 96 272 96C327.4 96 375.5 127.3 399.6 173.1C413.8 164.8 430.4 160 448 160C501 160 544 203 544 256C544 271.7 540.2 286.6 533.5 299.7C577.5 320 608 364.4 608 416C608 486.7 550.7 544 480 544L176 544zM337 255C327.6 245.6 312.4 245.6 303.1 255L231.1 327C221.7 336.4 221.7 351.6 231.1 360.9C240.5 370.2 255.7 370.3 265 360.9L296 329.9L296 432C296 445.3 306.7 456 320 456C333.3 456 344 445.3 344 432L344 329.9L375 360.9C384.4 370.3 399.6 370.3 408.9 360.9C418.2 351.5 418.3 336.3 408.9 327L336.9 255z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="cube-solid-full">
    <path d="M288.3 61.5C308.1 50.1 332.5 50.1 352.3 61.5L528.2 163C548 174.4 560.2 195.6 560.2 218.4L560.2 421.4C560.2 444.3 548 465.4 528.2 476.8L352.3 578.5C332.5 589.9 308.1 589.9 288.3 578.5L112.5 477C92.7 465.6 80.5 444.4 80.5 421.6L80.5 218.6C80.5 195.7 92.7 174.6 112.5 163.2L288.3 61.5zM496.1 421.5L496.1 255.4L352.3 338.4L352.3 504.5L496.1 421.5z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="download-solid-full">
    <path d="M352 96C352 78.3 337.7 64 320 64C302.3 64 288 78.3 288 96L288 306.7L246.6 265.3C234.1 252.8 213.8 252.8 201.3 265.3C188.8 277.8 188.8 298.1 201.3 310.6L297.3 406.6C309.8 419.1 330.1 419.1 342.6 406.6L438.6 310.6C451.1 298.1 451.1 277.8 438.6 265.3C426.1 252.8 405.8 252.8 393.3 265.3L352 306.7L352 96zM160 384C124.7 384 96 412.7 96 448L96 480C96 515.3 124.7 544 160 544L480 544C515.3 544 544 515.3 544 480L544 448C544 412.7 515.3 384 480 384L433.1 384L376.5 440.6C345.3 471.8 294.6 471.8 263.4 440.6L206.9 384L160 384zM464 440C477.3 440 488 450.7 488 464C488 477.3 477.3 488 464 488C450.7 488 440 477.3 440 464C440 450.7 450.7 440 464 440z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="eye-slash-solid-full">
    <path d="M73 39.1C63.6 29.7 48.4 29.7 39.1 39.1C29.8 48.5 29.7 63.7 39 73.1L567 601.1C576.4 610.5 591.6 610.5 600.9 601.1C610.2 591.7 610.3 576.5 600.9 567.2L504.5 470.8C507.2 468.4 509.9 466 512.5 463.6C559.3 420.1 590.6 368.2 605.5 332.5C608.8 324.6 608.8 315.8 605.5 307.9C590.6 272.2 559.3 220.2 512.5 176.8C465.4 133.1 400.7 96.2 319.9 96.2C263.1 96.2 214.3 114.4 173.9 140.4L73 39.1zM236.5 202.7C260 185.9 288.9 176 320 176C399.5 176 464 240.5 464 320C464 351.1 454.1 379.9 437.3 403.5L402.6 368.8C415.3 347.4 419.6 321.1 412.7 295.1C399 243.9 346.3 213.5 295.1 227.2C286.5 229.5 278.4 232.9 271.1 237.2L236.4 202.5zM357.3 459.1C345.4 462.3 332.9 464 320 464C240.5 464 176 399.5 176 320C176 307.1 177.7 294.6 180.9 282.7L101.4 203.2C68.8 240 46.4 279 34.5 307.7C31.2 315.6 31.2 324.4 34.5 332.3C49.4 368 80.7 420 127.5 463.4C174.6 507.1 239.3 544 320.1 544C357.4 544 391.3 536.1 421.6 523.4L357.4 459.2z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="eye-solid-full">
    <path d="M320 96C239.2 96 174.5 132.8 127.4 176.6C80.6 220.1 49.3 272 34.4 307.7C31.1 315.6 31.1 324.4 34.4 332.3C49.3 368 80.6 420 127.4 463.4C174.5 507.1 239.2 544 320 544C400.8 544 465.5 507.2 512.6 463.4C559.4 419.9 590.7 368 605.6 332.3C608.9 324.4 608.9 315.6 605.6 307.7C590.7 272 559.4 220 512.6 176.6C465.5 132.9 400.8 96 320 96zM176 320C176 240.5 240.5 176 320 176C399.5 176 464 240.5 464 320C464 399.5 399.5 464 320 464C240.5 464 176 399.5 176 320zM320 256C320 291.3 291.3 320 256 320C244.5 320 233.7 317 224.3 311.6C223.3 322.5 224.2 333.7 227.2 344.8C240.9 396 293.6 426.4 344.8 412.7C396 399 426.4 346.3 412.7 295.1C400.5 249.4 357.2 220.3 311.6 224.3C316.9 233.6 320 244.4 320 256z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="file-import-solid-full">
    <path d="M192 64C156.7 64 128 92.7 128 128L128 368L310.1 368L279.1 337C269.7 327.6 269.7 312.4 279.1 303.1C288.5 293.8 303.7 293.7 313 303.1L385 375.1C394.4 384.5 394.4 399.7 385 409L313 481C303.6 490.4 288.4 490.4 279.1 481C269.8 471.6 269.7 456.4 279.1 447.1L310.1 416.1L128 416.1L128 512.1C128 547.4 156.7 576.1 192 576.1L448 576.1C483.3 576.1 512 547.4 512 512.1L512 234.6C512 217.6 505.3 201.3 493.3 189.3L386.7 82.7C374.7 70.7 358.5 64 341.5 64L192 64zM453.5 240L360 240C346.7 240 336 229.3 336 216L336 122.5L453.5 240z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="globe-solid-full">
    <path d="M415.9 344L225 344C227.9 408.5 242.2 467.9 262.5 511.4C273.9 535.9 286.2 553.2 297.6 563.8C308.8 574.3 316.5 576 320.5 576C324.5 576 332.2 574.3 343.4 563.8C354.8 553.2 367.1 535.8 378.5 511.4C398.8 467.9 413.1 408.5 416 344zM224.9 296L415.8 296C413 231.5 398.7 172.1 378.4 128.6C367 104.2 354.7 86.8 343.3 76.2C332.1 65.7 324.4 64 320.4 64C316.4 64 308.7 65.7 297.5 76.2C286.1 86.8 273.8 104.2 262.4 128.6C242.1 172.1 227.8 231.5 224.9 296zM176.9 296C180.4 210.4 202.5 130.9 234.8 78.7C142.7 111.3 74.9 195.2 65.5 296L176.9 296zM65.5 344C74.9 444.8 142.7 528.7 234.8 561.3C202.5 509.1 180.4 429.6 176.9 344L65.5 344zM463.9 344C460.4 429.6 438.3 509.1 406 561.3C498.1 528.6 565.9 444.8 575.3 344L463.9 344zM575.3 296C565.9 195.2 498.1 111.3 406 78.7C438.3 130.9 460.4 210.4 463.9 296L575.3 296z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="lightbulb-regular-full">
    <path d="M424.5 355.1C449 329.2 464 294.4 464 256C464 176.5 399.5 112 320 112C240.5 112 176 176.5 176 256C176 294.4 191 329.2 215.5 355.1C236.8 377.5 260.4 409.1 268.8 448L371.2 448C379.6 409 403.2 377.5 424.5 355.1zM459.3 388.1C435.7 413 416 443.4 416 477.7L416 496C416 540.2 380.2 576 336 576L304 576C259.8 576 224 540.2 224 496L224 477.7C224 443.4 204.3 413 180.7 388.1C148 353.7 128 307.2 128 256C128 150 214 64 320 64C426 64 512 150 512 256C512 307.2 492 353.7 459.3 388.1zM272 248C272 261.3 261.3 272 248 272C234.7 272 224 261.3 224 248C224 199.4 263.4 160 312 160C325.3 160 336 170.7 336 184C336 197.3 325.3 208 312 208C289.9 208 272 225.9 272 248z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="lightbulb-solid-full">
    <path d="M420.9 448C428.2 425.7 442.8 405.5 459.3 388.1C492 353.7 512 307.2 512 256C512 150 426 64 320 64C214 64 128 150 128 256C128 307.2 148 353.7 180.7 388.1C197.2 405.5 211.9 425.7 219.1 448L420.8 448zM416 496L224 496L224 512C224 556.2 259.8 592 304 592L336 592C380.2 592 416 556.2 416 512L416 496zM312 176C272.2 176 240 208.2 240 248C240 261.3 229.3 272 216 272C202.7 272 192 261.3 192 248C192 181.7 245.7 128 312 128C325.3 128 336 138.7 336 152C336 165.3 325.3 176 312 176z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="list-ul-solid-full">
    <path d="M112 208C138.5 208 160 186.5 160 160C160 133.5 138.5 112 112 112C85.5 112 64 133.5 64 160C64 186.5 85.5 208 112 208zM256 128C238.3 128 224 142.3 224 160C224 177.7 238.3 192 256 192L544 192C561.7 192 576 177.7 576 160C576 142.3 561.7 128 544 128L256 128zM256 288C238.3 288 224 302.3 224 320C224 337.7 238.3 352 256 352L544 352C561.7 352 576 337.7 576 320C576 302.3 561.7 288 544 288L256 288zM256 448C238.3 448 224 462.3 224 480C224 497.7 238.3 512 256 512L544 512C561.7 512 576 497.7 576 480C576 462.3 561.7 448 544 448L256 448zM112 528C138.5 528 160 506.5 160 480C160 453.5 138.5 432 112 432C85.5 432 64 453.5 64 480C64 506.5 85.5 528 112 528zM160 320C160 293.5 138.5 272 112 272C85.5 272 64 293.5 64 320C64 346.5 85.5 368 112 368C138.5 368 160 346.5 160 320z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="panorama-solid-full">
    <path d="M75.9 112C51.7 112 32 131.7 32 155.9L32 484.1C32 508.4 51.7 528 75.9 528C81.4 528 86.6 527 91.6 525.1C104.5 520.2 195 488 320 488C445 488 535.5 520.3 548.4 525.1C553.4 527 558.6 528 564.1 528C588.4 528 608 508.3 608 484.1L608 155.9C608 131.6 588.3 112 564.1 112C558.6 112 553.4 113 548.4 114.9C535.5 119.8 445 152 320 152C195 152 104.5 119.7 91.6 114.9C86.6 113 81.4 112 75.9 112zM104 240C104 217.9 121.9 200 144 200C166.1 200 184 217.9 184 240C184 262.1 166.1 280 144 280C121.9 280 104 262.1 104 240zM368.1 224C375.6 224 382.7 227.6 387.2 233.6L511.7 400.2C517.6 408.1 518.1 418.7 513 427.1C507.9 435.5 498.2 439.9 488.5 438.2C442.7 430.4 385.2 424 320.1 424C254.5 424 196.7 430.5 150.8 438.4C141 440.1 131.1 435.5 126.1 426.9C121.1 418.3 121.8 407.5 128 399.7L197.3 313C201.9 307.3 208.8 304 216 304C223.2 304 230.2 307.3 234.7 313L262.2 347.4L348.9 233.5C353.5 227.5 360.6 224 368.1 224z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="ring-solid-full">
    <path d="M128 272C128 279.8 132.4 290.7 145.1 302.3C190.5 278.1 252.8 264 320 264C387.2 264 449.5 278.1 494.9 302.3C507.7 290.7 512 279.8 512 272C512 259.7 501.2 240 464.1 221.4C428.9 203.8 378 192 320 192C262 192 211.1 203.8 175.9 221.4C138.8 240 128 259.7 128 272zM320 312C273 312 230.7 319.6 197.1 331.7C230.3 344.1 272.8 352 320 352C367.2 352 409.7 344.2 442.9 331.7C409.3 319.6 367 312 320 312zM64 272C64 222.4 103.4 186.2 147.3 164.2C193.1 141.3 254.3 128 320 128C385.7 128 446.9 141.3 492.7 164.2C536.6 186.2 576 222.4 576 272L576 368C576 417.6 536.6 453.8 492.7 475.8C446.8 498.7 385.7 512 320 512C254.3 512 193.1 498.7 147.3 475.8C103.4 453.8 64 417.6 64 368L64 272z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="ruler-combined-solid-full">
    <path d="M97 505.7C101.5 527.5 120.8 544 144 544L496 544C522.5 544 544 522.5 544 496L544 400C544 373.5 522.5 352 496 352L448 352L448 424C448 437.3 437.3 448 424 448C410.7 448 400 437.3 400 424L400 352L336 352L336 424C336 437.3 325.3 448 312 448C298.7 448 288 437.3 288 424L288 352L216 352C202.7 352 192 341.3 192 328C192 314.7 202.7 304 216 304L288 304L288 240L216 240C202.7 240 192 229.3 192 216C192 202.7 202.7 192 216 192L288 192L288 144C288 117.5 266.5 96 240 96L144 96C117.5 96 96 117.5 96 144L96 496C96 499.3 96.3 502.6 97 505.7z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="square-regular-full">
    <path d="M480 144C488.8 144 496 151.2 496 160L496 480C496 488.8 488.8 496 480 496L160 496C151.2 496 144 488.8 144 480L144 160C144 151.2 151.2 144 160 144L480 144zM160 96C124.7 96 96 124.7 96 160L96 480C96 515.3 124.7 544 160 544L480 544C515.3 544 544 515.3 544 480L544 160C544 124.7 515.3 96 480 96L160 96z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="sun-solid-full">
    <path d="M210.2 53.9C217.6 50.8 226 51.7 232.7 56.1L320.5 114.3L408.3 56.1C415 51.7 423.4 50.9 430.8 53.9C438.2 56.9 443.4 63.5 445 71.3L465.9 174.5L569.1 195.4C576.9 197 583.5 202.4 586.5 209.7C589.5 217 588.7 225.5 584.3 232.2L526.1 320L584.3 407.8C588.7 414.5 589.5 422.9 586.5 430.3C583.5 437.7 576.9 443.1 569.1 444.6L465.8 465.4L445 568.7C443.4 576.5 438 583.1 430.7 586.1C423.4 589.1 414.9 588.3 408.2 583.9L320.4 525.7L232.6 583.9C225.9 588.3 217.5 589.1 210.1 586.1C202.7 583.1 197.3 576.5 195.8 568.7L175 465.4L71.7 444.5C63.9 442.9 57.3 437.5 54.3 430.2C51.3 422.9 52.1 414.4 56.5 407.7L114.7 320L56.5 232.2C52.1 225.5 51.3 217.1 54.3 209.7C57.3 202.3 63.9 196.9 71.7 195.4L175 174.6L195.9 71.3C197.5 63.5 202.9 56.9 210.2 53.9zM239.6 320C239.6 275.6 275.6 239.6 320 239.6C364.4 239.6 400.4 275.6 400.4 320C400.4 364.4 364.4 400.4 320 400.4C275.6 400.4 239.6 364.4 239.6 320zM448.4 320C448.4 249.1 390.9 191.6 320 191.6C249.1 191.6 191.6 249.1 191.6 320C191.6 390.9 249.1 448.4 320 448.4C390.9 448.4 448.4 390.9 448.4 320z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="trash-solid-full">
    <path d="M232.7 69.9L224 96L128 96C110.3 96 96 110.3 96 128C96 145.7 110.3 160 128 160L512 160C529.7 160 544 145.7 544 128C544 110.3 529.7 96 512 96L416 96L407.3 69.9C402.9 56.8 390.7 48 376.9 48L263.1 48C249.3 48 237.1 56.8 232.7 69.9zM512 208L128 208L149.1 531.1C150.7 556.4 171.7 576 197 576L443 576C468.3 576 489.3 556.4 490.9 531.1L512 208z"></path>
  </symbol>
</svg>
    <div class="editor-container">
        <div class="controls-panel">
            <div class="controls-header">
                <h2 class="main-title">
                    <span>HDRI Studio 编辑器</span>
                    <button class="export-button" id="exportHdri"><svg class="icon"><use xlink:href="#download-solid-full"></use></svg> 导出 HDRI</button>
                </h2>
                <div class="control-group">
                    <label for="resolutionSelector"><svg class="icon"><use xlink:href="#ruler-combined-solid-full"></use></svg> 尺寸选择</label>
                    <select id="resolutionSelector">
                        <option value="1024x512">1024 × 512</option>
                        <option value="2048x1024" selected>2048 × 1024</option>
                        <option value="4096x2048">4096 × 2048</option>
                    </select>
                </div>
                <div class="button-group">
                    <button id="addCircleLight"><svg class="icon"><use xlink:href="#lightbulb-regular-full"></use></svg>
 圆形灯</button>
                    <button id="addRectLight"><svg class="icon"><use xlink:href="#square-regular-full"></use></svg>
 矩形灯</button>
                    <button id="addOctagonLight"><svg class="icon"><use xlink:href="#sun-solid-full"></use></svg>
八边形灯</button>
                    <button id="addRingLight"><svg class="icon"><use xlink:href="#ring-solid-full"></use></svg>
 环形灯</button>
                </div>
            </div>
            <div class="controls-content">
                <div id="lightControls"></div>
                <div class="control-section" id="modelControls">
                    <div class="control-header">
                        <h3><svg class="icon"><use xlink:href="#box-solid-full"></use></svg>
模型调节</h3>
                        <button class="delete-button" id="resetSceneBtn" title="恢复为球体"><svg class="icon"><use xlink:href="#arrow-rotate-left-solid-full"></use></svg>
 复位场景</button>
                    </div>
                    <div class="control-group">
                        <label for="modelScale">缩放</label>
                        <div class="value-display">
                            <input type="range" id="modelScale" min="0.1" max="10" value="1" step="0.01">
                            <input type="number" id="modelScaleValue" min="0.1" max="10" value="1" step="0.01">
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="modelPosX">位置 X</label>
                        <div class="value-display">
                            <input type="range" id="modelPosX" min="-5" max="5" value="0" step="0.01">
                            <input type="number" id="modelPosXValue" min="-5" max="5" value="0" step="0.01">
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="modelPosY">位置 Y</label>
                        <div class="value-display">
                            <input type="range" id="modelPosY" min="-5" max="5" value="0" step="0.01">
                            <input type="number" id="modelPosYValue" min="-5" max="5" value="0" step="0.01">
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="modelPosZ">位置 Z</label>
                        <div class="value-display">
                            <input type="range" id="modelPosZ" min="-5" max="5" value="0" step="0.01">
                            <input type="number" id="modelPosZValue" min="-5" max="5" value="0" step="0.01">
                        </div>
                    </div>
                </div>
                <div class="control-section" id="backgroundControlsContainer">
                    <div class="control-header">
                        <h3><svg class="icon"><use xlink:href="#globe-solid-full"></use></svg>
环境调节</h3>
                    </div>
                    <div class="tab-buttons">
                        <button class="tab-button active" data-tab="solid">纯色</button>
                        <button class="tab-button" data-tab="gradient">渐变</button>
                        <button class="tab-button" data-tab="image">图片</button>
                    </div>
                    <div id="solidTab" class="tab-content active">
                        <div class="control-group">
                            <label for="bgColor">颜色</label>
                            <div class="color-input-wrapper">
                                <input type="color" id="bgColor" value="#202025">
                            </div>
                        </div>
                    </div>
                    <div id="gradientTab" class="tab-content">
                        <div class="control-group">
                            <label for="gradientColor1">颜色 1 (天空)</label>
                            <input type="color" id="gradientColor1" value="#1a73e8">
                        </div>
                        <div class="control-group">
                            <label for="gradientColor2">颜色 2 (地面)</label>
                            <input type="color" id="gradientColor2" value="#aaaaa1">
                        </div>
                        <div class="control-group">
                            <label for="gradientAngle">角度</label>
                            <div class="value-display">
                                <input type="range" id="gradientAngle" min="0" max="360" value="90" step="1">
                                <input type="number" id="gradientAngleValue" min="0" max="360" value="90" step="1">
                            </div>
                        </div>
                    </div>
                    <div id="imageTab" class="tab-content">
                        <div class="control-group">
                            <input type="file" id="imageUpload" accept="image/*">
                            <label for="imageUpload" id="imageUploadLabel"><svg class="icon"><use xlink:href="#cloud-arrow-up-solid-full"></use></svg>
点击上传图片</label>
                        </div>
                    </div>
                    <div class="control-group" style="margin-top:20px;">
                        <label for="bgRotation">旋转</label>
                        <div class="value-display">
                            <input type="range" id="bgRotation" min="0" max="360" value="0" step="1">
                            <input type="number" id="bgRotationValue" min="0" max="360" value="0" step="1">
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="bgBrightness">亮度</label>
                        <div class="value-display">
                            <input type="range" id="bgBrightness" min="0" max="5" value="1" step="0.01">
                            <input type="number" id="bgBrightnessValue" min="0" max="5" value="1" step="0.01">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="preview-panel">
            <div class="preview-box top-preview">
                <div class="preview-header">
                    <h3><svg class="icon"><use xlink:href="#panorama-solid-full"></use></svg>
二维视图 & 灯光列表
                        <span class="scripts">点击左侧添加灯光，选中画布中的灯光进行编辑</span>
                    </h3>
                </div>
                <div class="top-preview-content">
                    <div id="hdr-canvas-wrapper">
                        <canvas id="hdrCanvas"></canvas>
                    </div>
                    <div id="vertical-resize-handle"></div>
                    <div id="light-list-panel">
                        <div class="preview-header">
                            <h3><svg class="icon"><use xlink:href="#list-ul-solid-full"></use></svg>
 灯光列表
                                <span class="scripts">支持隐藏和删除</span>
                            </h3>
                        </div>
                        <ul id="light-list-items"></ul>
                    </div>
                </div>
            </div>
            <div class="resize-handle" id="resizeHandle"></div>
            <div class="preview-box bottom-preview">
                <div class="preview-header">
                    <h3><svg class="icon"><use xlink:href="#cube-solid-full"></use></svg>
 3D环境预览
                        <span class="scripts">支持obj、fbx、glb格式的外部模型导入</span>
                    </h3>
                    <input type="file" id="modelUpload" accept=".obj,.glb,.gltf,.fbx">
                    <button id="importModelBtn" class="import-model-button"><svg class="icon"><use xlink:href="#file-import-solid-full"></use></svg>
导入模型</button>
                </div>
                <canvas id="sceneCanvas"></canvas>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

        // 常量 & 状态
        const hdrCanvas = document.getElementById('hdrCanvas');
        const sceneCanvas = document.getElementById('sceneCanvas');
        const PI = Math.PI;
        const TWO_PI = 2 * PI;

        let HDR_WIDTH = 2048, HDR_HEIGHT = 1024;
        let lights = [];
        let lightTypeCounters = {};
        let selectedLight = null;
        let addingLightType = null;
        let draggingLight = null;
        
        // 拖动状态
        let isResizingVertical = false;
        let startY = 0, startTopHeight = 0, startBottomHeight = 0;
        let isResizingHorizontal = false;
        let startX = 0, startCanvasWidth = 0, startListWidth = 0;

        // 用于合成的临时画布
        let tempHdrCanvas, tempHdrCtx;

        let background = {
            type: 'solid',
            color: '#202025',
            gradient: { color1: '#1a73e8', color2: '#aaaaa1', angle: 90 },
            image: null,
            brightness: 1.0,
            rotation: 0,
        };

        let scene, camera, renderer, originalSphere, controls, envTexture;
        let currentModel = null;

        // 球面投影辅助函数
        function pixelsToSpherical(x, y, width, height) {
            const lon = (x / width) * TWO_PI - PI;
            const lat = (y / height) * PI - PI / 2;
            return { lon, lat };
        }

        function sphericalToPixels(lon, lat, width, height) {
            const x = ((lon + PI) / TWO_PI) * width;
            const y = ((lat + PI / 2) / PI) * height;
            return { x, y };
        }

        function angularDistance(lon1, lat1, lon2, lat2) {
            const dLon = Math.abs(lon2 - lon1);
            const sinDLon = Math.sin(dLon/2);
            const sinDLat = Math.sin((lat2-lat1)/2);
            const a = sinDLat*sinDLat + Math.cos(lat1)*Math.cos(lat2)*sinDLon*sinDLon;
            return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }

        function getDestinationPoint(startLon, startLat, bearing, angularDistance) {
            const δ = angularDistance;
            const φ1 = startLat;
            const λ1 = startLon;
            const θ = bearing;

            const sin_φ1 = Math.sin(φ1);
            const cos_φ1 = Math.cos(φ1);
            const sin_δ = Math.sin(δ);
            const cos_δ = Math.cos(δ);
            const sin_θ = Math.sin(θ);
            const cos_θ = Math.cos(θ);

            const sin_φ2 = sin_φ1 * cos_δ + cos_φ1 * sin_δ * cos_θ;
            const φ2 = Math.asin(sin_φ2);
            
            const y = sin_θ * sin_δ * cos_φ1;
            const x = cos_δ - sin_φ1 * sin_φ2;
            
            const λ2 = λ1 + Math.atan2(y, x);
            
            return { lon: λ2, lat: φ2 };
        }

        function sRGBToLinear(c) {
            return (c < 0.04045) ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
        }

        function hexToLinear(hex) {
            const rgb = hexToRgb(hex);
            return {
                r: sRGBToLinear(rgb.r / 255.0),
                g: sRGBToLinear(rgb.g / 255.0),
                b: sRGBToLinear(rgb.b / 255.0)
            };
        }

        function init3DScene() {
            try {
                scene = new THREE.Scene();
                renderer = new THREE.WebGLRenderer({
                    canvas: sceneCanvas,
                    antialias: true,
                    alpha: true,
                    logarithmicDepthBuffer: true
                });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 4.0;
                renderer.outputColorSpace = THREE.SRGBColorSpace;

                camera = new THREE.PerspectiveCamera(75, sceneCanvas.clientWidth / sceneCanvas.clientHeight, 0.1, 1000);
                camera.position.z = 2.5;

                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.screenSpacePanning = false;
                controls.minDistance = 1.5;
                controls.maxDistance = 5;

                const geometry = new THREE.SphereGeometry(1, 128, 64);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x787878,
                    metalness: 0.1,
                    roughness: 0.1,
                    side: THREE.DoubleSide
                });
                originalSphere = new THREE.Mesh(geometry, material);
                scene.add(originalSphere);
                currentModel = originalSphere;
                
                const gridHelper = new THREE.GridHelper(10, 10, 0x3333330d, 0x0000000d);
                scene.add(gridHelper);
                const axesHelper = new THREE.AxesHelper(1.5);
                scene.add(axesHelper);

                animate();
                resize3DCanvas();
                updateStatus("3D场景初始化成功", true);
            } catch (e) {
                console.error("初始化3D失败", e);
                updateStatus(`3D场景错误: ${e.message}`, false);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();
            if (renderer && scene && camera) renderer.render(scene, camera);
        }

        function resize3DCanvas() {
            if (!renderer || !camera) return;
            const previewBox = sceneCanvas.parentElement;
            if (!previewBox) return;
            const { clientWidth, clientHeight } = previewBox;
            const headerHeight = previewBox.querySelector('.preview-header').offsetHeight;
            const finalHeight = clientHeight - headerHeight - 15;
            
            renderer.setSize(clientWidth, finalHeight, false);
            camera.aspect = clientWidth / finalHeight;
            camera.updateProjectionMatrix();
        }
        
       function updateLightListUI() {
            const container = document.getElementById('light-list-items');
            container.innerHTML = '';
            
            const typeTranslations = {
                circle: '圆形灯', rect: '矩形灯', octagon: '八边形灯', ring: '环形灯'
            };

            // --- 修改开始 ---
            // 1. 将 typeIcons 的值从 CSS 类名改为 SVG symbol ID
            const typeIcons = {
                circle: 'lightbulb-regular-full', 
                rect: 'square-regular-full', 
                octagon: 'sun-solid-full', 
                ring: 'ring-solid-full'
            };

            lights.forEach(light => {
                const li = document.createElement('li');
                li.className = 'light-item';
                li.dataset.id = light.id;
                if (selectedLight && light.id === selectedLight.id) {
                    li.classList.add('active');
                }

                // 2. 获取正确的 iconId，并为未知类型提供一个后备ID
                const iconId = typeIcons[light.type] || 'box-solid-full'; // 使用 box-solid-full 作为后备图标
                const name = `${typeTranslations[light.type] || '未知'} ${light.displayId}`;
                
                // 3. 将可见性图标也改为 symbol ID
                const visibilityIconId = light.visible ? 'eye-solid-full' : 'eye-slash-solid-full';

                // 4. 更新 innerHTML，用 <svg> 替换 <i> 标签
                li.innerHTML = `
                    <span class="icon" style="color: ${light.color};"><svg class="icon"><use xlink:href="#${iconId}"></use></svg></span>
                    <span class="name">${name}</span>
                    <div class="actions">
                        <button class="toggle-visibility" title="切换可见性"><svg class="icon"><use xlink:href="#${visibilityIconId}"></use></svg></button>
                        <button class="delete-from-list" title="删除灯光"><svg class="icon"><use xlink:href="#trash-solid-full"></use></svg></button>
                    </div>
                `;
                // --- 修改结束 ---

                li.addEventListener('click', (e) => {
                    if (e.target.closest('.actions')) return;
                    selectedLight = lights.find(l => l.id === light.id);
                    updateControlsUI();
                    drawHdrPreview();
                    updateLightListUI();
                });

                li.querySelector('.toggle-visibility').addEventListener('click', () => {
                    light.visible = !light.visible;
                    drawHdrPreview();
                    updateLightListUI();
                });

                li.querySelector('.delete-from-list').addEventListener('click', () => {
                    deleteLightById(light.id);
                });

                container.appendChild(li);
            });
        }
        
        function deleteLightById(id) {
            if (selectedLight && selectedLight.id === id) {
                selectedLight = null;
            }
            lights = lights.filter(l => l.id !== id);
            updateControlsUI();
            drawHdrPreview();
            updateLightListUI();
        }

        function getProjectionFactors(light) {
            const latitude = (light.y / HDR_HEIGHT - 0.5) * PI;
            const cosLat = Math.cos(latitude);
            const scaleX = 1 / Math.max(cosLat, 0.05);
            const scaleY = cosLat;
            return { scaleX, scaleY };
        }
        
        function createCirclePath(ctx, light, offsetX = 0) {
            const center = pixelsToSpherical(light.x, light.y, HDR_WIDTH, HDR_HEIGHT);
            const angularRadius = (light.size / HDR_WIDTH) * TWO_PI;
            const segments = 64;

            ctx.beginPath();

            for (let i = 0; i <= segments; i++) {
                const bearing = (i / segments) * TWO_PI;
                const dest = getDestinationPoint(center.lon, center.lat, bearing, angularRadius);
                const pixel = sphericalToPixels(dest.lon, dest.lat, HDR_WIDTH, HDR_HEIGHT);
                
                const x = pixel.x + offsetX;
                const y = pixel.y;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    const prevDest = getDestinationPoint(center.lon, center.lat, ((i - 1) / segments) * TWO_PI, angularRadius);
                    const prevPoint = sphericalToPixels(prevDest.lon, prevDest.lat, HDR_WIDTH, HDR_HEIGHT);
                    if (Math.abs(pixel.x - prevPoint.x) < HDR_WIDTH * 0.8) {
                         ctx.lineTo(x, y);
                    } else {
                         ctx.moveTo(x,y);
                    }
                }
            }
            ctx.closePath();
        }

        function createRectPath(ctx, light, offsetX = 0) {
            const { scaleX, scaleY } = getProjectionFactors(light);
            const rotation = light.rotation || 0;
            const cornerRadius = Math.min(light.cornerRadius || 0, light.width / 2, light.height / 2);

            ctx.save();
            ctx.translate(light.x + offsetX, light.y);
            ctx.rotate(rotation * Math.PI / 180);
            ctx.scale(scaleX, scaleY);

            const halfW = light.width / 2;
            const halfH = light.height / 2;
            
            ctx.beginPath();
            ctx.moveTo(-halfW + cornerRadius, -halfH);
            ctx.lineTo(halfW - cornerRadius, -halfH);
            ctx.arcTo(halfW, -halfH, halfW, -halfH + cornerRadius, cornerRadius);
            ctx.lineTo(halfW, halfH - cornerRadius);
            ctx.arcTo(halfW, halfH, halfW - cornerRadius, halfH, cornerRadius);
            ctx.lineTo(-halfW + cornerRadius, halfH);
            ctx.arcTo(-halfW, halfH, -halfW, halfH - cornerRadius, cornerRadius);
            ctx.lineTo(-halfW, -halfH + cornerRadius);
            ctx.arcTo(-halfW, -halfH, -halfW + cornerRadius, -halfH, cornerRadius);
            ctx.closePath();
            ctx.restore();
        }
        
        function createOctagonPath(ctx, light, offsetX = 0) {
            const center = pixelsToSpherical(light.x, light.y, HDR_WIDTH, HDR_HEIGHT);
            const angularRadius = (light.size / HDR_WIDTH) * TWO_PI;
            const points = 8;
            const rotation = (light.rotation || 0) * PI / 180;

            ctx.beginPath();
            for (let i = 0; i <= points; i++) {
                const bearing = (i / points) * TWO_PI + rotation;
                const dest = getDestinationPoint(center.lon, center.lat, bearing, angularRadius);
                const pixel = sphericalToPixels(dest.lon, dest.lat, HDR_WIDTH, HDR_HEIGHT);
                
                const x = pixel.x + offsetX;
                const y = pixel.y;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    const prevDest = getDestinationPoint(center.lon, center.lat, (((i - 1) / points) * TWO_PI + rotation), angularRadius);
                    const prevPoint = sphericalToPixels(prevDest.lon, prevDest.lat, HDR_WIDTH, HDR_HEIGHT);
                    if (Math.abs(pixel.x - prevPoint.x) < HDR_WIDTH * 0.8) {
                         ctx.lineTo(x, y);
                    } else {
                         ctx.moveTo(x,y);
                    }
                }
            }
            ctx.closePath();
        }

        function createRingPath(ctx, light, offsetX = 0) {
            const center = pixelsToSpherical(light.x, light.y, HDR_WIDTH, HDR_HEIGHT);
            const rotation = (light.rotation || 0) * PI / 180;
            
            const outerAngularRadius = (light.size / HDR_WIDTH) * TWO_PI;
            const thicknessAngular = ((light.thickness || (light.size * 0.3)) / HDR_WIDTH) * TWO_PI;
            const innerAngularRadius = Math.max(0, outerAngularRadius - thicknessAngular);
            
            const segments = 64;

            ctx.beginPath();
            for (let i = 0; i <= segments; i++) {
                const bearing = (i / segments) * TWO_PI + rotation;
                const dest = getDestinationPoint(center.lon, center.lat, bearing, outerAngularRadius);
                const pixel = sphericalToPixels(dest.lon, dest.lat, HDR_WIDTH, HDR_HEIGHT);
                const x = pixel.x + offsetX;
                const y = pixel.y;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    const prevDest = getDestinationPoint(center.lon, center.lat, (((i-1) / segments) * TWO_PI + rotation), outerAngularRadius);
                    const prevPoint = sphericalToPixels(prevDest.lon, prevDest.lat, HDR_WIDTH, HDR_HEIGHT);
                    if (Math.abs(pixel.x - prevPoint.x) < HDR_WIDTH * 0.8) {
                        ctx.lineTo(x, y);
                    } else {
                        ctx.moveTo(x, y);
                    }
                }
            }
            
            for (let i = segments; i >= 0; i--) {
                const bearing = (i / segments) * TWO_PI + rotation;
                const dest = getDestinationPoint(center.lon, center.lat, bearing, innerAngularRadius);
                const pixel = sphericalToPixels(dest.lon, dest.lat, HDR_WIDTH, HDR_HEIGHT);
                const x = pixel.x + offsetX;
                const y = pixel.y;
                
                if (i === segments) {
                     ctx.moveTo(x,y);
                } else {
                    const prevDest = getDestinationPoint(center.lon, center.lat, (((i+1) / segments) * TWO_PI + rotation), innerAngularRadius);
                    const prevPoint = sphericalToPixels(prevDest.lon, prevDest.lat, HDR_WIDTH, HDR_HEIGHT);

                    if (Math.abs(pixel.x - prevPoint.x) < HDR_WIDTH * 0.8) {
                        ctx.lineTo(x, y);
                    } else {
                        ctx.moveTo(x, y);
                    }
                }
            }

            ctx.closePath();
        }

        function drawHdrPreview() {
            if (!tempHdrCtx) return; 

            tempHdrCtx.globalCompositeOperation = 'source-over';
            tempHdrCtx.fillStyle = background.color;
            tempHdrCtx.fillRect(0, 0, HDR_WIDTH, HDR_HEIGHT);

            switch (background.type) {
                case 'image':
                    if (background.image) {
                        const imgRatio = background.image.width / background.image.height;
                        const canvasRatio = HDR_WIDTH / HDR_HEIGHT;
                        let drawWidth, drawHeight, offsetX, offsetY;
                        if (imgRatio > canvasRatio) {
                            drawHeight = HDR_HEIGHT;
                            drawWidth = background.image.width * (HDR_HEIGHT / background.image.height);
                            offsetX = (HDR_WIDTH - drawWidth) / 2; offsetY = 0;
                        } else {
                            drawWidth = HDR_WIDTH;
                            drawHeight = background.image.height * (HDR_WIDTH / background.image.width);
                            offsetX = 0; offsetY = (HDR_HEIGHT - drawHeight) / 2;
                        }
                        tempHdrCtx.drawImage(background.image, offsetX, offsetY, drawWidth, drawHeight);
                    }
                    break;
                case 'gradient':
                    const angleRad = background.gradient.angle * PI / 180;
                    const x1 = HDR_WIDTH / 2 - Math.cos(angleRad) * HDR_WIDTH / 2;
                    const y1 = HDR_HEIGHT / 2 - Math.sin(angleRad) * HDR_HEIGHT / 2;
                    const x2 = HDR_WIDTH / 2 + Math.cos(angleRad) * HDR_WIDTH / 2;
                    const y2 = HDR_HEIGHT / 2 + Math.sin(angleRad) * HDR_HEIGHT / 2;
                    const grad = tempHdrCtx.createLinearGradient(x1, y1, x2, y2);
                    grad.addColorStop(0, background.gradient.color1);
                    grad.addColorStop(1, background.gradient.color2);
                    tempHdrCtx.fillStyle = grad;
                    tempHdrCtx.fillRect(0, 0, HDR_WIDTH, HDR_HEIGHT);
                    break;
            }
            
            tempHdrCtx.save();
            tempHdrCtx.filter = `brightness(${background.brightness})`;
            tempHdrCtx.globalCompositeOperation = 'copy';
            tempHdrCtx.drawImage(tempHdrCanvas, 0, 0);
            tempHdrCtx.restore();

            tempHdrCtx.globalCompositeOperation = 'lighter';
            lights.forEach(light => {
                if (!light.visible) return;

                const offsets = [0];
                const effectiveRadius = (light.size || Math.max(light.width || 0, light.height || 0)) * 1.5 + (light.falloff || 0);

                if (light.x - effectiveRadius < 0) offsets.push(HDR_WIDTH);
                if (light.x + effectiveRadius > HDR_WIDTH) offsets.push(-HDR_WIDTH);

                offsets.forEach(offsetX => {
                    tempHdrCtx.save();
                    if (light.type === 'circle') createCirclePath(tempHdrCtx, light, offsetX);
                    else if (light.type === 'rect') createRectPath(tempHdrCtx, light, offsetX);
                    else if (light.type === 'octagon') createOctagonPath(tempHdrCtx, light, offsetX);
                    else if (light.type === 'ring') createRingPath(tempHdrCtx, light, offsetX);

                    const rgb = hexToRgb(light.color);
                    const r = rgb.r, g = rgb.g, b = rgb.b;
                    const displayAlpha = Math.min(light.intensity / 15, 1.0);
                    const fullColorRgba = `rgba(${r}, ${g}, ${b}, ${displayAlpha})`;
                    
                    if (light.innerShadow > 0 && light.type !== 'ring') {
                        tempHdrCtx.clip();
                        const { scaleX } = getProjectionFactors(light);
                        const gradRadius = (light.size || Math.max(light.width || 0, light.height || 0)) * scaleX;
                        const grad = tempHdrCtx.createRadialGradient(light.x + offsetX, light.y, 0, light.x + offsetX, light.y, gradRadius);
                        const solidRatio = Math.max(0, 1.0 - light.innerShadow);
                        const min_attenuation = 0.1;
                        const edgeAlpha = displayAlpha * min_attenuation;
                        const edgeRgba = `rgba(${r}, ${g}, ${b}, ${edgeAlpha})`;
                        grad.addColorStop(0, fullColorRgba);
                        grad.addColorStop(solidRatio, fullColorRgba);
                        grad.addColorStop(1, edgeRgba);
                        tempHdrCtx.fillStyle = grad;
                        tempHdrCtx.fillRect(0, 0, HDR_WIDTH, HDR_HEIGHT);
                    } else {
                        tempHdrCtx.shadowColor = `rgba(${r}, ${g}, ${b}, ${displayAlpha})`;
                        tempHdrCtx.shadowBlur = light.falloff;
                        tempHdrCtx.fillStyle = fullColorRgba;
                        if (light.type === 'ring') {
                             tempHdrCtx.fill('evenodd');
                        } else {
                             tempHdrCtx.fill();
                        }
                    }
                    tempHdrCtx.restore();
                });
            });

            if (selectedLight && selectedLight.visible) {
                const offsets = [0];
                const effectiveRadius = (selectedLight.size || Math.max(selectedLight.width || 0, selectedLight.height || 0)) * 1.5 + (selectedLight.falloff || 0);
                if (selectedLight.x - effectiveRadius < 0) offsets.push(HDR_WIDTH);
                if (selectedLight.x + effectiveRadius > HDR_WIDTH) offsets.push(-HDR_WIDTH);

                offsets.forEach(offsetX => {
                    tempHdrCtx.save();
                    tempHdrCtx.globalCompositeOperation = 'source-over';
                    if (selectedLight.type === 'circle') createCirclePath(tempHdrCtx, selectedLight, offsetX);
                    else if (selectedLight.type === 'rect') createRectPath(tempHdrCtx, selectedLight, offsetX);
                    else if (selectedLight.type === 'octagon') createOctagonPath(tempHdrCtx, selectedLight, offsetX);
                    else if (selectedLight.type === 'ring') createRingPath(tempHdrCtx, selectedLight, offsetX);
                    tempHdrCtx.lineWidth = 5 * (HDR_WIDTH / 2048);
                    tempHdrCtx.setLineDash([10, 4]);
                    tempHdrCtx.strokeStyle = 'rgba(128,128,255,0.9)';
                    tempHdrCtx.stroke();
                    tempHdrCtx.restore();
                });
            }

            const ctx = hdrCanvas.getContext('2d');
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, HDR_WIDTH, HDR_HEIGHT);
            const rotationOffset = (background.rotation / 360) * HDR_WIDTH;
            
            ctx.drawImage(tempHdrCanvas, -rotationOffset, 0);
            ctx.drawImage(tempHdrCanvas, -rotationOffset + HDR_WIDTH, 0);

            update3DScene();
        }

        function update3DScene() {
            try {
                if (envTexture) {
                    envTexture.dispose();
                }
                
                envTexture = new THREE.CanvasTexture(hdrCanvas);
                envTexture.mapping = THREE.EquirectangularReflectionMapping;
                envTexture.colorSpace = THREE.SRGBColorSpace;
                
                if (scene) {
                    scene.environment = envTexture;
                    scene.background = envTexture;
                    
                    if (currentModel) {
                        currentModel.traverse((child) => {
                            if (child.isMesh && child.material) {
                                const materials = Array.isArray(child.material) ? child.material : [child.material];
                                materials.forEach(material => {
                                    if (material.isMeshStandardMaterial || material.isMeshPhysicalMaterial) {
                                        material.envMap = envTexture;
                                        material.needsUpdate = true;
                                    }
                                });
                            }
                        });
                    }
                }
            } catch (e) {
                console.error("更新3D场景失败", e);
            }
        }
        
function updateControlsUI() {
            const container = document.getElementById('lightControls');
            container.innerHTML = '';
            updateLightListUI();
            if (!selectedLight) return;

            // --- 修改开始 ---
            // 1. 将 icon 变量的值从 Font Awesome 类名后缀改为完整的 SVG symbol ID
            const iconId = selectedLight.type === 'circle' ? 'lightbulb-solid-full' :
                         selectedLight.type === 'rect' ? 'square-regular-full' :
                         selectedLight.type === 'octagon' ? 'sun-solid-full' :
                         'ring-solid-full';
            
            const typeName = selectedLight.type === 'circle' ? '圆形灯光' :
                             selectedLight.type === 'rect' ? '矩形灯光' :
                             selectedLight.type === 'octagon' ? '八边形灯光' :
                             '环形灯光';
            
            // 2. 更新 HTML 模板字符串，用 <svg> 替换 <i> 标签
            let html = `<div class="control-section">
                <div class="control-header">
                    <h3><svg class="icon"><use xlink:href="#${iconId}"></use></svg> ${typeName} ${selectedLight.displayId}</h3>
                    <button class="delete-button" id="deleteLightBtn"><svg class="icon"><use xlink:href="#trash-solid-full"></use></svg></button>
                </div>`;
            // --- 修改结束 ---

            if (selectedLight.type === 'circle') {
                html += createSlider('size', '大小', 10, 500, 1, selectedLight.size);
            } else if (selectedLight.type === 'rect') {
                html += createSlider('width', '宽度', 10, 500, 1, selectedLight.width);
                html += createSlider('height', '高度', 10, 500, 1, selectedLight.height);
                html += createSlider('cornerRadius', '圆角半径', 0, 100, 1, selectedLight.cornerRadius || 0);
                html += createSlider('rotation', '旋转', 0, 360, 1, selectedLight.rotation || 0);
            } else if (selectedLight.type === 'octagon') {
                html += createSlider('size', '大小', 10, 500, 1, selectedLight.size);
                html += createSlider('rotation', '旋转', 0, 360, 1, selectedLight.rotation || 0);
            } else if (selectedLight.type === 'ring') {
                html += createSlider('size', '外半径', 10, 500, 1, selectedLight.size);
                html += createSlider('thickness', '环厚度', 1, 200, 1, selectedLight.thickness || (selectedLight.size * 0.3));
                html += createSlider('rotation', '旋转', 0, 360, 1, selectedLight.rotation || 0);
            }
            html += createColorInput('color', '颜色', selectedLight.color);
            
            const useTemperature = selectedLight.useTemperature || false;
            const temperature = selectedLight.temperature || 6500;
            html += `
                <div class="control-group">
                    <div class="temperature-toggle">
                        <input type="checkbox" id="useTemperature" ${useTemperature ? 'checked' : ''}>
                        <label for="useTemperature">使用色温(K)</label>
                    </div>
                    <div class="temperature-control ${useTemperature ? 'active' : ''}">
                        <label for="temperature"> </label>
                        <div class="value-display">
                            <input type="range" id="temperature" min="1000" max="30000" step="100" value="${temperature}">
                            <input type="number" id="temperatureValue" min="1000" max="30000" step="100" value="${temperature}">
                        </div>
                    </div>
                </div>
            `;
            
            html += createSlider('intensity', '亮度 (HDR)', 0.1, 25, 0.1, selectedLight.intensity);
            html += createSlider('falloff', '外侧衰减', 0, 100, 1, selectedLight.falloff);
            html += createSlider('innerShadow', '内侧柔化', 0, 1, 0.01, selectedLight.innerShadow || 0);
            html += `</div>`;
            container.innerHTML = html;
            addControlListeners();
            
            if (useTemperature) {
                document.getElementById('color').parentElement.classList.add('disabled-color');
            }
        }

        function createSlider(id, label, min, max, step, value) {
            return `<div class="control-group">
                        <label for="${id}">${label}</label>
                        <div class="value-display">
                            <input type="range" id="${id}" min="${min}" max="${max}" step="${step}" value="${value}">
                            <input type="number" id="${id}Value" min="${min}" max="${max}" step="${step}" value="${value}">
                        </div>
                    </div>`;
        }

        function createColorInput(id, label, value) {
            return `<div class="control-group">
                        <label for="${id}">${label}</label>
                        <div class="color-input-wrapper">
                          <input type="color" id="${id}" value="${value}">
                          <input type="text" id="${id}Text" value="${value}">
                        </div>
                    </div>`;
        }
        
        function temperatureToRGB(kelvin) {
            kelvin = Math.max(1000, Math.min(40000, kelvin));
            let temp = kelvin / 100;
            let r, g, b;
            
            if (temp <= 66) {
                r = 255;
                g = 99.4708025861 * Math.log(temp) - 161.1195681661;
            } else {
                r = 329.698727446 * Math.pow(temp - 60, -0.1332047592);
                g = 288.1221695283 * Math.pow(temp - 60, -0.0755148492);
            }
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            
            if (temp >= 66) {
                b = 255;
            } else if (temp <= 19) {
                b = 0;
            } else {
                b = 138.5177312231 * Math.log(temp - 10) - 305.0447927307;
                b = Math.max(0, Math.min(255, b));
            }
            
            const hex = `#${Math.round(r).toString(16).padStart(2, '0')}${Math.round(g).toString(16).padStart(2, '0')}${Math.round(b).toString(16).padStart(2, '0')}`;
            return hex;
        }
        
        function handleModelUpload(event) {
            const fileInput = event.target;
            const file = fileInput.files[0];
            if (!file) return;

            const url = URL.createObjectURL(file);
            const filename = file.name.toLowerCase();
            let loader;

            if (filename.endsWith('.glb') || filename.endsWith('.gltf')) {
                loader = new GLTFLoader();
            } else if (filename.endsWith('.obj')) {
                loader = new OBJLoader();
            } else if (filename.endsWith('.fbx')) {
                loader = new FBXLoader();
            } else {
                updateStatus('不支持的文件格式', false);
                return;
            }

            updateStatus('正在加载模型...', true);
            loader.load(url, (loadedObject) => {
                const model = filename.endsWith('.gltf') || filename.endsWith('.glb') ? loadedObject.scene : loadedObject;
                
                if (currentModel) {
                    scene.remove(currentModel);
                }
                
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 2.0 / maxDim;
                
                model.userData.initialScale = scale;
                model.scale.set(scale, scale, scale);
                model.position.sub(center.multiplyScalar(scale));

                const lightsToRemove = [];
                model.traverse((child) => {
                    if (child.isLight) {
                        lightsToRemove.push(child);
                    }

                    if (child.isMesh) {
                        let materials = [];
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                materials = child.material;
                            } else {
                                materials = [child.material];
                            }
                        }

                        if (materials.length === 0) {
                            child.material = new THREE.MeshStandardMaterial({
                                color: 0xffffff,
                                roughness: 0.8,
                                metalness: 0.05,
                                envMap: scene.environment
                            });
                        } else {
                            const newMaterials = materials.map(mat => {
                                if (!mat.isMeshStandardMaterial && !mat.isMeshPhysicalMaterial) {
                                    const newMat = new THREE.MeshStandardMaterial({
                                        color: mat.color ? mat.color.clone() : new THREE.Color(0xffffff),
                                        map: mat.map || null,
                                        roughness: mat.roughness || 0.8,
                                        metalness: mat.metalness || 0.05,
                                        envMap: scene.environment,
                                        side: THREE.DoubleSide
                                    });
                                    if (mat.map) {
                                        newMat.map.colorSpace = THREE.SRGBColorSpace;
                                    }
                                    return newMat;
                                } else {
                                    mat.envMap = scene.environment;
                                    mat.needsUpdate = true;
                                    return mat;
                                }
                            });
                            child.material = Array.isArray(child.material) ? newMaterials : newMaterials[0];
                        }
                    }
                });
                
                lightsToRemove.forEach(light => light.removeFromParent());

                scene.add(model);
                currentModel = model;
                URL.revokeObjectURL(url);
                updateStatus('模型加载成功', true);
                
                document.getElementById('modelControls').style.display = 'block';
                document.getElementById('modelScale').value = 1;
                document.getElementById('modelScaleValue').value = 1;
                document.getElementById('modelPosX').value = 0;
                document.getElementById('modelPosXValue').value = 0;
                document.getElementById('modelPosY').value = 0;
                document.getElementById('modelPosYValue').value = 0;
                document.getElementById('modelPosZ').value = 0;
                document.getElementById('modelPosZValue').value = 0;
                
            }, undefined, (error) => {
                console.error('模型加载失败:', error);
                updateStatus('模型加载失败', false);
                URL.revokeObjectURL(url);
            });

            fileInput.value = null;
        }

        function resetScene() {
            if (currentModel && currentModel !== originalSphere) {
                scene.remove(currentModel);
            }
            scene.add(originalSphere);
            currentModel = originalSphere;
            document.getElementById('modelControls').style.display = 'none';
            updateStatus('场景已复位', true);
        }

        function addModelControlListeners() {
            const controls = [
                { id: 'modelScale', valueId: 'modelScaleValue', prop: 'scale' },
                { id: 'modelPosX', valueId: 'modelPosXValue', prop: 'position', axis: 'x' },
                { id: 'modelPosY', valueId: 'modelPosYValue', prop: 'position', axis: 'y' },
                { id: 'modelPosZ', valueId: 'modelPosZValue', prop: 'position', axis: 'z' },
            ];

            controls.forEach(c => {
                const slider = document.getElementById(c.id);
                const valueInput = document.getElementById(c.valueId);

                const updateModelTransform = (val) => {
                    if (currentModel && currentModel !== originalSphere) {
                        if (c.prop === 'scale') {
                            const initialScale = currentModel.userData.initialScale || 1.0;
                            currentModel.scale.set(val * initialScale, val * initialScale, val * initialScale);
                        } else {
                            currentModel.position[c.axis] = val;
                        }
                    }
                };

                slider.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    valueInput.value = val;
                    updateModelTransform(val);
                });
                valueInput.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value) || 0;
                    slider.value = val;
                    updateModelTransform(val);
                });
            });

            document.getElementById('resetSceneBtn').addEventListener('click', resetScene);
        }
        
        function initResizeEvents() {
            const verticalHandle = document.getElementById('resizeHandle');
            verticalHandle.addEventListener('mousedown', startVerticalResize);

            const horizontalHandle = document.getElementById('vertical-resize-handle');
            horizontalHandle.addEventListener('mousedown', startHorizontalResize);

            window.addEventListener('mousemove', (e) => {
                if (isResizingVertical) handleVerticalResize(e);
                if (isResizingHorizontal) handleHorizontalResize(e);
            });
            window.addEventListener('mouseup', () => {
                isResizingVertical = false;
                isResizingHorizontal = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            });
        }
        
        function startVerticalResize(e) {
            isResizingVertical = true;
            startY = e.clientY;
            const topPreview = document.querySelector('.top-preview');
            const bottomPreview = document.querySelector('.bottom-preview');
            startTopHeight = topPreview.offsetHeight;
            startBottomHeight = bottomPreview.offsetHeight;
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        }

        function handleVerticalResize(e) {
            if (!isResizingVertical) return;
            const topPreview = document.querySelector('.top-preview');
            const bottomPreview = document.querySelector('.bottom-preview');
            const deltaY = e.clientY - startY;
            const newTop = startTopHeight + deltaY;
            const newBottom = startBottomHeight - deltaY;
            if (newTop > 120 && newBottom > 120) {
                topPreview.style.height = `${newTop}px`;
                bottomPreview.style.height = `${newBottom}px`;
                resize3DCanvas();
            }
        }
        
        function startHorizontalResize(e) {
            isResizingHorizontal = true;
            startX = e.clientX;
            const canvasWrapper = document.getElementById('hdr-canvas-wrapper');
            const listPanel = document.getElementById('light-list-panel');
            startCanvasWidth = canvasWrapper.offsetWidth;
            startListWidth = listPanel.offsetWidth;
            document.body.style.cursor = 'ew-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        }

        function handleHorizontalResize(e) {
            if (!isResizingHorizontal) return;
            const canvasWrapper = document.getElementById('hdr-canvas-wrapper');
            const listPanel = document.getElementById('light-list-panel');
            const deltaX = e.clientX - startX;
            
            const newCanvasRatio = (startCanvasWidth + deltaX) / (startCanvasWidth + startListWidth);
            const newListRatio = (startListWidth - deltaX) / (startCanvasWidth + startListWidth);
            
            canvasWrapper.style.flex = `${newCanvasRatio} 1 0%`;
            listPanel.style.flex = `${newListRatio} 1 0%`;
            
            canvasWrapper.dataset.ratio = newCanvasRatio;
            listPanel.dataset.ratio = newListRatio;
        }
        
        function getCanvasPixelPosition(canvas, clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            
            const canvasAspect = HDR_WIDTH / HDR_HEIGHT;
            const displayAspect = rect.width / rect.height;
            
            let displayWidth, displayHeight, offsetX, offsetY;
            
            if (displayAspect > canvasAspect) {
                displayHeight = rect.height;
                displayWidth = displayHeight * canvasAspect;
                offsetX = (rect.width - displayWidth) / 2;
                offsetY = 0;
            } else {
                displayWidth = rect.width;
                displayHeight = displayWidth / canvasAspect;
                offsetX = 0;
                offsetY = (rect.height - displayHeight) / 2;
            }
            
            const x = clientX - rect.left - offsetX;
            const y = clientY - rect.top - offsetY;
            
            const pixelX = (x / displayWidth) * HDR_WIDTH;
            const pixelY = (y / displayHeight) * HDR_HEIGHT;
            
            return { 
                x: Math.max(0, Math.min(HDR_WIDTH, pixelX)), 
                y: Math.max(0, Math.min(HDR_HEIGHT, pixelY))
            };
        }
        
        function resetCanvas(width, height) {
            const prevW = HDR_WIDTH, prevH = HDR_HEIGHT;
            HDR_WIDTH = width; HDR_HEIGHT = height;
            hdrCanvas.width = width; hdrCanvas.height = height;

            tempHdrCanvas = document.createElement('canvas');
            tempHdrCanvas.width = width;
            tempHdrCanvas.height = height;
            tempHdrCtx = tempHdrCanvas.getContext('2d');

            lights.forEach(light => {
                light.x *= (width / prevW);
                light.y *= (height / prevH);
                if (light.type === 'circle' || light.type === 'octagon' || light.type === 'ring') {
                    light.size *= (width / prevW);
                    if (light.thickness) light.thickness *= (width / prevW);
                } else if (light.type === 'rect') {
                    light.width *= (width / prevW);
                    light.height *= (height / prevH);
                }
            });
            drawHdrPreview();
        }
        
        function handleCanvasMouseDown(e) {
            const pos = getCanvasPixelPosition(hdrCanvas, e.clientX, e.clientY);
            const rotationOffset = (background.rotation / 360) * HDR_WIDTH;
            let x = (pos.x + rotationOffset) % HDR_WIDTH;
            let y = pos.y;
            
            document.querySelectorAll('#addCircleLight, #addRectLight, #addOctagonLight, #addRingLight').forEach(btn => btn.classList.remove('active'));
            hdrCanvas.style.cursor = 'default';
            
            if (addingLightType) {
                if (!lightTypeCounters[addingLightType]) {
                    lightTypeCounters[addingLightType] = 0;
                }
                lightTypeCounters[addingLightType]++;
                
                const newLight = {
                    id: Date.now(),
                    displayId: lightTypeCounters[addingLightType],
                    type: addingLightType,
                    visible: true,
                    x, y,
                    color: '#ffffff',
                    intensity: 10.0,
                    falloff: 30,
                    innerShadow: 0,
                    useTemperature: false,
                    temperature: 6500
                };
                if (addingLightType === 'circle' || addingLightType === 'octagon' || addingLightType === 'ring') {
                    newLight.size = 80 * (HDR_WIDTH / 2048);
                    if (addingLightType === 'ring') newLight.thickness = newLight.size * 0.3;
                    newLight.rotation = 0;
                } else if (addingLightType === 'rect') {
                    newLight.width = 120 * (HDR_WIDTH / 2048);
                    newLight.height = 80 * (HDR_HEIGHT / 1024);
                    newLight.cornerRadius = 10;
                    newLight.rotation = 0;
                }
                lights.push(newLight);
                selectedLight = newLight;
                addingLightType = null;
            } else {
                let clicked = null;
                for (let i = lights.length -1; i >=0; i--) {
                    const light = lights[i];
                    if (!light.visible) continue;
                    
                    const { scaleX } = getProjectionFactors(light);
                    const effectiveRadius = (light.size || Math.max(light.width, light.height)/2) * scaleX;
                    const dx = x - light.x, dy = y - light.y;
                    const wrapped_dx = Math.min(Math.abs(dx), Math.abs(dx - HDR_WIDTH), Math.abs(dx + HDR_WIDTH));
                    const dist = Math.sqrt(wrapped_dx*wrapped_dx + dy*dy);

                    if (dist < effectiveRadius + (light.falloff || 0)) {
                        clicked = light; 
                        break; 
                    }
                }
                selectedLight = clicked;
                if (selectedLight) draggingLight = selectedLight;
            }
            updateControlsUI();
            drawHdrPreview();
        }

        function handleCanvasMouseMove(e) {
            if (draggingLight) {
                const pos = getCanvasPixelPosition(hdrCanvas, e.clientX, e.clientY);
                const rotationOffset = (background.rotation / 360) * HDR_WIDTH;
                let x = (pos.x + rotationOffset);
                let y = pos.y;

                let newX = x;
                newX = (newX % HDR_WIDTH + HDR_WIDTH) % HDR_WIDTH;
                
                draggingLight.x = newX;
                draggingLight.y = Math.max(0, Math.min(HDR_HEIGHT, y));

                drawHdrPreview();
            }
        }

        function handleMouseUp() { draggingLight = null; }

        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    background.image = img;
                    document.querySelector('.tab-button[data-tab="image"]').click();
                    drawHdrPreview();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function addControlListeners() {
            if (!selectedLight) return;
            document.getElementById('deleteLightBtn').addEventListener('click', deleteSelectedLight);
            
            const updateLightProperty = (prop, value) => {
                if (!selectedLight) return;
                selectedLight[prop] = value;
                
                if (prop === 'falloff' && value > 0 && selectedLight.innerShadow > 0) {
                    selectedLight.innerShadow = 0;
                    document.getElementById('innerShadow').value = 0;
                    document.getElementById('innerShadowValue').value = 0;
                } else if (prop === 'innerShadow' && value > 0 && selectedLight.falloff > 0) {
                    selectedLight.falloff = 0;
                    document.getElementById('falloff').value = 0;
                    document.getElementById('falloffValue').value = 0;
                }
                drawHdrPreview();
                if (prop === 'color') updateLightListUI();
            };

            const sliders = document.querySelectorAll('.control-group input[type="range"]');
            sliders.forEach(slider => {
                if(slider.id.startsWith('model') || slider.id.startsWith('bg')) return;

                const inputId = slider.id;
                const valueInput = document.getElementById(inputId + 'Value');
                slider.addEventListener('input', e => {
                    const val = parseFloat(e.target.value);
                    if (valueInput) valueInput.value = val;
                    updateLightProperty(inputId, val);
                });
                if (valueInput) {
                    valueInput.addEventListener('input', e => {
                        const val = parseFloat(e.target.value) || 0;
                        slider.value = val;
                        updateLightProperty(inputId, val);
                    });
                }
            });

            const colorPicker = document.getElementById('color');
            const colorText = document.getElementById('colorText');
            if (colorPicker && colorText) {
                const updateColor = (value) => {
                    if (!/^#[0-9a-f]{6}$/i.test(value)) return;
                    colorPicker.value = value;
                    colorText.value = value;
                    updateLightProperty('color', value);
                };
                colorPicker.addEventListener('input', e => updateColor(e.target.value));
                colorText.addEventListener('change', e => updateColor(e.target.value));
            }
            
            const useTemperatureCheckbox = document.getElementById('useTemperature');
            const temperatureSlider = document.getElementById('temperature');
            const temperatureValue = document.getElementById('temperatureValue');
            
            if (useTemperatureCheckbox && temperatureSlider && temperatureValue) {
                useTemperatureCheckbox.addEventListener('change', (e) => {
                    selectedLight.useTemperature = e.target.checked;
                    const temperatureControl = document.querySelector('.temperature-control');
                    const colorWrapper = document.getElementById('color').parentElement;
                    
                    if (e.target.checked) {
                        temperatureControl.classList.add('active');
                        colorWrapper.classList.add('disabled-color');
                        const temp = selectedLight.temperature || 6500;
                        const hexColor = temperatureToRGB(temp);
                        selectedLight.color = hexColor;
                        document.getElementById('color').value = hexColor;
                        document.getElementById('colorText').value = hexColor;
                    } else {
                        temperatureControl.classList.remove('active');
                        colorWrapper.classList.remove('disabled-color');
                    }
                    drawHdrPreview();
                    updateLightListUI();
                });
                
                const updateTemp = (temp) => {
                    selectedLight.temperature = temp;
                    if (selectedLight.useTemperature) {
                        const hexColor = temperatureToRGB(temp);
                        selectedLight.color = hexColor;
                        document.getElementById('color').value = hexColor;
                        document.getElementById('colorText').value = hexColor;
                        drawHdrPreview();
                        updateLightListUI();
                    }
                }
                
                temperatureSlider.addEventListener('input', (e) => {
                    const temp = parseFloat(e.target.value);
                    temperatureValue.value = temp;
                    updateTemp(temp);
                });
                
                temperatureValue.addEventListener('input', (e) => {
                    const temp = parseFloat(e.target.value) || 6500;
                    temperatureSlider.value = temp;
                    updateTemp(temp);
                });
            }
        }

        function deleteSelectedLight() {
            if (!selectedLight) return;
            deleteLightById(selectedLight.id);
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 255, g: 255, b: 255 };
        }

        function updateStatus(message, isSuccess) {
            let statusEl = document.getElementById('status-indicator');
            if (!statusEl) {
                statusEl = document.createElement('div');
                statusEl.id = 'status-indicator';
                document.body.appendChild(statusEl);
            }
            statusEl.textContent = message;
            statusEl.className = `status-indicator ${isSuccess ? 'status-ok' : 'status-error'}`;
            setTimeout(() => {
                if (statusEl && statusEl.parentNode) statusEl.parentNode.removeChild(statusEl);
            }, 3000);
        }
        
        function smoothStep(t) {
             t = Math.max(0, Math.min(1, t));
             return t * t * (3 - 2 * t);
        }
        
        // 使用球面投影的衰减计算函数
        function computeCircleAttenuation(x, y, light) {
            const pixelPos = pixelsToSpherical(x, y, HDR_WIDTH, HDR_HEIGHT);
            const lightPos = pixelsToSpherical(light.x, light.y, HDR_WIDTH, HDR_HEIGHT);
            const angularRadius = (light.size / HDR_WIDTH) * TWO_PI;
            
            const dist = angularDistance(pixelPos.lon, pixelPos.lat, lightPos.lon, lightPos.lat);
            
            if (light.falloff > 0) {
                const falloffRadius = angularRadius + (light.falloff / HDR_WIDTH) * TWO_PI;
                if (dist > falloffRadius) return 0.0;
                if (dist < angularRadius) return 1.0;
                return smoothStep((falloffRadius - dist) / (falloffRadius - angularRadius));
            } else if (light.innerShadow > 0) {
                if (dist > angularRadius) return 0.0;
                if (dist < angularRadius * (1 - light.innerShadow)) return 1.0;
                const t = (angularRadius - dist) / (angularRadius * light.innerShadow);
                return 0.1 + 0.9 * smoothStep(t);
            }
            return dist <= angularRadius ? 1.0 : 0.0;
        }

// ===== 请将原有的 computeRingAttenuation 函数替换为下面的代码 =====
function computeRingAttenuation(x, y, light) {
    // 1. 将像素和灯光中心转换为球面坐标 (弧度)
    const pixelPos = pixelsToSpherical(x + 0.5, y + 0.5, HDR_WIDTH, HDR_HEIGHT);
    const lightPos = pixelsToSpherical(light.x, light.y, HDR_WIDTH, HDR_HEIGHT);

    // 2. 计算灯光相关的角距离参数
    const angularOuterRadius = (light.size / HDR_WIDTH) * TWO_PI;
    const angularThickness = (light.thickness / HDR_WIDTH) * TWO_PI;
    const angularInnerRadius = Math.max(0, angularOuterRadius - angularThickness);

    // 3. 计算当前像素到灯光中心的角距离
    const dist = angularDistance(pixelPos.lon, pixelPos.lat, lightPos.lon, lightPos.lat);

    // 4. 根据效果类型（外侧衰减或内侧柔化）计算光照强度
    let attenuation = 0.0;

    if (light.falloff > 0) {
        // --- 外侧衰减逻辑 ---
        // 将 falloff 从像素单位转换为角距离
        const angularFalloff = (light.falloff / HDR_WIDTH) * TWO_PI;
        
        // 计算外圆的外边缘 和 内圆的内边缘 (衰减的边界)
        const outerBound = angularOuterRadius + angularFalloff;
        const innerBound = Math.max(0, angularInnerRadius - angularFalloff);
        
        if (dist >= innerBound && dist <= outerBound) {
             // 计算到外圆实体边缘的距离
            const distToOuterEdge = Math.abs(dist - angularOuterRadius);
             // 计算到内圆实体边缘的距离
            const distToInnerEdge = Math.abs(dist - angularInnerRadius);
            
            // 取到最近实体边缘的距离
            const minDistToEdge = Math.min(distToOuterEdge, distToInnerEdge);

            // 如果像素点在环内，则强度为1，否则根据到最近边缘的距离进行平滑衰减
            if (dist >= angularInnerRadius && dist <= angularOuterRadius) {
                attenuation = 1.0;
            } else {
                attenuation = smoothStep(1.0 - minDistToEdge / angularFalloff);
            }
        }

    } else if (light.innerShadow > 0) {
        // --- 内侧柔化逻辑 ---
        // 柔化范围不能超过环厚度的一半
        const maxSoftness = angularThickness / 2;
        const angularInnerSoftness = Math.min(maxSoftness, angularOuterRadius * light.innerShadow);

        if (dist >= angularInnerRadius && dist <= angularOuterRadius) {
            // 计算到外圆内边缘的距离 和 到内圆外边缘的距离
            const distToOuterSoftnessBoundary = angularOuterRadius - dist;
            const distToInnerSoftnessBoundary = dist - angularInnerRadius;
            
            // 取到最近柔化边界的距离
            const minSoftnessDist = Math.min(distToOuterSoftnessBoundary, distToInnerSoftnessBoundary);

            // 使用 smoothStep 实现向内平滑过渡
            const t = minSoftnessDist / (angularInnerSoftness || 1e-8);
            attenuation = 0.1 + 0.9 * smoothStep(t); // 从 0.1 平滑过渡到 1.0
        }
        
    } else {
        // --- 无效果的逻辑 ---
        if (dist >= angularInnerRadius && dist <= angularOuterRadius) {
            attenuation = 1.0;
        }
    }

    return Math.max(0, Math.min(1, attenuation));
}

// 计算点到线段的距离
function pointToSegmentDistance(px, py, ax, ay, bx, by) {
    const vx = bx - ax, vy = by - ay;
    const wx = px - ax, wy = py - ay;
    const c1 = vx * wx + vy * wy;
    const c2 = vx * vx + vy * vy;
    const t = Math.max(0, Math.min(1, c1 / (c2 || 1e-8)));
    const qx = ax + t * vx, qy = ay + t * vy;
    const dx = px - qx, dy = py - qy;
    return Math.hypot(dx, dy);
}

// 计算点到凸多边形（这里是规则八边形）的“有符号距离”
// 约定：inside 时返回负值（到边界的最近距离），outside 时返回正值
function signedDistanceToConvexPolygon(p, verts) {
    let inside = true;
    let minEdgeDist = Infinity;

    for (let i = 0; i < verts.length; i++) {
        const a = verts[i];
        const b = verts[(i + 1) % verts.length];

        // 计算外法线（假设顶点按逆时针）
        const ex = b.x - a.x, ey = b.y - a.y;
        const nx =  ey, ny = -ex; // 外法线（与边旋转 90°）
        const len = Math.hypot(nx, ny) || 1e-8;
        const s = ((p.x - a.x) * nx + (p.y - a.y) * ny) / len;

        if (s > 0) inside = false;

        // 到边线段的欧氏最短距离
        const segDist = pointToSegmentDistance(p.x, p.y, a.x, a.y, b.x, b.y);
        if (segDist < minEdgeDist) minEdgeDist = segDist;
    }
    return inside ? -minEdgeDist : minEdgeDist;
}

/**
 * [新增] 计算两个球面坐标点之间的初始方位角
 * @param {number} φ1 - 起点纬度 (弧度)
 * @param {number} λ1 - 起点经度 (弧度)
 * @param {number} φ2 - 终点纬度 (弧度)
 * @param {number} λ2 - 终点经度 (弧度)
 * @returns {number} - 方位角 (弧度)
 */
function bearing(φ1, λ1, φ2, λ2) {
    const y = Math.sin(λ2 - λ1) * Math.cos(φ2);
    const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(λ2 - λ1);
    return Math.atan2(y, x);
}

// === 替换为这个新的、基于球面几何的八边形衰减函数 ===
function computeOctagonAttenuation(x, y, light) {
    // 1. 将像素和灯光中心转换为球面坐标 (弧度)
    const pixelPos = pixelsToSpherical(x + 0.5, y + 0.5, HDR_WIDTH, HDR_HEIGHT);
    const lightPos = pixelsToSpherical(light.x, light.y, HDR_WIDTH, HDR_HEIGHT);

    // 2. 计算从灯光中心到当前像素的球面角距离和方位角
    const angularDist = angularDistance(lightPos.lon, lightPos.lat, pixelPos.lon, pixelPos.lat);
    const bearingFromLight = bearing(lightPos.lat, lightPos.lon, pixelPos.lat, pixelPos.lon);

    // 3. 根据方位角，计算出八边形在该方向上的球面半径
    const lightRotation = (light.rotation || 0) * Math.PI / 180;
    const angularVertexRadius = (light.size / HDR_WIDTH) * TWO_PI; // 灯光尺寸定义为到顶点的角距离
    const numSegments = 8;

    // 计算像素相对于灯光旋转后的方位角
    let relativeAngle = bearingFromLight - lightRotation;
    // 将角度归一化到 [0, 2*PI]
    relativeAngle = (relativeAngle % TWO_PI + TWO_PI) % TWO_PI;
    
    // 计算该角度在八边形的一个 45度(PI/4) 切片内的位置
    const segmentAngle = TWO_PI / numSegments;
    const angleInSegment = relativeAngle % segmentAngle;
    const beta = angleInSegment - (segmentAngle / 2); // 将角度中心化到 [-PI/8, PI/8]

    // 八边形内切圆半径（角距离）
    const apothem = angularVertexRadius * Math.cos(PI / numSegments);
    // 使用几何公式计算出在 beta 角方向上，从中心到边缘的角距离
    const octagonRadiusAtAngle = apothem / Math.cos(beta);

    // 4. 计算像素到八边形边缘的“有符号角距离”
    // > 0 表示在外部, < 0 表示在内部
    const angularDistToEdge = angularDist - octagonRadiusAtAngle;

    // 5. 根据有符号距离，应用外侧衰减或内侧柔化效果
    if (light.falloff > 0) {
        if (angularDistToEdge <= 0) return 1.0; // 在内部，强度为1
        // 将像素单位的 falloff 值转换为等效的角距离
        const angularFalloff = (light.falloff / HDR_WIDTH) * TWO_PI;
        // 使用 smoothStep 实现平滑衰减
        return smoothStep(1.0 - angularDistToEdge / angularFalloff);

    } else if (light.innerShadow > 0) {
        if (angularDistToEdge >= 0) return 0.0; // 在外部，强度为0
        // 内侧柔化的范围，正比于灯光大小
        const angularInnerShadowSize = octagonRadiusAtAngle * light.innerShadow;
        if (-angularDistToEdge >= angularInnerShadowSize) return 1.0; // 在内部的纯色区域
        
        const t = (-angularDistToEdge) / (angularInnerShadowSize || 1e-8);
        return 0.1 + 0.9 * smoothStep(t); // 从 0.1 平滑过渡到 1.0
    }

    // 无衰减/柔化效果：内部为1，外部为0
    return angularDistToEdge <= 0 ? 1.0 : 0.0;
}


        function frexp(value) {
            if (value === 0) return [0, 0];
            const data = new DataView(new ArrayBuffer(8));
            data.setFloat64(0, value);
            let bits = data.getBigUint64(0);
            const sign = (bits >> 63n) === 0n ? 1 : -1;
            let exponent = Number((bits >> 52n) & 0x7ffn) - 1023;
            let mantissa = 1 + Number(bits & 0xfffffffffffffn) / (2**52);
            exponent += 1;
            mantissa /= 2;
            return [sign * mantissa, exponent];
        }

        function floatToRgbe(r, g, b) {
            const v = Math.max(r, g, b);
            if (v < 1e-32) return [0,0,0,0];
            const res = frexp(v);
            let m = res[0], e = res[1];
            m = m * 256.0 / v;
            return [ Math.floor(r * m), Math.floor(g * m), Math.floor(b * m), e + 128 ];
        }

async function generateHdrFile() {
            console.log("Generating true HDR data with spherical projection...");
            const unrotatedFloatData = new Float32Array(HDR_WIDTH * HDR_HEIGHT * 3);
            const bgCanvas = document.createElement('canvas');
            bgCanvas.width = HDR_WIDTH;
            bgCanvas.height = HDR_HEIGHT;
            const bgCtx = bgCanvas.getContext('2d');
            
            switch (background.type) {
                case 'image':
                    if (background.image) {
                        const imgRatio = background.image.width / background.image.height;
                        const canvasRatio = HDR_WIDTH / HDR_HEIGHT;
                        let drawWidth, drawHeight, offsetX, offsetY;
                        if (imgRatio > canvasRatio) {
                            drawHeight = HDR_HEIGHT;
                            drawWidth = background.image.width * (HDR_HEIGHT / background.image.height);
                            offsetX = (HDR_WIDTH - drawWidth) / 2; offsetY = 0;
                        } else {
                            drawWidth = HDR_WIDTH;
                            drawHeight = background.image.height * (HDR_WIDTH / background.image.width);
                            offsetX = 0; offsetY = (HDR_HEIGHT - drawHeight) / 2;
                        }
                        bgCtx.drawImage(background.image, offsetX, offsetY, drawWidth, drawHeight);
                    } else { bgCtx.fillStyle = '#000'; bgCtx.fillRect(0, 0, HDR_WIDTH, HDR_HEIGHT); }
                    break;
                case 'gradient':
                    const angleRad = background.gradient.angle * PI / 180;
                    const x1 = HDR_WIDTH / 2 - Math.cos(angleRad) * HDR_WIDTH / 2, y1 = HDR_HEIGHT / 2 - Math.sin(angleRad) * HDR_HEIGHT / 2;
                    const x2 = HDR_WIDTH / 2 + Math.cos(angleRad) * HDR_WIDTH / 2, y2 = HDR_HEIGHT / 2 + Math.sin(angleRad) * HDR_HEIGHT / 2;
                    const grad = bgCtx.createLinearGradient(x1, y1, x2, y2);
                    grad.addColorStop(0, background.gradient.color1);
                    grad.addColorStop(1, background.gradient.color2);
                    bgCtx.fillStyle = grad;
                    bgCtx.fillRect(0, 0, HDR_WIDTH, HDR_HEIGHT);
                    break;
                default:
                    bgCtx.fillStyle = background.color;
                    bgCtx.fillRect(0, 0, HDR_WIDTH, HDR_HEIGHT);
            }

            const bgImageData = bgCtx.getImageData(0, 0, HDR_WIDTH, HDR_HEIGHT).data;
            for (let i = 0; i < HDR_WIDTH * HDR_HEIGHT; i++) {
                const r = sRGBToLinear(bgImageData[i * 4 + 0] / 255);
                const g = sRGBToLinear(bgImageData[i * 4 + 1] / 255);
                const b = sRGBToLinear(bgImageData[i * 4 + 2] / 255);
                unrotatedFloatData[i * 3 + 0] = r * background.brightness;
                unrotatedFloatData[i * 3 + 1] = g * background.brightness;
                unrotatedFloatData[i * 3 + 2] = b * background.brightness;
            }

            for (const light of lights) {
                if (!light.visible) continue;
                const linearColor = hexToLinear(light.color);
                const lr = linearColor.r * light.intensity;
                const lg = linearColor.g * light.intensity;
                const lb = linearColor.b * light.intensity;
                
                for (let y = 0; y < HDR_HEIGHT; y++) {
                    for (let x = 0; x < HDR_WIDTH; x++) {
                        const idx = (y * HDR_WIDTH + x) * 3;
                        let attenuation = 0;
                        
                        if (light.type === 'circle') {
                            attenuation = computeCircleAttenuation(x+0.5, y+0.5, light);
                        } else if (light.type === 'octagon') {
                            attenuation = computeOctagonAttenuation(x+0.5, y+0.5, light);
                        } else if (light.type === 'ring') {
                            attenuation = computeRingAttenuation(x+0.5, y+0.5, light);
                        } else {
                            // ===== MODIFICATION START =====
                            // 修正后的矩形灯光逻辑
                            const { scaleX, scaleY } = getProjectionFactors(light);
                            const rotation = light.rotation || 0;
                            const r_rad = rotation * Math.PI / 180;
                            const cos_r = Math.cos(-r_rad);
                            const sin_r = Math.sin(-r_rad);
                            
                            let localX = x - light.x;
                            // 处理水平环绕的情况
                            if (localX > HDR_WIDTH / 2) localX -= HDR_WIDTH;
                            if (localX < -HDR_WIDTH / 2) localX += HDR_WIDTH;
                            
                            let localY = y - light.y;
                            
                            const rx = localX * cos_r - localY * sin_r;
                            const ry = localX * sin_r + localY * cos_r;
                            
                            const urx = rx / scaleX;
                            const ury = ry / scaleY;
                            
                            const halfW = light.width / 2;
                            const halfH = light.height / 2;
                            const cornerRadius = Math.min(light.cornerRadius || 0, halfW, halfH);
                            
                            // 使用标准的圆角矩形符号距离函数(SDF)
                            const q_x = Math.abs(urx) - (halfW - cornerRadius);
                            const q_y = Math.abs(ury) - (halfH - cornerRadius);
                            const max_q_x = Math.max(q_x, 0);
                            const max_q_y = Math.max(q_y, 0);
                            const signedDist = Math.hypot(max_q_x, max_q_y) + Math.min(Math.max(q_x, q_y), 0) - cornerRadius;

                            attenuation = 0.0; // 默认衰减为0

                            if (light.falloff > 0) {
                                attenuation = smoothStep(1.0 - signedDist / light.falloff);
                            } else if (light.innerShadow > 0) {
                                const softnessWidth = Math.min(halfW, halfH) * light.innerShadow;
                                if (signedDist > 0) {
                                    attenuation = 0.0; // 在形状外，强度为0
                                } else if (signedDist < -softnessWidth) {
                                    attenuation = 1.0; // 在核心区域，强度为1
                                } else {
                                    // 在柔化边缘区域
                                    const t = (-signedDist) / (softnessWidth || 1e-8);
                                    attenuation = 0.1 + 0.9 * smoothStep(t);
                                }
                            } else {
                                attenuation = signedDist <= 0 ? 1.0 : 0.0;
                            }
                            attenuation = Math.max(0, attenuation); // 确保衰减值不为负
                            // ===== MODIFICATION END =====
                        }
                        
                        if (attenuation > 0) {
                            unrotatedFloatData[idx] += lr * attenuation;
                            unrotatedFloatData[idx + 1] += lg * attenuation;
                            unrotatedFloatData[idx + 2] += lb * attenuation;
                        }
                    }
                }
            }
            
            const rotatedFloatData = new Float32Array(HDR_WIDTH * HDR_HEIGHT * 3);
            const rotationOffset = Math.round((background.rotation / 360) * HDR_WIDTH);

            for (let y = 0; y < HDR_HEIGHT; y++) {
                for (let x = 0; x < HDR_WIDTH; x++) {
                    const sourceX = (x + rotationOffset) % HDR_WIDTH;
                    const sourceIndex = (y * HDR_WIDTH + sourceX) * 3;
                    const destIndex = (y * HDR_WIDTH + x) * 3;

                    rotatedFloatData[destIndex] = unrotatedFloatData[sourceIndex];
                    rotatedFloatData[destIndex + 1] = unrotatedFloatData[sourceIndex + 1];
                    rotatedFloatData[destIndex + 2] = unrotatedFloatData[sourceIndex + 2];
                }
            }

            const rgbeData = new Uint8Array(HDR_WIDTH * HDR_HEIGHT * 4);
            for (let i = 0; i < HDR_WIDTH * HDR_HEIGHT; i++) {
                const r = rotatedFloatData[i * 3 + 0], g = rotatedFloatData[i * 3 + 1], b = rotatedFloatData[i * 3 + 2];
                const rgbe = floatToRgbe(r, g, b);
                rgbeData.set(rgbe, i * 4);
            }

            const header = `#?RADIANCE\nFORMAT=32-bit_rle_rgbe\n\n-Y ${HDR_HEIGHT} +X ${HDR_WIDTH}\n`;
            const headerBytes = new TextEncoder().encode(header);
            const fileData = new Uint8Array(headerBytes.length + rgbeData.length);
            fileData.set(headerBytes, 0);
            fileData.set(rgbeData, headerBytes.length);

            const blob = new Blob([fileData], { type: 'application/octet-stream' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `studio-light-${Date.now()}.hdr`;
            link.click();
            URL.revokeObjectURL(link.href);
            
            updateStatus("HDRI导出成功！", true);
        }

        function initApp() {
            try {
                init3DScene();
                resetCanvas(HDR_WIDTH, HDR_HEIGHT);
                initResizeEvents();

                document.getElementById('resolutionSelector').addEventListener('change', (e) => {
                    const [w, h] = e.target.value.split('x').map(Number);
                    resetCanvas(w, h);
                });
                
                const canvasWrapper = document.getElementById('hdr-canvas-wrapper');
                const listPanel = document.getElementById('light-list-panel');
                if (!canvasWrapper.dataset.ratio) {
                    canvasWrapper.dataset.ratio = "0.75";
                    listPanel.dataset.ratio = "0.25";
                }
                
                const addButtons = ['addCircleLight', 'addRectLight', 'addOctagonLight', 'addRingLight'];
                addButtons.forEach(id => {
                    const btn = document.getElementById(id);
                    btn.addEventListener('click', (e) => {
                        hdrCanvas.classList.remove('cursor-dashed', 'cursor-square', 'cursor-octagon', 'cursor-ring');
                        addingLightType = id.replace('add', '').replace('Light', '').toLowerCase();
                        addButtons.forEach(bid => document.getElementById(bid).classList.remove('active'));
                        e.currentTarget.classList.add('active');
                        hdrCanvas.style.cursor = 'crosshair';
                    });
                });

                hdrCanvas.addEventListener('mousedown', handleCanvasMouseDown);
                hdrCanvas.addEventListener('mousemove', handleCanvasMouseMove);
                window.addEventListener('mouseup', handleMouseUp);
                hdrCanvas.addEventListener('mouseleave', () => { if (!addingLightType) handleMouseUp(); });

                document.querySelectorAll('.tab-button').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const tabId = btn.dataset.tab;
                        background.type = tabId;
                        document.querySelectorAll('.tab-button, .tab-content').forEach(el => el.classList.remove('active'));
                        btn.classList.add('active');
                        document.getElementById(tabId + 'Tab').classList.add('active');
                        drawHdrPreview();
                    });
                });

                document.getElementById('bgColor').addEventListener('input', e => { background.color = e.target.value; drawHdrPreview(); });
                document.getElementById('gradientColor1').addEventListener('input', e => { background.gradient.color1 = e.target.value; drawHdrPreview(); });
                document.getElementById('gradientColor2').addEventListener('input', e => { background.gradient.color2 = e.target.value; drawHdrPreview(); });
                const gradientAngleSlider = document.getElementById('gradientAngle');
                const gradientAngleValue = document.getElementById('gradientAngleValue');
                gradientAngleSlider.addEventListener('input', e => { background.gradient.angle = e.target.value; gradientAngleValue.value = e.target.value; drawHdrPreview(); });
                gradientAngleValue.addEventListener('input', e => { background.gradient.angle = e.target.value; gradientAngleSlider.value = e.target.value; drawHdrPreview(); });
                
                const bgRotationSlider = document.getElementById('bgRotation');
                const bgRotationValue = document.getElementById('bgRotationValue');
                bgRotationSlider.addEventListener('input', e => { background.rotation = e.target.value; bgRotationValue.value = e.target.value; drawHdrPreview(); });
                bgRotationValue.addEventListener('input', e => { background.rotation = e.target.value; bgRotationSlider.value = e.target.value; drawHdrPreview(); });

                const bgBrightnessSlider = document.getElementById('bgBrightness');
                const bgBrightnessValue = document.getElementById('bgBrightnessValue');
                bgBrightnessSlider.addEventListener('input', e => { background.brightness = e.target.value; bgBrightnessValue.value = e.target.value; drawHdrPreview(); });
                bgBrightnessValue.addEventListener('input', e => { background.brightness = e.target.value; bgBrightnessSlider.value = e.target.value; drawHdrPreview(); });

                document.getElementById('imageUpload').addEventListener('change', handleImageUpload);
                document.getElementById('exportHdri').addEventListener('click', generateHdrFile);
                
                document.getElementById('importModelBtn').addEventListener('click', () => document.getElementById('modelUpload').click());
                document.getElementById('modelUpload').addEventListener('change', handleModelUpload);
                addModelControlListeners();

                lightTypeCounters['circle'] = 1;
                lights.push({
                    id: Date.now(),
                    displayId: 1,
                    type: 'circle',
                    visible: true,
                    x: HDR_WIDTH * 0.85,
                    y: HDR_HEIGHT * 0.4,
                    size: 120,
                    color: '#ffffff',
                    intensity: 10.0,
                    falloff: 30,
                    innerShadow: 0,
                    useTemperature: false,
                    temperature: 6500
                });
                
                selectedLight = lights[0];

                updateControlsUI();
                drawHdrPreview();
                updateStatus("HDRI编辑器已就绪", true);
            } catch (e) {
                console.error("初始化失败:", e);
                updateStatus(`初始化错误: ${e.message}`, false);
            }
        }

        window.addEventListener('load', initApp);
        window.addEventListener('resize', () => {
            resize3DCanvas();
            drawHdrPreview();
        });

    </script>
</body>
</html>