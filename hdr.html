<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HDRI 编辑器 Pro (增强版)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="menu.js" defer></script>
    <link rel="icon" href="img/gongjuxiang.svg" type="image/svg">
    <script defer src="https://cloud.umami.is/script.js" data-website-id="5a2e10cd-bf73-47df-be48-079c9ba7783c" data-domains="designtool.site"></script>
    <style>
        :root {
            --main-color: #8080FF;
            --line: #7878784d;
            --main-bg: #222228;
            --panel-bg: #2E2E33;
            --bt-gradient: linear-gradient(to left, #6450ff, #8f56fa);
            --add-gradient: linear-gradient(to left, #50c878, #56fa8f);
            --octagon-gradient: linear-gradient(to left, #ff7e5f, #feb47b);
            --text1: #ffffff;
            --text2: #c7d1e2;
            --text3: #969dbb;
            --input-bg: #3a3a42;
            --scrollbar-thumb: #4a4a5a;
            --scrollbar-track: #2a2a33;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--main-bg);
            color: var(--text2);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            overflow: hidden;
        }

        .editor-container {
            display: flex;
            gap: 20px;
            width: 100%;
            height: calc(100vh - 40px);
            position: relative;
	margin-left: 60px;
        }

        .controls-panel {
            width: 400px;
            background-color: var(--panel-bg);
            border: 1px solid var(--line);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .controls-header {
            position: sticky;
            top: 0;
            background-color: var(--panel-bg);
            z-index: 10;
        }

        .controls-content {
            overflow-y: auto;
            flex-grow: 1;
        }

        /* 自定义滚动条 */
        .controls-content::-webkit-scrollbar {
            width: 8px;
        }
        .controls-content::-webkit-scrollbar-track {
            background: var(--scrollbar-track);
            border-radius: 4px;
        }
        .controls-content::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb);
            border-radius: 4px;
        }
        .controls-content::-webkit-scrollbar-thumb:hover {
            background: #5a5a6a;
        }

        .preview-panel {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 6px;
            height: 100%;
            position: relative;
        }

        .resize-handle {
            position: static;
            top: 50%;
            left: 0;
            right: 0;
            height: 4px;
            background: none;
            cursor: ns-resize;
            z-index: 10;
            transform: translateY(-2px);
        }
        .resize-handle:hover {
            background: var(--main-color);
        }

        .preview-box {
            background-color: var(--panel-bg);
            border: 1px solid var(--line);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            padding: 15px;
            overflow: hidden;
            position: relative;
        }
        
        .top-preview {
            height: 50%;
        }
        
        .bottom-preview {
            height: 50%;
        }
        
        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 14px;
            color: var(--text3);
        }

        .preview-header h3 {
            margin: 0;
            color: var(--text2);
            font-weight: 500;
        }

        canvas {
            display: block;
            background-color: #000;
            border-radius: 4px;
            height: calc(100% - 30px);
            margin: 0 auto;
        }

        #hdrCanvas {
            cursor: default;
        }
         #hdrCanvas:hover {
            border: 1px solid #8080ff94;
        }
        h2.main-title {
            margin-top: 0;
            border-bottom: 1px solid var(--line);
            padding-bottom: 15px;
            font-size: 22px;
            color: var(--main-color);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
	    justify-content: space-between;
        }
        
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .button-group button {
            padding: 10px 12px;
            border: none;
            border-radius: 25px;
            color: var(--text1);
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: none;
            border: 1px solid var(--text3);
        }
        
        .button-group button:hover {
            border: 1px solid var(--main-color);
            color: var(--main-color);
            background: #8080ff30;
        }
        
        #addCircleLight {
        }
        
        #addRectLight {
        }
        
        #addOctagonLight {
        }

        .export-button {
            padding: 10px 22px;
            border: none;
            border-radius: 25px;
            background: var(--bt-gradient);
            color: var(--text1);
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .export-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .control-section {
            background-color: rgba(0,0,0,0.1);
            border: 1px solid var(--line);
            border-radius: 6px;
            padding: 15px;
            margin-top: 20px;
        }

        .control-group {
            margin: 16px 0;
        }
        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: var(--text2);
        }

        .control-group input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: var(--input-bg);
            border-radius: 2px;
            outline: none;
        }
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--main-color);
            cursor: pointer;
            border: 2px solid var(--panel-bg);
        }
        .control-group input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--main-color);
            cursor: pointer;
            border: 2px solid var(--panel-bg);
        }

        .color-input-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group input[type="color"] {
            min-width: 40px;
            height: 30px;
            border: 1px solid var(--line);
            border-radius: 4px;
            padding: 2px;
            cursor: pointer;
            background: none;
        }
        
        .control-group input[type="text"], 
        .control-group input[type="number"], 
        #resolutionSelector {
            flex-grow: 1;
            background-color: var(--input-bg);
            color: var(--text1);
            border: 1px solid var(--line);
            border-radius: 4px;
            padding: 6px 8px;
        }
        
        .control-group .value-display {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .control-group .value-display input[type="number"] {
            width: 100px;
        }
        
        #resolutionSelector {
            width: 100%;
        }

        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--line);
        }

        .control-header h3 {
            margin: 0;
            font-size: 16px;
            color: #f59e0b;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .delete-button {
            background: none;
            border: none;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
        }
        .delete-button:hover {
            color: #ff4757;
        }

        .tab-buttons {
            display: flex;
            background-color: var(--input-bg);
            border-radius: 6px;
            padding: 4px;
            margin-bottom: 15px;
        }
        .tab-button {
            flex: 1;
            padding: 6px 0;
            background: none;
            border: none;
            color: var(--text3);
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        .tab-button.active {
                background: var(--main-color);
    		color: var(--text1);
            font-weight: 600;
        }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        #imageUploadLabel {
             display: block;
             padding: 10px;
             text-align: center;
             background-color: var(--input-bg);
             border: 1px dashed var(--line);
             border-radius: 4px;
             cursor: pointer;
        }
         #imageUploadLabel:hover {
            background-color: #44444c;
         }
        #imageUpload { display: none; }
        
        /* 添加灯光形状区分 */
        .light-shape-circle {
            border-radius: 50%;
        }
        .light-shape-rect {
            border-radius: 4px;
        }
        .light-shape-octagon {
            border-radius: 4px;
        }
        
        /* 移动端适配 */
        @media (max-width: 992px) {
            .editor-container {
                flex-direction: column;
                height: auto;
            }
            
            .controls-panel {
                width: 100%;
                height: auto;
	        max-height: 74vh;
            }
            
            .preview-panel {
                width: 100%;
                height: 50vh;
            }
            
            .button-group {
            }
            
            .preview-header h3 {
                font-size: 14px;
            }
            
            .main-title {
                font-size: 20px;
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .editor-container {
                gap: 10px;
	margin-left: 0;
            }
            
            .controls-panel {
                padding: 15px;
            }
            
            .preview-box {
                padding: 10px;
            }
            
            .control-section {
                padding: 12px;
            }
            
            .control-group .value-display {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }
            
            .control-group .value-display input[type="number"] {
                width: 100%;
            }
            
            .button-group button {
                font-size: 13px;
                padding: 8px;
            }
            
            .export-button {
                font-size: 13px;
            }
        }
    </style>
</head>
<body>
    <div id="global-sidebar"></div>
    <div class="editor-container">
        <div class="controls-panel">
            <div class="controls-header">
                <h2 class="main-title"><span><i class="fa-solid fa-wand-magic-sparkles"></i> HDRI 编辑器</span>
		<button class="export-button" id="exportHdri"><i class="fa-solid fa-download"></i> 导出 HDRI</button>
		</h2>
                
                <div class="control-group">
                    <label for="resolutionSelector"><i class="fa-solid fa-ruler-combined"></i> 尺寸选择</label>
                    <select id="resolutionSelector">
                        <option value="1024x512">1024 × 512</option>
                        <option value="2048x1024" selected>2048 × 1024</option>
                        <option value="4096x2048">4096 × 2048</option>
                    </select>
                </div>

                <div class="button-group">
                    <button id="addCircleLight"><i class="fa-regular fa-lightbulb"></i> 圆形灯</button>
                    <button id="addRectLight"><i class="fa-regular fa-square"></i> 矩形灯</button>
                    <button id="addOctagonLight"><i class="fa-solid fa-sun"></i> 八边形灯</button>
                </div>  
            </div>
            
            <div class="controls-content">
                <div id="lightControls"></div>

                <div class="control-section" id="backgroundControlsContainer">
                    <div class="control-header">
                        <h3><i class="fa-solid fa-layer-group"></i> 背景调节</h3>
                    </div>
                    <div class="tab-buttons">
                        <button class="tab-button active" data-tab="solid">纯色</button>
                        <button class="tab-button" data-tab="gradient">渐变</button>
                        <button class="tab-button" data-tab="image">图片</button>
                    </div>
                    
                    <div id="solidTab" class="tab-content active">
                        <div class="control-group">
                            <label for="bgColor">颜色</label>
                            <div class="color-input-wrapper">
                                <input type="color" id="bgColor" value="#202025">
                            </div>
                        </div>
                    </div>

                    <div id="gradientTab" class="tab-content">
                        <div class="control-group">
                            <label for="gradientColor1">颜色 1 (天空)</label>
                            <input type="color" id="gradientColor1" value="#1a73e8">
                        </div>
                        <div class="control-group">
                            <label for="gradientColor2">颜色 2 (地面)</label>
                            <input type="color" id="gradientColor2" value="#aaaaa1">
                        </div>
                        <div class="control-group">
                            <label for="gradientAngle">角度</label>
                            <div class="value-display">
                                <input type="range" id="gradientAngle" min="0" max="360" value="90" step="1">
                                <input type="number" id="gradientAngleValue" min="0" max="360" value="90" step="1">
                            </div>
                        </div>
                    </div>

                    <div id="imageTab" class="tab-content">
                        <div class="control-group">
                            <input type="file" id="imageUpload" accept="image/*">
                            <label for="imageUpload" id="imageUploadLabel"><i class="fa-solid fa-upload"></i> 点击上传图片</label>
                        </div>
                    </div>

                    <div class="control-group" style="margin-top: 20px;">
                        <label for="bgBrightness">亮度</label>
                        <div class="value-display">
                            <input type="range" id="bgBrightness" min="0" max="5" value="1" step="0.01">
                            <input type="number" id="bgBrightnessValue" min="0" max="5" value="1" step="0.01">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="preview-panel">
            <div class="preview-box top-preview">
                <div class="preview-header">
                    <h3><i class="fa-solid fa-globe"></i> 展开图预览 (Equirectangular)</h3>
                </div>
                <canvas id="hdrCanvas"></canvas>
            </div>
            <div class="resize-handle" id="resizeHandle"></div>
            <div class="preview-box bottom-preview">
                <div class="preview-header">
                    <h3><i class="fa-solid fa-cube"></i> 3D环境预览</h3>
                </div>
                <canvas id="sceneCanvas" style="width: 100%;"></canvas>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- DOM Elements & Constants ---
        const hdrCanvas = document.getElementById('hdrCanvas');
        const hdrCtx = hdrCanvas.getContext('2d', { willReadFrequently: true });
        const sceneCanvas = document.getElementById('sceneCanvas');
        const resizeHandle = document.getElementById('resizeHandle');
        const PI = Math.PI;
        const TWO_PI = 2 * PI;
        const HALF_PI = PI / 2;

        // --- State ---
        let HDR_WIDTH = 2048, HDR_HEIGHT = 1024;
        let lights = [];
        let selectedLight = null;
        let addingLightType = null;
        let draggingLight = null;
        let isResizing = false;
        let startY = 0;
        let startTopHeight = 0;
        let startBottomHeight = 0;

        let background = {
            type: 'solid',
            color: '#202025',
            gradient: { color1: '#1a73e8', color2: '#aaaaa1', angle: 90 },
            image: null,
            brightness: 1.0,
        };

        // --- 3D Scene ---
        let scene, camera, renderer, sphere, controls, envTexture;
        let pointLight, directionalLight;

        function init3DScene() {
            scene = new THREE.Scene();
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: sceneCanvas, 
                antialias: true, 
                alpha: true,
                logarithmicDepthBuffer: true
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.6; // 降低曝光值，使颜色变深

            camera = new THREE.PerspectiveCamera(75, sceneCanvas.clientWidth / sceneCanvas.clientHeight, 0.1, 1000);
            camera.position.z = 2.5;

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 1.5;
            controls.maxDistance = 5;

            const geometry = new THREE.SphereGeometry(1, 128, 64);
            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff, // 使用更深的颜色
                metalness: 0.8,
                roughness: 0.1,
                side: THREE.DoubleSide
            });
            sphere = new THREE.Mesh(geometry, material);
            scene.add(sphere);

            // 添加环境光
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3); // 降低环境光强度
            scene.add(ambientLight);

            // 添加点光源
            pointLight = new THREE.PointLight(0xffffff, 0.8, 100); // 降低点光源强度
            pointLight.position.set(0, 2, 0);
            scene.add(pointLight);

            // 添加方向光
            directionalLight = new THREE.DirectionalLight(0xffffff, 0.5); // 降低方向光强度
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // 添加网格辅助
            const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
            scene.add(gridHelper);

            // 添加坐标轴辅助
            const axesHelper = new THREE.AxesHelper(1.5);
            scene.add(axesHelper);

            // 创建环境纹理
            envTexture = new THREE.CanvasTexture(hdrCanvas);
            envTexture.mapping = THREE.EquirectangularReflectionMapping;
            scene.environment = envTexture;
            scene.background = envTexture;

            animate();
            resize3DCanvas();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function update3DScene() {
            if (!envTexture) return;
            envTexture.dispose();
            envTexture = new THREE.CanvasTexture(hdrCanvas);
            envTexture.mapping = THREE.EquirectangularReflectionMapping;
            scene.environment = envTexture;
            scene.background = envTexture;
        }
        
        function resize3DCanvas() {
            if(!renderer) return;
            const { clientWidth, clientHeight } = sceneCanvas;
            renderer.setSize(clientWidth, clientHeight, false);
            camera.aspect = clientWidth / clientHeight;
            camera.updateProjectionMatrix();
        }

        // --- Drawing Logic ---
        function unproject(u, v) {
            const lon = (u / HDR_WIDTH) * TWO_PI - PI;
            const lat = (v / HDR_HEIGHT) * PI - HALF_PI;
            return { lon, lat };
        }

        // 圆形灯光路径
        function createCirclePath(ctx, light) {
            const { lon: centerLon, lat: centerLat } = unproject(light.x, light.y);
            const angularRadius = (light.size / HDR_WIDTH) * PI;

            ctx.beginPath();
            const segments = 64;
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * TWO_PI;
                const lat = Math.asin(Math.sin(centerLat) * Math.cos(angularRadius) + Math.cos(centerLat) * Math.sin(angularRadius) * Math.cos(angle));
                let lon = centerLon + Math.atan2(Math.sin(angle) * Math.sin(angularRadius) * Math.cos(centerLat), Math.cos(angularRadius) - Math.sin(centerLat) * Math.sin(lat));

                const u = ((lon + PI) / TWO_PI) * HDR_WIDTH;
                const v = ((lat + HALF_PI) / PI) * HDR_HEIGHT;

                if (i === 0) ctx.moveTo(u, v);
                else ctx.lineTo(u, v);
            }
            ctx.closePath();
        }
        
        // 矩形灯光路径（带圆角和旋转）
        function createRectPath(ctx, light) {
            const centerX = light.x;
            const centerY = light.y;
            const width = light.width;
            const height = light.height;
            const cornerRadius = light.cornerRadius || 0;
            const rotation = light.rotation || 0;
            
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(rotation * Math.PI / 180);
            
            const halfWidth = width / 2;
            const halfHeight = height / 2;
            
            ctx.beginPath();
            ctx.moveTo(-halfWidth + cornerRadius, -halfHeight);
            
            // 绘制顶部边
            ctx.lineTo(halfWidth - cornerRadius, -halfHeight);
            // 右上角
            ctx.arcTo(halfWidth, -halfHeight, halfWidth, -halfHeight + cornerRadius, cornerRadius);
            
            // 绘制右边
            ctx.lineTo(halfWidth, halfHeight - cornerRadius);
            // 右下角
            ctx.arcTo(halfWidth, halfHeight, halfWidth - cornerRadius, halfHeight, cornerRadius);
            
            // 绘制底部边
            ctx.lineTo(-halfWidth + cornerRadius, halfHeight);
            // 左下角
            ctx.arcTo(-halfWidth, halfHeight, -halfWidth, halfHeight - cornerRadius, cornerRadius);
            
            // 绘制左边
            ctx.lineTo(-halfWidth, -halfHeight + cornerRadius);
            // 左上角
            ctx.arcTo(-halfWidth, -halfHeight, -halfWidth + cornerRadius, -halfHeight, cornerRadius);
            
            ctx.closePath();
            ctx.restore();
        }
        
        // 八边形灯光路径（带旋转）
        function createOctagonPath(ctx, light) {
            const centerX = light.x;
            const centerY = light.y;
            const radius = light.size;
            const rotation = light.rotation || 0;
            const points = 8;
            
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(rotation * Math.PI / 180);
            
            ctx.beginPath();
            for (let i = 0; i < points; i++) {
                const angle = (i * 2 * Math.PI) / points - Math.PI/8;
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.restore();
        }

        function drawHdrPreview() {
            hdrCtx.globalCompositeOperation = 'source-over';
            
            // 1. Draw Background
            switch (background.type) {
                case 'image':
                    if (background.image) {
                        const imgRatio = background.image.width / background.image.height;
                        const canvasRatio = HDR_WIDTH / HDR_HEIGHT;
                        
                        let drawWidth, drawHeight, offsetX, offsetY;
                        
                        if (imgRatio > canvasRatio) {
                            drawHeight = HDR_HEIGHT;
                            drawWidth = background.image.width * (HDR_HEIGHT / background.image.height);
                            offsetX = (HDR_WIDTH - drawWidth) / 2;
                            offsetY = 0;
                        } else {
                            drawWidth = HDR_WIDTH;
                            drawHeight = background.image.height * (HDR_WIDTH / background.image.width);
                            offsetX = 0;
                            offsetY = (HDR_HEIGHT - drawHeight) / 2;
                        }
                        
                        hdrCtx.drawImage(background.image, offsetX, offsetY, drawWidth, drawHeight);
                    } else { 
                        hdrCtx.fillStyle = '#000'; 
                        hdrCtx.fillRect(0, 0, HDR_WIDTH, HDR_HEIGHT); 
                    }
                    break;
                case 'gradient':
                    const angleRad = background.gradient.angle * PI / 180;
                    const x1 = HDR_WIDTH / 2 - Math.cos(angleRad) * HDR_WIDTH / 2, 
                          y1 = HDR_HEIGHT / 2 - Math.sin(angleRad) * HDR_HEIGHT / 2;
                    const x2 = HDR_WIDTH / 2 + Math.cos(angleRad) * HDR_WIDTH / 2, 
                          y2 = HDR_HEIGHT / 2 + Math.sin(angleRad) * HDR_HEIGHT / 2;
                    const grad = hdrCtx.createLinearGradient(x1, y1, x2, y2);
                    grad.addColorStop(0, background.gradient.color1);
                    grad.addColorStop(1, background.gradient.color2);
                    hdrCtx.fillStyle = grad;
                    hdrCtx.fillRect(0, 0, HDR_WIDTH, HDR_HEIGHT);
                    break;
                default:
                    hdrCtx.fillStyle = background.color;
                    hdrCtx.fillRect(0, 0, HDR_WIDTH, HDR_HEIGHT);
            }
            hdrCtx.filter = `brightness(${background.brightness})`;

            // 2. Draw Lights (Additive Blending)
            hdrCtx.globalCompositeOperation = 'add';
            lights.forEach(light => {
                hdrCtx.save();
                
                // 根据灯光类型绘制不同形状
                if (light.type === 'circle') {
                    createCirclePath(hdrCtx, light);
                } else if (light.type === 'rect') {
                    createRectPath(hdrCtx, light);
                } else if (light.type === 'octagon') {
                    createOctagonPath(hdrCtx, light);
                }

                const color = hexToRgb(light.color);
                const displayIntensity = Math.min(light.intensity / 10, 1.0);
                
                hdrCtx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${displayIntensity})`;
                hdrCtx.shadowColor = `rgba(${color.r}, ${color.g}, ${color.b}, ${displayIntensity})`;
                hdrCtx.shadowBlur = light.falloff;

                // Fill the path
                hdrCtx.fill();

                hdrCtx.restore();
            });
            hdrCtx.filter = 'none';
            
            // 3. Draw Selection Outline
            if (selectedLight) {
                hdrCtx.globalCompositeOperation = 'source-over';
                hdrCtx.strokeStyle = 'rgba(128, 128, 255, 0.9)';
                hdrCtx.lineWidth = 2;
                hdrCtx.setLineDash([8, 4]);
                
                if (selectedLight.type === 'circle') {
                    createCirclePath(hdrCtx, selectedLight);
                } else if (selectedLight.type === 'rect') {
                    createRectPath(hdrCtx, selectedLight);
                } else if (selectedLight.type === 'octagon') {
                    createOctagonPath(hdrCtx, selectedLight);
                }
                hdrCtx.stroke();
                
                hdrCtx.setLineDash([]);
            }
            
            update3DScene();
        }

        // --- UI & Controls ---
        function updateControlsUI() {
            const container = document.getElementById('lightControls');
            container.innerHTML = '';
            
            if (selectedLight) {
                const icon = selectedLight.type === 'circle' ? 'fa-circle' : 
                             selectedLight.type === 'rect' ? 'fa-square' : 'fa-stop';
                const typeName = selectedLight.type === 'circle' ? '圆形灯光' : 
                                 selectedLight.type === 'rect' ? '矩形灯光' : '八边形灯光';
                
                let html = `<div class="control-section">
                    <div class="control-header"><h3> ${typeName}</h3><button class="delete-button" id="deleteLightBtn"><i class="fa-solid fa-trash-can"></i></button></div>`;

                if (selectedLight.type === 'circle') {
                    html += createSlider('size', '大小', 10, 500, 1, selectedLight.size);
                } else if (selectedLight.type === 'rect') {
                    html += createSlider('width', '宽度', 10, 500, 1, selectedLight.width);
                    html += createSlider('height', '高度', 10, 500, 1, selectedLight.height);
                    html += createSlider('cornerRadius', '圆角半径', 0, 100, 1, selectedLight.cornerRadius || 0);
                    html += createSlider('rotation', '旋转角度', 0, 360, 1, selectedLight.rotation || 0);
                } else if (selectedLight.type === 'octagon') {
                    html += createSlider('size', '大小', 10, 500, 1, selectedLight.size);
                    html += createSlider('rotation', '旋转角度', 0, 360, 1, selectedLight.rotation || 0);
                }
                
                html += createColorInput('color', '颜色', selectedLight.color);
                html += createSlider('intensity', '亮度 (HDR)', 0.1, 100, 0.1, selectedLight.intensity);
                html += createSlider('falloff', '衰减 (羽化)', 0, 100, 1, selectedLight.falloff);

                html += `</div>`;
                container.innerHTML = html;
                addControlListeners();
            }
        }
        
        function createSlider(id, label, min, max, step, value) {
            return `<div class="control-group">
                        <label for="${id}">${label}</label>
                        <div class="value-display">
                            <input type="range" id="${id}" min="${min}" max="${max}" step="${step}" value="${value}">
                            <input type="number" id="${id}Value" min="${min}" max="${max}" step="${step}" value="${value}">
                        </div>
                    </div>`;
        }
        
        function createColorInput(id, label, value) {
            return `<div class="control-group">
                        <label for="${id}">${label}</label>
                        <div class="color-input-wrapper">
                          <input type="color" id="${id}" value="${value}">
                          <input type="text" id="${id}Text" value="${value}">
                        </div>
                    </div>`;
        }

        // --- Event Handlers & Core Logic ---
        function initApp() {
            // 初始化画布尺寸
            resetCanvas(HDR_WIDTH, HDR_HEIGHT);
            
            document.getElementById('resolutionSelector').addEventListener('change', (e) => {
                const [w, h] = e.target.value.split('x').map(Number);
                resetCanvas(w, h);
            });

            document.getElementById('addCircleLight').addEventListener('click', () => setAddingMode('circle'));
            document.getElementById('addRectLight').addEventListener('click', () => setAddingMode('rect'));
            document.getElementById('addOctagonLight').addEventListener('click', () => setAddingMode('octagon'));
            
            hdrCanvas.addEventListener('mousedown', handleCanvasMouseDown);
            hdrCanvas.addEventListener('mousemove', handleCanvasMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
            hdrCanvas.addEventListener('mouseleave', handleMouseUp);
            
            // 添加拖拽调整功能
            resizeHandle.addEventListener('mousedown', startResize);
            window.addEventListener('mousemove', handleResize);
            window.addEventListener('mouseup', stopResize);
            
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.addEventListener('click', () => {
                    const tabId = btn.dataset.tab;
                    background.type = tabId;
                    document.querySelectorAll('.tab-button, .tab-content').forEach(el => el.classList.remove('active'));
                    btn.classList.add('active');
                    document.getElementById(tabId + 'Tab').classList.add('active');
                    drawHdrPreview();
                });
            });

            // 背景颜色输入
            document.getElementById('bgColor').addEventListener('input', e => { 
                background.color = e.target.value; 
                drawHdrPreview(); 
            });
            
            // 渐变颜色输入
            document.getElementById('gradientColor1').addEventListener('input', e => { 
                background.gradient.color1 = e.target.value; 
                drawHdrPreview(); 
            });
            document.getElementById('gradientColor2').addEventListener('input', e => { 
                background.gradient.color2 = e.target.value; 
                drawHdrPreview(); 
            });
            
            // 渐变角度滑块和数值输入框同步
            const gradientAngleSlider = document.getElementById('gradientAngle');
            const gradientAngleValue = document.getElementById('gradientAngleValue');
            gradientAngleSlider.addEventListener('input', e => { 
                background.gradient.angle = e.target.value; 
                gradientAngleValue.value = e.target.value;
                drawHdrPreview(); 
            });
            gradientAngleValue.addEventListener('input', e => { 
                background.gradient.angle = e.target.value; 
                gradientAngleSlider.value = e.target.value;
                drawHdrPreview(); 
            });
            
            // 亮度滑块和数值输入框同步
            const bgBrightnessSlider = document.getElementById('bgBrightness');
            const bgBrightnessValue = document.getElementById('bgBrightnessValue');
            bgBrightnessSlider.addEventListener('input', e => { 
                background.brightness = e.target.value; 
                bgBrightnessValue.value = e.target.value;
                drawHdrPreview(); 
            });
            bgBrightnessValue.addEventListener('input', e => { 
                background.brightness = e.target.value; 
                bgBrightnessSlider.value = e.target.value;
                drawHdrPreview(); 
            });
            
            // 图片上传
            document.getElementById('imageUpload').addEventListener('change', handleImageUpload);
            
            // 导出HDRI
            document.getElementById('exportHdri').addEventListener('click', generateHdrFile);

            // 添加默认灯光
            lights.push({
                id: Date.now(),
                type: 'circle',
                x: HDR_WIDTH * 0.3,
                y: HDR_HEIGHT * 0.4,
                size: 120,
                color: '#ffffff',
                intensity: 25.0,
                falloff: 30,
            });
            
            lights.push({
                id: Date.now() + 1,
                type: 'rect',
                x: HDR_WIDTH * 0.7,
                y: HDR_HEIGHT * 0.6,
                width: 100,
                height: 120,
                cornerRadius: 20,
                rotation: 0,
                color: '#fff700',
                intensity: 15.0,
                falloff: 20,
            });

            lights.push({
                id: Date.now() + 2,
                type: 'octagon',
                x: HDR_WIDTH * 0.5,
                y: HDR_HEIGHT * 0.7,
                size: 100,
                rotation: 0,
                color: '#ffffff',
                intensity: 20.0,
                falloff: 25,
            });

            init3DScene();
            updateControlsUI();
            drawHdrPreview();
        }

        function resetCanvas(width, height) {
            HDR_WIDTH = width;
            HDR_HEIGHT = height;
            hdrCanvas.width = width;
            hdrCanvas.height = height;
            lights.forEach(light => {
                // 缩放灯光位置和尺寸
                light.x *= (width / 2048);
                light.y *= (height / 1024);
                if (light.type === 'circle' || light.type === 'octagon') {
                    light.size *= (width / 2048);
                } else if (light.type === 'rect') {
                    light.width *= (width / 2048);
                    light.height *= (height / 1024);
                }
            });
            drawHdrPreview();
        }

        function setAddingMode(type) {
            addingLightType = type;
            hdrCanvas.style.cursor = 'crosshair';
        }

        function handleCanvasMouseDown(e) {
            const { x, y } = getCanvasCoords(e);
            
            if (addingLightType) {
                const newLight = {
                    id: Date.now(),
                    type: addingLightType,
                    x, y,
                    color: '#ffffff',
                    intensity: 15.0,
                    falloff: 30,
                };
                
                if (addingLightType === 'circle' || addingLightType === 'octagon') {
                    newLight.size = 80 * (HDR_WIDTH / 2048);
                } else {
                    newLight.width = 120 * (HDR_WIDTH / 2048);
                    newLight.height = 60 * (HDR_HEIGHT / 1024);
                    newLight.cornerRadius = 10;
                    newLight.rotation = 0;
                }
                
                if (addingLightType === 'octagon') {
                    newLight.rotation = 0;
                }
                
                lights.push(newLight);
                selectedLight = newLight;
                addingLightType = null;
                hdrCanvas.style.cursor = 'default';
            } else {
                let clickedLight = null;
                for (let i = lights.length - 1; i >= 0; i--) {
                    const light = lights[i];
                    let hit = false;
                    
                    if (light.type === 'circle') {
                        const dist = Math.sqrt((x - light.x) ** 2 + (y - light.y) ** 2);
                        hit = dist < light.size;
                    } else if (light.type === 'rect') {
                        hit = (x > light.x - light.width/2 && 
                               x < light.x + light.width/2 && 
                               y > light.y - light.height/2 && 
                               y < light.y + light.height/2);
                    } else if (light.type === 'octagon') {
                        const dist = Math.sqrt((x - light.x) ** 2 + (y - light.y) ** 2);
                        hit = dist < light.size;
                    }
                    
                    if (hit) {
                        clickedLight = light;
                        break;
                    }
                }
                selectedLight = clickedLight;
                if (selectedLight) draggingLight = selectedLight;
            }
            updateControlsUI();
            drawHdrPreview();
        }
        
        function handleCanvasMouseMove(e) {
            if (draggingLight) {
                const { x, y } = getCanvasCoords(e);
                draggingLight.x = x;
                draggingLight.y = y;
                drawHdrPreview();
            }
        }
        
        function handleMouseUp() {
            draggingLight = null;
        }

        function getCanvasCoords(e) {
            const rect = hdrCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (HDR_WIDTH / rect.width);
            const y = (e.clientY - rect.top) * (HDR_HEIGHT / rect.height);
            return { x, y };
        }

        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    background.image = img;
                    document.querySelector('.tab-button[data-tab="image"]').click();
                    drawHdrPreview();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function startResize(e) {
            isResizing = true;
            startY = e.clientY;
            const topPreview = document.querySelector('.top-preview');
            const bottomPreview = document.querySelector('.bottom-preview');
            startTopHeight = parseFloat(getComputedStyle(topPreview).height);
            startBottomHeight = parseFloat(getComputedStyle(bottomPreview).height);
            document.body.style.cursor = 'ns-resize';
            e.preventDefault();
        }
        
        function handleResize(e) {
            if (!isResizing) return;
            
            const previewPanel = document.querySelector('.preview-panel');
            const topPreview = document.querySelector('.top-preview');
            const bottomPreview = document.querySelector('.bottom-preview');
            
            const deltaY = e.clientY - startY;
            const newTopHeight = startTopHeight + deltaY;
            const newBottomHeight = startBottomHeight - deltaY;
            
            // 设置最小高度
            if (newTopHeight > 150 && newBottomHeight > 150) {
                topPreview.style.height = `${newTopHeight}px`;
                bottomPreview.style.height = `${newBottomHeight}px`;
                
                // 更新分割线位置
                const topRect = topPreview.getBoundingClientRect();
                const panelRect = previewPanel.getBoundingClientRect();
                const relativeTop = topRect.bottom - panelRect.top;
                resizeHandle.style.top = `${relativeTop - 2}px`; // 减去2px使分割线居中
                
                // 更新canvas尺寸
                resize3DCanvas();
            }
        }
        
        function stopResize() {
            isResizing = false;
            document.body.style.cursor = '';
        }

        function addControlListeners() {
            if (!selectedLight) return;
            document.getElementById('deleteLightBtn').addEventListener('click', deleteSelectedLight);
            
            // 为所有滑块添加数值同步功能
            const sliders = document.querySelectorAll('.control-group input[type="range"]');
            sliders.forEach(slider => {
                const inputId = slider.id;
                const valueInput = document.getElementById(inputId + 'Value');
                
                // 滑块变化时更新数值输入框
                slider.addEventListener('input', e => {
                    valueInput.value = e.target.value;
                    if (selectedLight) {
                        selectedLight[inputId] = parseFloat(e.target.value);
                        drawHdrPreview();
                    }
                });
                
                // 数值输入框变化时更新滑块
                valueInput.addEventListener('input', e => {
                    slider.value = e.target.value;
                    if (selectedLight) {
                        selectedLight[inputId] = parseFloat(e.target.value);
                        drawHdrPreview();
                    }
                });
            });

            // 颜色选择器和颜色文本输入框同步
            const colorPicker = document.getElementById('color');
            const colorText = document.getElementById('colorText');
            if (colorPicker && colorText) {
                colorPicker.addEventListener('input', e => {
                    selectedLight.color = e.target.value;
                    colorText.value = e.target.value;
                    drawHdrPreview();
                });
                colorText.addEventListener('input', e => {
                    selectedLight.color = e.target.value;
                    colorPicker.value = e.target.value;
                    drawHdrPreview();
                });
            }
        }

        function deleteSelectedLight() {
            if (!selectedLight) return;
            lights = lights.filter(l => l.id !== selectedLight.id);
            selectedLight = null;
            updateControlsUI();
            drawHdrPreview();
        }

        // --- Utility Functions ---
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? { 
                r: parseInt(result[1], 16), 
                g: parseInt(result[2], 16), 
                b: parseInt(result[3], 16) 
            } : null;
        }

        // --- HDR Export ---
        function frexp(value) {
            if (value === 0) return [0, 0];
            const data = new DataView(new ArrayBuffer(8));
            data.setFloat64(0, value);
            let bits = data.getBigUint64(0);
            const sign = (bits >> 63n) === 0n ? 1 : -1;
            let exponent = Number((bits >> 52n) & 0x7ffn) - 1023;
            let mantissa = 1 + Number(bits & 0xfffffffffffffn) / (2**52);
            if (mantissa === 0) return [0,0];
            exponent += 1;
            mantissa /= 2;
            return [sign * mantissa, exponent];
        }

        function floatToRgbe(r, g, b) {
            const v = Math.max(r, g, b);
            if (v < 1e-32) return [0, 0, 0, 0];
            const res = frexp(v);
            let m = res[0];
            let e = res[1];
            m = m * 256.0 / v;
            return [ Math.floor(r * m), Math.floor(g * m), Math.floor(b * m), e + 128 ];
        }

        async function generateHdrFile() {
            console.log("Generating HDR data...");
            const floatData = new Float32Array(HDR_WIDTH * HDR_HEIGHT * 3);
            
            // Generate background data by drawing to a temp canvas
            const bgImgData = hdrCtx.getImageData(0, 0, HDR_WIDTH, HDR_HEIGHT);
            for (let i = 0; i < floatData.length / 3; i++) {
                floatData[i*3 + 0] = bgImgData.data[i*4 + 0] / 255;
                floatData[i*3 + 1] = bgImgData.data[i*4 + 1] / 255;
                floatData[i*3 + 2] = bgImgData.data[i*4 + 2] / 255;
            }
            
            const rgbeData = new Uint8Array(HDR_WIDTH * HDR_HEIGHT * 4);
            for (let i = 0; i < HDR_WIDTH * HDR_HEIGHT; i++) {
                const r = floatData[i*3], g = floatData[i*3+1], b = floatData[i*3+2];
                const rgbe = floatToRgbe(r, g, b);
                rgbeData.set(rgbe, i * 4);
            }
            const header = `#?RADIANCE\nFORMAT=32-bit_rle_rgbe\nEXPOSURE=1.0\n\n-Y ${HDR_HEIGHT} +X ${HDR_WIDTH}\n`;
            const headerBytes = new TextEncoder().encode(header);
            const fileData = new Uint8Array(headerBytes.length + rgbeData.length);
            fileData.set(headerBytes, 0);
            fileData.set(rgbeData, headerBytes.length);

            const blob = new Blob([fileData], { type: 'application/octet-stream' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `studio-light-${Date.now()}.hdr`;
            link.click();
            URL.revokeObjectURL(link.href);
        }

        // --- Initialisation ---
        window.addEventListener('load', initApp);
    </script>
</body>
</html>