<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>全面屏图片对比工具</title>
    <style>
        :root {
            --main-color: #5a64ff; /* 主色调 */
            --btcolor: linear-gradient(113deg, #4c73ff, #6a52ff); /* 按钮背景色 */
            --text1: #f0f2f5; /* 浅色背景 */
            --text2: #606277; /* 较深的文本色 */
            --text3: #8d8fa3; /* 提示文本色 */
            --dark-bg: #ffffff; /* 主内容区背景 */
            --light-bg: #e0e2e7; /* 次级背景，如棋盘格 */
            --border-color: #d0d2d7; /* 边框颜色 */
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            width: 100vw;
            height: 100vh;
            background-color: var(--dark-bg); /* 浅色背景 */
            color: var(--text2); /* 调整文本颜色 */
            position: relative;
            user-select: none;
        }

        /* 顶部菜单栏 */
        .menu-bar {
            height: 50px;
            background-color: var(--text1); /* 浅色菜单栏 */
            display: flex;
            align-items: center;
            padding: 0 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05); /* 调整阴影 */
            z-index: 200;
            border-bottom: 1px solid var(--border-color); /* 增加底部边框 */
        }

        .menu-item {
            margin-right: 25px;
            display: flex;
            align-items: center;
        }

        .menu-label {
            color: var(--text3);
            margin-right: 10px;
            font-size: 14px;
        }

        .btn {
            background: var(--btcolor);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(90, 100, 255, 0.3); /* 调整阴影 */
        }

        .btn i {
            margin-right: 6px;
            font-size: 16px;
        }

        .zoom-slider-container {
            display: flex;
            align-items: center;
            width: 200px;
        }

        .zoom-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: linear-gradient(to right, var(--main-color) 0%, var(--main-color) 100%);
            background-size: 100% 100%;
            background-repeat: no-repeat;
            border-radius: 10px;
            outline: none;
        }

        .zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: white;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2); /* 调整阴影 */
            cursor: pointer;
        }

        .zoom-value {
            min-width: 50px;
            text-align: right;
            margin-left: 10px;
            font-size: 14px;
            color: var(--text3);
        }

        .comparison-section {
            position: relative;
            width: 100%;
            height: calc(100% - 50px);
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--dark-bg); /* 主内容区背景 */
            /* 优化透明背景棋盘格 - 移到这里 */
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
            background-image: 
                linear-gradient(45deg, var(--light-bg) 25%, transparent 25%, transparent 75%, var(--light-bg) 75%, var(--light-bg)),
                linear-gradient(45deg, var(--light-bg) 25%, transparent 25%, transparent 75%, var(--light-bg) 75%, var(--light-bg));
        }

        .image-container {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            /* 移除这里的背景，确保图片在棋盘格之上 */
        }

        .image-container img {
            max-width: none;
            max-height: none;
            flex-shrink: 0;
            object-fit: contain; /* 确保图片完整显示 */
            position: absolute;
            transform-origin: 0 0;
            pointer-events: none;
            left: 0; /* 确保图片初始位置为0，方便后续计算裁剪 */
            top: 0;
        }

        #image-after {
            /* clip-path 样式将在JS中动态设置 */
        }

        .resizer {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 8px;
            background-color: var(--main-color);
            cursor: ew-resize;
            transform: translateX(-50%);
            z-index: 100;
            opacity: 0.8;
            transition: opacity 0.2s ease;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2); /* 调整阴影 */
        }

        .resizer:hover {
            opacity: 1;
        }

        .resizer::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            background: var(--btcolor);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 0 6px rgba(90, 100, 255, 0.2); /* 调整阴影 */
            pointer-events: none;
        }

        .resizer::after {
            content: '↔';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            font-weight: bold;
        }

        .drop-zone {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            pointer-events: auto;
            background-color: rgba(0, 0, 0, 0.05); /* 调整拖拽区背景 */
            border: 3px dashed transparent;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        .drop-zone.left {
            left: 0;
        }

        .drop-zone.right {
            right: 0;
        }

        .drop-zone.active {
            background-color: rgba(0, 0, 0, 0.1); /* 调整激活状态背景 */
            border-color: var(--main-color);
        }

        .drop-zone p {
            color: var(--text2); /* 调整文本颜色 */
            font-size: 1.5em;
            text-align: center;
            pointer-events: none;
            opacity: 0.8;
            margin: 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.7); /* 调整背景 */
            border-radius: 10px;
            max-width: 80%;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .drop-zone i {
            font-size: 48px;
            margin-bottom: 20px;
            color: var(--text3); /* 调整图标颜色 */
        }

        .image-overlay-text {
            position: absolute;
            top: 20px;
            padding: 8px 15px;
            background-color: rgba(255, 255, 255, 0.8); /* 调整背景 */
            color: var(--text2); /* 调整文本颜色 */
            border-radius: 6px;
            font-size: 1.1em;
            z-index: 110;
            opacity: 0;
            transition: opacity 0.3s ease;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .image-overlay-text.visible {
            opacity: 1;
        }

        #before-text {
            left: 20px;
        }

        #after-text {
            right: 20px;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .before-indicator {
            background-color: var(--main-color);
        }

        .after-indicator {
            background-color: #ff6b6b;
        }

        .tooltip {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6); /* 保持深色以保证可见性 */
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            opacity: 0.9;
            z-index: 120;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <div class="menu-bar">
        <div class="menu-item">
            <button id="reset-size" class="btn">
                <i class="fas fa-expand-arrows-alt"></i> 1:1 尺寸
            </button>
        </div>
        <div class="menu-item">
            <div class="menu-label">图片缩放:</div>
            <div class="zoom-slider-container">
                <input type="range" id="zoom-slider" class="zoom-slider" min="10" max="500" value="100">
                <div id="zoom-value" class="zoom-value">100%</div>
            </div>
        </div>
    </div>

    <div class="comparison-section" id="comparison-section">
        <div class="image-container" id="image-container-before">
            <img id="image-before" src="" alt="原图">
        </div>
        <div class="image-container" id="image-container-after">
            <img id="image-after" src="" alt="对比图">
        </div>

        <div class="resizer" id="resizer"></div>

        <div class="drop-zone left" id="drop-zone-left">
            <i class="fas fa-cloud-upload-alt"></i>
            <p>将第一张图片拖拽到这里</p>
        </div>
        <div class="drop-zone right" id="drop-zone-right">
            <i class="fas fa-cloud-upload-alt"></i>
            <p>将第二张图片拖拽到这里</p>
        </div>

        <span class="image-overlay-text" id="before-text">
            <span class="status-indicator before-indicator"></span>
            原图
        </span>
        <span class="image-overlay-text" id="after-text">
            <span class="status-indicator after-indicator"></span>
            对比图
        </span>
        
        <div class="tooltip">提示: 使用鼠标滚轮可缩放图片 | 拖动中间竖线可调整对比位置</div>
    </div>

    <script>
        const comparisonSection = document.getElementById('comparison-section');
        const imageContainerBefore = document.getElementById('image-container-before');
        const imageContainerAfter = document.getElementById('image-container-after');
        const imageBefore = document.getElementById('image-before');
        const imageAfter = document.getElementById('image-after');
        const resizer = document.getElementById('resizer');
        const dropZoneLeft = document.getElementById('drop-zone-left');
        const dropZoneRight = document.getElementById('drop-zone-right');
        const beforeText = document.getElementById('before-text');
        const afterText = document.getElementById('after-text');
        const resetSizeBtn = document.getElementById('reset-size');
        const zoomSlider = document.getElementById('zoom-slider');
        const zoomValue = document.getElementById('zoom-value');

        let isResizing = false;
        let isDragging = false;
        let startX, startY;
        let scale = 1;
        let translateX = 0;
        let translateY = 0;
        let initialTranslateX = 0;
        let initialTranslateY = 0;
        let resizerX = 0; // 记录拖动条的当前X坐标
        let maxImageHeight = 0; // 用于存储两张图片中较大的高度

        // 图片加载状态
        let imageBeforeLoaded = false;
        let imageAfterLoaded = false;

        // 图片上传逻辑
        function handleImageDrop(event, targetImage, dropZone, isBefore) {
            event.preventDefault();
            dropZone.classList.remove('active');
            const file = event.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    targetImage.src = e.target.result;
                    targetImage.onload = () => {
                        if (isBefore) {
                            imageBeforeLoaded = true;
                        } else {
                            imageAfterLoaded = true;
                        }
                        dropZone.querySelector('p').style.display = 'none';
                        dropZone.querySelector('i').style.display = 'none';
                        targetImage.style.opacity = 1;

                        if (imageBeforeLoaded && imageAfterLoaded) {
                            beforeText.classList.add('visible');
                            afterText.classList.add('visible');
                            comparisonSection.style.cursor = 'grab';
                            // 确保图片都加载完成后再进行居中和缩放计算
                            calculateInitialImageSizeAndPosition();
                        }
                    };
                };
                reader.readAsDataURL(file);
            }
        }

        // 计算初始图片尺寸和位置，并处理大小不一致的情况
        function calculateInitialImageSizeAndPosition() {
            if (!imageBefore.src || !imageAfter.src || !imageBefore.naturalWidth || !imageAfter.naturalWidth) {
                // 如果图片未完全加载，等待
                return;
            }

            const containerRect = comparisonSection.getBoundingClientRect();
            
            // 找出两张图片中较高的图片高度
            maxImageHeight = Math.max(imageBefore.naturalHeight, imageAfter.naturalHeight);

            // 计算一个缩放比例，使得图片的高度能够适应容器的高度（但不超过容器高度），并保持等比
            let initialScale = 1;
            if (maxImageHeight > containerRect.height) {
                initialScale = containerRect.height / maxImageHeight;
            }

            scale = initialScale;

            // 计算基于当前缩放比例的图片实际宽度和高度
            const scaledWidthBefore = imageBefore.naturalWidth * scale;
            const scaledHeightBefore = imageBefore.naturalHeight * scale;
            const scaledWidthAfter = imageAfter.naturalWidth * scale;
            const scaledHeightAfter = imageAfter.naturalHeight * scale;

            // 居中图片
            translateX = (containerRect.width - scaledWidthBefore) / 2;
            translateY = (containerRect.height - scaledHeightBefore) / 2; // 以before图片的高度为基准居中

            updateImageTransform();
            updateImageClip(); // 初始化裁剪位置

            // 更新缩放滑块
            zoomSlider.value = Math.round(scale * 100);
            zoomValue.textContent = `${Math.round(scale * 100)}%`;
        }

        // 更新图片 transform 属性
        function updateImageTransform() {
            const transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
            imageBefore.style.transform = transform;
            imageAfter.style.transform = transform;
        }

        // 更新图片的裁剪区域
        function updateImageClip() {
            // resizerX 是 resizer 相对于 comparisonSection 左侧的像素位置
            // imageAfter 是绝对定位且 transform-origin 是 0 0，其逻辑位置就是 translateX, translateY
            // 裁剪的左侧边缘应该是 resizerX 减去 imageAfter 的逻辑X坐标
            const clipLeft = resizerX - translateX;
            
            // clip-path 的值是相对于图片自身的，所以需要将像素值转换为百分比
            // 但是，由于我们已经通过 translateX 和 translateY 调整了图片位置，
            // 且 resizerX 是屏幕坐标，直接用像素值更准确。
            // 裁剪的左侧边缘是 (resizerX - 图片左边缘的屏幕坐标)
            // 图片的左边缘屏幕坐标 = translateX + comparisonSection.left
            // 这样，imageAfter 应该从 resizerX 所在位置开始显示
            // clipPath: inset(top right bottom left)

            // imageAfter 需要显示 resizer 往右的部分，所以左侧裁剪是 resizerX 像素
            // 但考虑到图片自身的缩放和位移，我们需要计算 resizer 对应的图片内部的像素位置。
            // resizerX 是屏幕坐标。图片的左边缘是 translateX。
            // 所以 resizer 相对于图片未缩放的原点，在图片缩放后的坐标是 (resizerX - translateX)
            // 再除以缩放比例，得到图片原始尺寸上的裁剪点
            const actualClipLeft = (resizerX - translateX) / scale;

            // 裁剪需要是相对于图片自身尺寸的
            imageAfter.style.clipPath = `inset(0px 0px 0px ${actualClipLeft}px)`;
        }


        // 为左右拖拽区域添加事件监听
        [dropZoneLeft, dropZoneRight].forEach(zone => {
            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                zone.classList.add('active');
            });
            zone.addEventListener('dragleave', () => {
                zone.classList.remove('active');
            });
            zone.addEventListener('drop', (e) => {
                if (zone === dropZoneLeft) {
                    handleImageDrop(e, imageBefore, dropZoneLeft, true);
                } else {
                    handleImageDrop(e, imageAfter, dropZoneRight, false);
                }
            });
        });

        // 拖动比较线逻辑
        resizer.addEventListener('mousedown', (e) => {
            if (!imageBefore.src || !imageAfter.src) return;
            isResizing = true;
            comparisonSection.style.cursor = 'ew-resize';
            resizer.style.transition = 'none'; // 拖动时移除过渡效果，防止延迟
            e.stopPropagation(); 
        });

        document.addEventListener('mousemove', (e) => {
            if (isResizing) {
                const comparisonRect = comparisonSection.getBoundingClientRect();
                let x = e.clientX - comparisonRect.left;
                
                // 限制拖动范围在0到comparisonSection.width之间
                if (x < 0) x = 0;
                if (x > comparisonRect.width) x = comparisonRect.width;
                
                resizerX = x; // 更新拖动条的X坐标
                resizer.style.left = `${resizerX}px`; // 直接设置像素值
                updateImageClip(); // 实时更新图片裁剪
            } else if (isDragging) {
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                translateX = initialTranslateX + dx;
                translateY = initialTranslateY + dy;
                updateImageTransform();
                updateImageClip(); // 图片拖动时也要更新裁剪
            }
        });

        document.addEventListener('mouseup', () => {
            isResizing = false;
            isDragging = false;
            resizer.style.transition = ''; // 恢复过渡效果
            if (imageBefore.src && imageAfter.src) {
                comparisonSection.style.cursor = 'grab';
            } else {
                comparisonSection.style.cursor = 'default';
            }
        });

        // 图片缩放和拖拽逻辑
        comparisonSection.addEventListener('mousedown', (e) => {
            if (!imageBefore.src || !imageAfter.src) return;
            if (e.target === resizer) return;
            
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
            
            // 获取当前的translateX和translateY作为拖拽的起始点
            const styleBefore = window.getComputedStyle(imageBefore);
            const matrix = new DOMMatrixReadOnly(styleBefore.transform);
            initialTranslateX = matrix.m41;
            initialTranslateY = matrix.m42;
            
            comparisonSection.style.cursor = 'grabbing';
        });

        comparisonSection.addEventListener('wheel', (e) => {
            if (!imageBefore.src || !imageAfter.src) return;
            
            e.preventDefault();
            
            const scaleAmount = 1.1;
            const oldScale = scale;
            
            if (e.deltaY < 0) { // 向上滚是放大
                scale *= scaleAmount;
            } else { // 向下滚是缩小
                scale /= scaleAmount;
            }
            
            // 限制最小和最大缩放
            if (scale < 0.1) scale = 0.1;
            if (scale > 10) scale = 10;
            
            // 更新缩放滑块值
            const zoomPercentage = Math.round(scale * 100);
            zoomSlider.value = zoomPercentage;
            zoomValue.textContent = `${zoomPercentage}%`;
            
            // 计算缩放中心（容器中心）
            const rect = comparisonSection.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            
            // 调整位置以保持缩放中心
            // 新的translateX = 容器中心X - ((容器中心X - 当前translateX) * (新缩放比例 / 旧缩放比例))
            translateX = centerX - ((centerX - translateX) * (scale / oldScale));
            translateY = centerY - ((centerY - translateY) * (scale / oldScale));
            
            updateImageTransform();
            updateImageClip(); // 缩放时也要更新裁剪
        });

        // 1:1 显示尺寸功能
        resetSizeBtn.addEventListener('click', resetToOriginalSize);
        
        function resetToOriginalSize() {
            if (!imageBefore.src || !imageAfter.src || !imageBeforeLoaded || !imageAfterLoaded) return; 
            
            // 重新计算初始尺寸和位置
            calculateInitialImageSizeAndPosition();

            // 重置拖动条位置
            const containerRect = comparisonSection.getBoundingClientRect();
            resizerX = containerRect.width / 2;
            resizer.style.left = `${resizerX}px`;
            updateImageClip();
        }

        // 缩放滑块功能
        zoomSlider.addEventListener('input', () => {
            if (!imageBefore.src || !imageAfter.src || !imageBeforeLoaded || !imageAfterLoaded) return;

            const zoomPercentage = parseInt(zoomSlider.value);
            const newScale = zoomPercentage / 100;
            
            if (scale === newScale) return; 
            
            const oldScale = scale;
            scale = newScale;
            
            // 更新显示
            zoomValue.textContent = `${zoomPercentage}%`;
            
            // 计算缩放中心（容器中心）
            const containerRect = comparisonSection.getBoundingClientRect();
            const centerX = containerRect.width / 2;
            const centerY = containerRect.height / 2;
            
            // 调整位置以保持中心点不变
            translateX = centerX - ((centerX - translateX) * (scale / oldScale));
            translateY = centerY - ((centerY - translateY) * (scale / oldScale));
            
            updateImageTransform();
            updateImageClip(); // 缩放时也要更新裁剪
        });

        // 初始化设置
        imageBefore.style.opacity = 0;
        imageAfter.style.opacity = 0;
        comparisonSection.style.cursor = 'default';

        // 监听窗口大小变化，重新调整图片位置和裁剪
        window.addEventListener('resize', () => {
            if (imageBeforeLoaded && imageAfterLoaded) {
                resetToOriginalSize(); // 简单粗暴地重新计算
            }
        });
    </script>
</body>
</html>