<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>在线无缝纹理制作工具 - 专业3D无缝贴图生成工具</title>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <script src="https://cdn.jsdelivr.net/npm/utif@3.1.0/UTIF.min.js"></script>
    <script src="menu.js" defer></script>
    <link rel="icon" href="img/gongjuxiang.svg" type="image/svg">
    <script defer src="https://cloud.umami.is/script.js" data-website-id="5a2e10cd-bf73-47df-be48-079c9ba7783c" data-domains="designtool.site"></script>    
    
    <style>
        /* 全局样式重置 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', 'Microsoft YaHei', sans-serif;
            background: #0f172a;
            color: #e2e8f0;
            height: 100vh;
            overflow: hidden;
        }
.vue {
	width: 10px;}
/* 标签页样式 */
.tabs-container {
    margin-bottom: 1rem;
    flex: 1;
}

.tabs-header {
    display: flex;
    border-bottom: 1px solid #334155;
}

.tab-btn {
    flex: 1;
    padding: 0.75rem 1rem;
    background: #141d2f;
    border: none;
    color: #94a3b8;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
	    border-bottom: 2px solid transparent;
	    font-size: 0.9rem;
}

.tab-btn:hover {
    background: #293950;
    color: #e2e8f0;
}

.tab-btn.active {
    background: #293950;
    color: #60a5fa;
	border-color: #60a5fa;
}

.tab-content {
    display: none;
    padding: 0;
}

.tab-content.active {
    display: block;
}
  /* 分隔条样式 */
  .divider {
    width: 8px;
    background: none;
    cursor: col-resize;
    position: relative;
    z-index: 10;
    transition: background-color 0.2s;
  }

  .divider:hover {
    
  }
.kuang {
    padding: 14px;
    border-radius: 6px;
	background: #141d2f;}
/* 添加在现有CSS中 */
#mirrorControls, #blendControls, #offsetControls, #gradientControls {
    display: none;
	margin-bottom: 8px;
}

        /* 头部样式 */
        .header {
            background: linear-gradient(135deg, #1e293b, #334155);
            padding: 0rem 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            position: relative;
	margin-left: 60px;
        }
	.selectpng {
	}
	.toptitle {
	display: flex;  
	align-items: center; 
	gap: 10px;
	}
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
	height: 60px;
        }

        .header h1 {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 1.65rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .header p {
            color: #94a3b8;
            margin-top: 0.25rem;
        }

        /* 导出控制面板 - 移到右上角 */
        .header-export {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .export-select {
            padding: 0.5rem;
            background: #374151;
            color: white;
            border: 1px solid #4b5563;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        /* 主容器 */
        .container {
            display: flex;
            height: calc(100vh - 60px);
	margin-left: 60px;
        }

        /* 左侧控制面板 */
        .sidebar {
            width: 360px;
            background: #1c2637;
            overflow-y: auto;
	    display: flex;
    flex-direction: column;
        }

        /* 主预览区域 */
        .main-content {
            flex: 1;
            display: flex;
            padding: 1rem 1rem 0.5rem;
    display: flex;
    height: calc(100vh - 60px);
        }

        .preview-panel {
            background: linear-gradient(135deg, #1e293b, #334155);
            border-radius: 6px;
            border: 1px solid #475569;
            overflow: hidden;
            display: flex;
            flex-direction: column;
	    flex: 1 1 50%; 
		/*height: calc(100vh - 160px);*/
        }

        .preview-header {
            background: linear-gradient(135deg, #374151, #4b5563);
            padding: 0.75rem 1rem;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
	height: 3rem;
        }

        .preview-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            background: 
                linear-gradient(45deg, #374151 25%, transparent 25%), 
                linear-gradient(-45deg, #374151 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #374151 75%), 
                linear-gradient(-45deg, transparent 75%, #374151 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            cursor: pointer;
	overflow: hidden;
            position: relative; /* 为箭头画布提供定位上下文 */
        }

        canvas {
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
    object-fit: contain;
    border-radius: 4px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        }

        /* 文件上传区域 */
        .upload-area {
            border: 2px dashed #475569;
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #0f172a, #1e293b);
            transition: all 0.3s ease;
            cursor: pointer;
	    margin: 14px;
        }

        .upload-area:hover {
            border-color: #3b82f6;
            background: linear-gradient(135deg, #1e293b, #334155);
        }

        .upload-area.dragover {
            border-color: #3b82f6;
            background: linear-gradient(135deg, #1e3a8a, #3730a3);
        }

        .upload-icon {
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            display: flex;
            justify-content: center;
        }

        /* 控制组 */
        .control-group, .control-group1 {
            margin-bottom: 0;
            padding: 14px;
            background: none;
            border-radius: 0;
            border: none;
        }

        .control-group h3, .control-group1 h3 {
            color: #f59e0b;
            margin-bottom: 1rem;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .control-item {
            margin-bottom: 0.5rem;
        }

        .control-item label {
            display: block;
            margin-bottom: 0.5rem;
            color: #cbd5e1;
            font-weight: 500;
        }

        .control-item input[type="range"] {
            width: 100%;
            height: 6px;
            background: #374151;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .control-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(59, 130, 246, 0.4);
        }

        .control-item input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* 按钮样式 */
        .btn {
            padding: 0.65rem 1.5rem;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.1s ease;
            margin: 0.25rem;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #2563eb, #1e40af);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .btn-secondary {
            background: none;
    	color: #94a3b8;
    	border: 1px solid #94a3b8;
	    padding: 0.5rem 0.8rem;
	display: flex;
    justify-content: center;
	margin: auto;
        }

        .btn-secondary:hover {
            border-color: #fff;
	background: #404958;
	color: #fff;
        }

        .btn-success {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }

        .btn-success:hover {
            background: linear-gradient(135deg, #0d9668, #047857);
        }

        .btn-orange {
            background: linear-gradient(113deg, #4c73ff, #6a52ff);
            color: white;
        }

        .btn-orange:hover {
            opacity: 0.92;
    box-shadow: 0 7px 18px rgba(89, 99, 255, 0.35);
	scale: 1.05;
        }

        /* 无缝化方法选择 */
        .method-selector {
            display: grid;
            gap: 0.5rem;
            margin-bottom: 1rem;
	grid-template-columns: 1fr 1fr;
        }

        .method-btn {
            padding: 0.5rem;
            background: #374151;
            border: 1px solid #4b5563;
            border-radius: 6px;
            color: #e2e8f0;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            position: relative;
        }

        .method-btn:hover {
            border-color: #6b7280;
            background: #4b5563;
        }

        .method-btn.active {
            border-color: #10b981;
            background: linear-gradient(135deg, #065f46, #047857);
            color: white;
        }

        .method-btn strong {
            display: block;
            margin-bottom: 0.25rem;
            padding-right: 20px;
        }

        .method-btn small {
            opacity: 0.8;
            font-size: 0.8rem;
            display: block;
        }

        .method-btn .order-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.3);
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }

        /* 切换按钮样式 */
        .toggle-btn {
            padding: 0.5rem;
            border-radius: 6px;
            font-size: 0.85rem;
            background: none;
            border: none;
            color: #e2e8f0;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .toggle-btn:hover {
            background: #334155;
            border-color: #64748b;
        }

        /* 数字输入框样式 */
        .number-input {
            width: 60px;
            padding: 0.25rem;
            background: #374151;
            border: 1px solid #4b5563;
            border-radius: 4px;
            color: white;
            text-align: center;
            margin-left: 8px;
        }

        .number-input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 5px;
        }

        .slider-container input[type="range"] {
            flex: 1;
        }

        /* 滚动条样式 */
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: #1e293b;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 3px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        /* 隐藏文件输入 */
        #fileInput {
            display: none;
        }

        /* 加载状态 */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* 实时预览标识 */
        .live-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.8rem;
            color: #10b981;
            margin-bottom: 1rem;
        }

        .live-dot {
            width: 6px;
            height: 6px;
            background: #10b981;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* 模态框 - 放大查看 */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            cursor: zoom-out;
            border-radius: 8px;
        }

        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            background: rgba(0,0,0,0.5);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            body {
                overflow-y: auto;
                height: auto;
            }
.tabs-container {margin-bottom: 18rem;}
	.selectpng {
	display: none;}
	.toptitle {
		flex-direction: column;
	        gap: 0;}
	.control-group1 {
		margin-bottom: 0;}
            .header {
		margin-left: 0;
	        padding: 0.5rem;
		}
            .container {
                flex-direction: column;
                height: auto;
                overflow-y: visible;
		margin-left: 0;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                border-right: none;
                border-bottom: 2px solid #475569;
            }
            
            .main-content {
                flex-direction: column;
                height: auto;
            }
            
            .header-content {
                flex-direction: column;
                gap: 1rem;
                text-align: center;
	        height: auto;
            }
            
            .header-export {
                width: 100%;
                justify-content: center;
                flex-wrap: wrap;
            }
            
            .preview-panel {
                max-height: 40vh;
	        position: fixed;
        bottom: 0;
        width: 100%;
        left: 0;
            }
            .preview-content {
		height: 80%;}
            .preview-header {
                flex-direction: column;
                gap: 0.5rem;
		display: none;
            }
            
            #toggleOriginalBtn {
                margin-top: 0.5rem;
            }
        }
        
        /* 旋转控制样式 */
        .rotation-control {
            position: relative;
            margin-bottom: 0.5rem;
        }
        
        /* 图标样式 */
        .icon {
            width: 1.2rem;
            height: 1.2rem;
        }
        
        .icon-large {
	font-size: 2.5rem;
        }
        
        .icon-xl {
            width: 4rem;
            height: 4rem;
	font-size: 4rem;
        }
        
        .fa-icon {
        }
        
        /* 箭头画布样式 */
        #arrowCanvas {
            position: absolute;
            top: 0;
            left: 0;
            display: none;
            pointer-events: none;
        }
    </style>
</head>
<body>
<div id="global-sidebar"></div>
    <div class="header">
        <div class="header-content">
            <div class="toptitle">
                <h1>
                    3D无缝纹理制作工具
                </h1>
                <p>专业的无缝贴图制作与编辑工具</p>
            </div>
            
            <div class="header-export" id="headerExport" style="display: none;">
                <span class="selectpng">选择格式</span>
		<select id="exportFormat" class="export-select">
                    <option value="image/png">PNG</option>
                    <option value="image/jpeg">JPEG</option>
                    <option value="image/webp">WebP</option>
                    <option value="image/tiff">TIFF</option>
                </select>
                <div style="display: flex; gap: 10px;"><button class="btn btn-orange" onclick="exportImage()">
                    <i class="fas fa-download fa-icon"></i>
                    下载纹理
                </button>
                <button class="btn btn-secondary" onclick="clearImage()">
                    <i class="fas fa-trash fa-icon"></i>
                    清空
                </button>
	</div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="sidebar">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">
                    <i class="fa-solid fa-cloud-arrow-up  icon-large"></i>
                </div>
                <h3>拖拽或点击图像上传</h3>
                <small>支持 PNG, JPG, BMP, WebP, TIFF</small>
            </div>
            <input type="file" id="fileInput" accept="image/*,.tiff,.tif">

<div class="tabs-container">
    <div class="tabs-header">
        <button class="tab-btn active" data-tab="seamless">
            <i class="fa-solid fa-layer-group"></i>
            无缝化处理
        </button>
        <button class="tab-btn" data-tab="adjustment">
            <i class="fas fa-sliders-h fa-icon"></i>
            图像调整
        </button>
    </div>

    <div class="tab-content active" id="seamlessTab">
        <div class="control-group" id="seamlessControls">
        <span class="live-indicator" id="liveIndicator" style="display: none;">
            <span class="live-dot"></span>
            实时预览
        </span>
        <button class="btn btn-secondary" style="width: 100%; margin-bottom: 16px;" onclick="resetSeamlessParameters()" >
            <i class="fas fa-redo fa-icon"></i>
            重置参数
        </button>
                
                <div class="method-selector">
                    <div class="method-btn" data-method="mirror">
                        <strong>镜像边缘</strong>
                        <small>镜像边缘像素</small>
                        <span class="order-indicator">1</span>
                    </div>

<div class="method-btn" data-method="gradient">
    <strong>光影矫正</strong>
    <small>渐变调整图像亮度</small>
    <span class="order-indicator">2</span>
</div>

                    <div class="method-btn" data-method="blend">
                        <strong>边缘混合</strong>
                        <small>混合相对边缘</small>
                        <span class="order-indicator">2</span>
                    </div>
                    <div class="method-btn" data-method="offset">
                        <strong>偏移映射</strong>
                        <small>重新排列图像象限</small>
                        <span class="order-indicator">3</span>
                    </div>
                </div>
                
                <div style="margin-bottom:1rem; font-size:0.9rem; color:#94a3b8;">
                    <small>提示：可同时选择多个方法，按顺序应用</small>
                </div>
                
<div id="mirrorControls" class="kuang">
    <div class="control-item">
        <label>镜像强度</label>
        <div class="slider-container">
            <input type="range" id="mirrorStrength" min="0" max="50" value="20">
            <input type="number" id="mirrorStrengthInput" class="number-input" min="0" max="50" value="20"><span class="vue">%</span>
        </div>
    </div>
    <!-- 添加渐变控制 -->
                    <div class="control-item">
                        <label>边缘亮度调整</label>
                        <div class="slider-container">
                            <input type="range" id="gradientStrength" min="-100" max="100" value="0">
                            <input type="number" id="gradientStrengthInput" class="number-input" min="-100" max="100" value="0"><span class="vue">%</span>
                        </div>
                    </div>
</div>

<!-- 在mirrorControls之后，blendControls之前添加 -->
<div id="gradientControls" style="display: none;" class="kuang">
    <div class="control-item">
        <label>渐变角度</label>
        <div class="slider-container">
            <input type="range" id="gradientAngle" min="0" max="360" value="180">
            <input type="number" id="gradientAngleInput" class="number-input" min="0" max="360" value="180"><span class="vue">°</span>
        </div>
    </div>
    <div class="control-item">
        <label>渐变延伸</label>
        <div class="slider-container">
            <input type="range" id="gradientExtend" min="0" max="100" value="50">
            <input type="number" id="gradientExtendInput" class="number-input" min="0, max="100" value="50"><span class="vue">%</span>
        </div>
    </div>
    <div class="control-item">
        <label>渐变亮度</label>
        <div class="slider-container">
            <input type="range" id="gradientBrightness" min="-100" max="100" value="50">
            <input type="number" id="gradientBrightnessInput" class="number-input" min="-100" max="100" value="50"><span class="vue">%</span>
        </div>
    </div>
</div>
                
                <div id="blendControls"  class="kuang">
                    <div class="control-item">
                        <label>混合强度</label>
                        <div class="slider-container">
                            <input type="range" id="blendStrength" min="0" max="50" value="20">
                            <input type="number" id="blendStrengthInput" class="number-input" min="0" max="50" value="20"><span class="vue">%</span>
                        </div>
                    </div>
                </div>
                
                <div id="offsetControls"  class="kuang">
                    <div class="control-item">
                        <label>水平偏移</label>
                        <div class="slider-container">
                            <input type="range" id="offsetX" min="0" max="100" value="50">
                            <input type="number" id="offsetXInput" class="number-input" min="0" max="100" value="50"><span class="vue">%</span>
                        </div>
                    </div>
                    <div class="control-item">
                        <label>垂直偏移</label>
                        <div class="slider-container">
                            <input type="range" id="offsetY" min="0" max="100" value="50">
                            <input type="number" id="offsetYInput" class="number-input" min="0" max="100" value="50"><span class="vue">%</span>
                        </div>
                    </div>
                </div>
            </div>
       </div>


    <div class="tab-content" id="adjustmentTab">
        <div class="control-group1" id="imageControls">

    <!-- 将重置按钮移到标题右侧 -->
    <button class="btn btn-secondary" style="width: 100%; margin-bottom: 16px;" onclick="resetAdjustments()" >
        <i class="fas fa-redo fa-icon"></i>
        重置调整
    </button>

                <div class="control-item rotation-control">
                    <label>旋转</label>
                    <div class="slider-container">
                        <input type="range" id="rotation" min="0" max="360" value="0">
                        <input type="number" id="rotationInput" class="number-input" min="0" max="360" value="0"><span class="vue">°</span>
                    </div>
                </div>
                
                <div class="control-item">
                    <label>亮度</label>
                    <div class="slider-container">
                        <input type="range" id="brightness" min="0" max="200" value="100">
                        <input type="number" id='brightnessInput' class="number-input" min="0" max="200" value="100"><span class="vue">%</span>
                    </div>
                </div>
                
                <div class="control-item">
                    <label>对比度</label>
                    <div class="slider-container">
                        <input type="range" id="contrast" min="0" max="200" value="100">
                        <input type="number" id="contrastInput" class="number-input" min="0" max="200" value="100"><span class="vue">%</span>
                    </div>
                </div>
                
                <div class="control-item">
                    <label>饱和度</label>
                    <div class="slider-container">
                        <input type="range" id="saturation" min="0" max="200" value="100">
                        <input type="number" id="saturationInput" class="number-input" min="0" max="200" value="100"><span class="vue">%</span>
                    </div>
                </div>
                
                <div class="control-item">
                    <label>色调</label>
                    <div class="slider-container">
                        <input type="range" id="hue" min="-180" max="180" value="0">
                        <input type="number" id="hueInput" class="number-input" min="-180" max="180" value="0"><span class="vue">%</span>
                    </div>
                </div>

            </div>

        </div>
        </div>
    </div>
<div style="display: flex; flex-direction: column; flex: 1; min-width: 0;">
        <div class="main-content">
            <div class="preview-panel" id="leftPanel">
                <div class="preview-header">
                    <span>
                        <i class="fas fa-image fa-icon"></i>
                        处理后图像
                    </span>
                    <div style="display: flex; align-items: center;">
                        <span id="imageDimensions" style="margin-right: 10px;"></span>
                        <button class="toggle-btn" id="toggleOriginalBtn" onclick="toggleOriginalPreview()">
                            <i class="fas fa-eye fa-icon"></i>
                            显示原图
                        </button>
                    </div>
                </div>
                <div class="preview-content" onclick="zoomImage()">
                    <canvas id="processedCanvas" style="display: none;"></canvas>
                    <canvas id="arrowCanvas"></canvas>
                    <div id="noImageMessage">
                        <div style="text-align: center; opacity: 0.6;">
                            <i class="fas fa-star icon-xl" style="margin-bottom: 1rem;"></i>
                            <h3>欢迎使用无缝纹理工具</h3>
                            <p>请上传图像开始制作</p>
                        </div>
                    </div>
                </div>
            </div>
<div class="divider" id="divider"></div>
            <div class="preview-panel" id="rightPanel">
<div class="preview-header">
    <span>
        <i class="fas fa-th fa-icon"></i>
        平铺预览
    </span>
    <div style="display: flex; align-items: center; gap: 10px;">
        <span>3×3 网格</span>
        <!-- 添加这个切换按钮 -->
        <button class="toggle-btn" id="toggleTiledBtn" onclick="toggleTiledPreview()">
            <i class="fas fa-eye fa-icon"></i>
            显示原图
        </button>
    </div>
</div>
                <div class="preview-content" onclick="zoomTiledImage()">
                    <canvas id="tiledCanvas" style="display: none;"></canvas>
                    <div id="noTileMessage">
                        <div style="text-align: center; opacity: 0.6;">
                            <i class="fas fa-th-large icon-xl" style="margin-bottom: 1rem;"></i>
                            <h3>平铺预览</h3>
                            <p>上传图像后查看无缝效果</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
<div style="display: none;">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3983418855272291"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="fluid"
     data-ad-layout-key="-hq-10+1x-12+2m"
     data-ad-client="ca-pub-3983418855272291"
     data-ad-slot="4487878994"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
</div>




    <div class="modal" id="imageModal">
        <div class="modal-close" onclick="closeModal()">×</div>
        <img id="modalImage" class="modal-content" src="" alt="放大图像">
    </div>

    <script>
        // 全局变量
        let showTiledOriginal = false;
        let originalImageData = null;
        let processedCanvas = document.getElementById('processedCanvas');
        // 修复Canvas2D性能警告：设置willReadFrequently属性
        let processedCtx = processedCanvas.getContext('2d', { willReadFrequently: true });
        let tiledCanvas = document.getElementById('tiledCanvas');
        let tiledCtx = tiledCanvas.getContext('2d', { willReadFrequently: true });
        let activeMethods = []; // 存储选中的无缝处理方法
        let isRealTimePreview = false;
        let showOriginal = false; // 是否显示原图模式
        let adjustCanvas = document.createElement('canvas'); // 用于保存调整后的图像
        let adjustCtx = adjustCanvas.getContext('2d', { willReadFrequently: true });
        let rotatedCanvas = document.createElement('canvas'); // 用于旋转后的图像
        let rotatedCtx = rotatedCanvas.getContext('2d', { willReadFrequently: true });
        
        // 箭头画布相关变量
        let arrowCanvas = document.getElementById('arrowCanvas');
        let arrowCtx = arrowCanvas.getContext('2d');
        let arrowTimeout = null; // 用于隐藏箭头的定时器

        // 初始化
        document.addEventListener('DOMContentLoaded', function() {
            initializeEventListeners();
            initializeSliders();
            initializeNumberInputs(); // 初始化数字输入框
            // 确保所有方法控制面板初始状态为隐藏
            hideAllMethodControls();
        });
        
        // 新增函数：隐藏所有方法控制面板
        function hideAllMethodControls() {
            document.getElementById('mirrorControls').style.display = 'none';
            document.getElementById('gradientControls').style.display = 'none';
            document.getElementById('blendControls').style.display = 'none';
            document.getElementById('offsetControls').style.display = 'none';
        }
        
        function initializeEventListeners() {
            // 文件上传
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');

            uploadArea.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect);

            // 拖拽上传
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    loadImage(files[0]);
                }
            });

    window.addEventListener('resize', function() {
    if (originalImageData) {
        const previewContent = document.querySelector('.preview-content');
        arrowCanvas.width = previewContent.clientWidth;
        arrowCanvas.height = previewContent.clientHeight;
        
        // 如果当前正在显示箭头，重新绘制
        if (arrowCanvas.style.display === 'block') {
            drawArrow();
        }
    }
});
            // 添加标签切换功能
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const tab = this.dataset.tab;
                    
                    // 更新按钮状态
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    
                    // 更新内容显示
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                    document.getElementById(tab + 'Tab').classList.add('active');
                });
            });
            
            // 分隔条拖动功能
            const divider = document.getElementById('divider');
            const leftPanel = document.getElementById('leftPanel');
            const rightPanel = document.getElementById('rightPanel');
            const container = document.querySelector('.main-content');
            
            let isResizing = false;
            
            divider.addEventListener('mousedown', function(e) {
                isResizing = true;
                document.body.style.cursor = 'col-resize';
                // 阻止拖动时选中文本
                leftPanel.style.userSelect = 'none';
                leftPanel.style.pointerEvents = 'none';
                rightPanel.style.userSelect = 'none';
                rightPanel.style.pointerEvents = 'none';
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isResizing) return;
                
                const containerRect = container.getBoundingClientRect();
                if (containerRect.width === 0) return; // 避免除以零错误
                
                const percentage = (e.clientX - containerRect.left) / containerRect.width * 100;
                
                // 设置最小宽度限制为10%
                const leftPercentage = Math.max(25, Math.min(75, percentage));
                
                leftPanel.style.flex = `1 1 ${leftPercentage}%`;
                rightPanel.style.flex = `1 1 ${100 - leftPercentage}%`;
            });
            
            document.addEventListener('mouseup', function() {
                if (!isResizing) return;
                isResizing = false;
                document.body.style.cursor = '';
                // 恢复面板的正常交互
                leftPanel.style.userSelect = '';
                leftPanel.style.pointerEvents = '';
                rightPanel.style.userSelect = '';
                rightPanel.style.pointerEvents = '';
            });

            // 模态框点击空白区域关闭
            const imageModal = document.getElementById('imageModal');
            imageModal.addEventListener('click', function(event) {
                // 检查点击事件的目标是否是模态框背景本身 (而不是图片)
                if (event.target === this) {
                    closeModal();
                }
            });

            // 方法选择事件处理
            document.querySelectorAll('.method-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    this.classList.toggle('active');
                    const method = this.dataset.method;
                    
                    if (this.classList.contains('active')) {
                        if (!activeMethods.includes(method)) {
                            activeMethods.push(method);
                        }
                    } else {
                        const index = activeMethods.indexOf(method);
                        if (index > -1) {
                            activeMethods.splice(index, 1);
                        }
                    }
                    
                    // 显示/隐藏对应的控制参数
                    toggleMethodControls(method, this.classList.contains('active'));
                    
                    // 更新顺序指示器
                    updateMethodOrderIndicators();
                    
                    // 如果启用实时预览，立即应用
                    if (isRealTimePreview && originalImageData) {
                        applySeamlessEffect();
                    }
                });
            });
        }

        // 添加这个新函数来控制参数显示/隐藏
        function toggleMethodControls(method, isActive) {
            switch(method) {
                case 'mirror':
                    document.getElementById('mirrorControls').style.display = isActive ? 'block' : 'none';
                    break;
                case 'blend':
                    document.getElementById('blendControls').style.display = isActive ? 'block' : 'none';
                    break;
                case 'offset':
                    document.getElementById('offsetControls').style.display = isActive ? 'block' : 'none';
                    break;
                case 'gradient':
                    document.getElementById('gradientControls').style.display = isActive ? 'block' : 'none';
                    break;
            }
        }
        
        // 添加切换函数
        function toggleTiledPreview() {
            showTiledOriginal = !showTiledOriginal;
            const btn = document.getElementById('toggleTiledBtn');
            
            if (showTiledOriginal) {
                btn.classList.add('active');
                btn.innerHTML = `
                    <i class="fa-solid fa-eye-slash"></i>
                    显示修改
                `;
            } else {
                btn.classList.remove('active');
                btn.innerHTML = `
                    <i class="fas fa-eye fa-icon"></i>
                    显示原图
                `;
            }
            
            updateTiledPreview();
        }

        function initializeSliders() {
            // 图像调整滑竿
            ['brightness', 'contrast', 'saturation', 'hue', 'rotation'].forEach(id => {
                const slider = document.getElementById(id);
                
                slider.addEventListener('input', function() {
                    applyImageAdjustments();
                });
            });

            // 镜像强度控制 - 实时预览
            const mirrorSlider = document.getElementById('mirrorStrength');
            mirrorSlider.addEventListener('input', function() {
                if (isRealTimePreview && activeMethods.includes('mirror') && originalImageData) {
                    applySeamlessEffect();
                }
            });
            
            // 渐变强度控制 - 实时预览
            const gradientSlider = document.getElementById('gradientStrength');
            gradientSlider.addEventListener('input', function() {
                if (isRealTimePreview && activeMethods.includes('mirror') && originalImageData) {
                    applySeamlessEffect();
                }
            });
            
            // 光影矫正控制 - 实时预览
            ['gradientAngle', 'gradientExtend', 'gradientBrightness'].forEach(id => {
                const slider = document.getElementById(id);
                slider.addEventListener('input', function() {
                    if (isRealTimePreview && activeMethods.includes('gradient') && originalImageData) {
                        applySeamlessEffect();
                    }
                });
                
                // 为渐变角度添加特殊处理 - 显示箭头
                if (id === 'gradientAngle') {
                    slider.addEventListener('input', function() {
                        showArrowIndicator();
                    });
                    
                    slider.addEventListener('change', function() {
                        hideArrowIndicator();
                    });
                }
            });
            
            // 偏移控制 - 实时预览
            ['offsetX', 'offsetY'].forEach(id => {
                const slider = document.getElementById(id);
                
                slider.addEventListener('input', function() {
                    if (isRealTimePreview && activeMethods.includes('offset') && originalImageData) {
                        applySeamlessEffect();
                    }
                });
            });

            // 混合强度 - 实时预览
            const blendSlider = document.getElementById('blendStrength');
            blendSlider.addEventListener('input', function() {
                if (isRealTimePreview && activeMethods.includes('blend') && originalImageData) {
                    applySeamlessEffect();
                }
            });
        }

        // 初始化数字输入框
        function initializeNumberInputs() {
            // 图像调整参数
            const adjustParams = [
                {id: 'brightness', min: 0, max: 200, unit: '%'},
                {id: 'contrast', min: 0, max: 200, unit: '%'},
                {id: 'saturation', min: 0, max: 200, unit: '%'},
                {id: 'hue', min: -180, max: 180, unit: '°'},
                {id: 'rotation', min: 0, max: 360, unit: '°'}
            ];
            
            // 无缝处理参数
            const seamlessParams = [
                {id: 'mirrorStrength', min: 0, max: 50, unit: '%'},
                {id: 'gradientStrength', min: -100, max: 100, unit: '%'},
                {id: 'blendStrength', min: 0, max: 50, unit: '%'},
                {id: 'offsetX', min: 0, max: 100, unit: '%'},
                {id: 'offsetY', min: 0, max: 100, unit: '%'},
                {id: 'gradientAngle', min: 0, max: 360, unit: '°'},
                {id: 'gradientExtend', min: 0, max: 100, unit: '%'},
                {id: 'gradientBrightness', min: -100, max: 100, unit: '%'}
            ];
            
            // 为所有参数设置输入框事件
            [...adjustParams, ...seamlessParams].forEach(param => {
                const slider = document.getElementById(param.id);
                const input = document.getElementById(param.id + 'Input');
                
                // 输入框变化时更新滑块
                input.addEventListener('input', function() {
                    let value = Math.max(param.min, Math.min(param.max, Number(this.value)));
                    this.value = value;
                    slider.value = value;
                    
                    // 触发相应的处理
                    if (adjustParams.find(p => p.id === param.id)) {
                        applyImageAdjustments();
                    } else if (isRealTimePreview && originalImageData) {
                        applySeamlessEffect();
                    }
                    
                    // 如果是渐变角度，显示箭头
                    if (param.id === 'gradientAngle') {
                        showArrowIndicator();
                    }
                });
                
                // 滑块变化时更新输入框
                slider.addEventListener('input', function() {
                    input.value = this.value;
                });
                
                // 如果是渐变角度输入框，添加失去焦点事件隐藏箭头
                if (param.id === 'gradientAngle') {
                    input.addEventListener('blur', function() {
                        hideArrowIndicator();
                    });
                }
            });
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                loadImage(file);
            }
        }

        function loadImage(file) {
            // 检查是否是TIFF文件
            if (file.type === 'image/tiff' || file.name.toLowerCase().endsWith('.tiff') || file.name.toLowerCase().endsWith('.tif')) {
                loadTiffImage(file);
                return;
            }
            
            // 处理其他格式
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    originalImageData = {
                        image: img,
                        width: img.width,
                        height: img.height
                    };
                    
                    setupCanvases();
                    drawOriginalImage();
                    applyImageAdjustments();
                    showControls();
                    updateImageDimensions();
                    enableRealTimePreview();
                    
		activeMethods.forEach(method => {
            toggleMethodControls(method, true);
        });
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // 添加窗口大小改变时的监听
        window.addEventListener('resize', adjustCanvasDisplay);
        
        function adjustCanvasDisplay() {
            if (!originalImageData) return;
            
            const container = document.querySelector('.preview-content');
            const canvas = document.getElementById('processedCanvas');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            const imgRatio = originalImageData.width / originalImageData.height;
            const containerRatio = containerWidth / containerHeight;
            
            // 根据容器和图片比例调整canvas显示尺寸
            if (imgRatio > containerRatio) {
                // 图片更宽，以宽度为基准
                canvas.style.width = '100%';
                canvas.style.height = 'auto';
            } else {
                // 图片更高，以高度为基准
                canvas.style.width = 'auto';
                canvas.style.height = '100%';
            }
        }

        function loadTiffImage(file) {
            // 检查 UTIF 库是否已加载。如果未加载，说明 <script> 标签加载失败。
            if (typeof UTIF === 'undefined') {
                alert('TIFF 支持库加载失败。请检查您的网络连接并刷新页面。');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const buffer = e.target.result;
                    const ifds = UTIF.decode(buffer);
                    // 处理多页TIFF，我们只使用第一页
                    const page = ifds[0];
                    UTIF.decodeImage(buffer, page);
                    
                    const canvas = document.createElement('canvas');
                    // 修复Canvas2D性能警告：设置willReadFrequently属性
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    canvas.width = page.width;
                    canvas.height = page.height;
                    
                    const rgba = UTIF.toRGBA8(page);
                    const imageData = new ImageData(
                        new Uint8ClampedArray(rgba), 
                        page.width, 
                        page.height
                    );
                    ctx.putImageData(imageData, 0, 0);
                    
                    const img = new Image();
                    img.onload = function() {
                        originalImageData = {
                            image: img,
                            width: img.width,
                            height: img.height
                        };
                        
                        setupCanvases();
                        drawOriginalImage();
                        applyImageAdjustments();
                        showControls();
                        updateImageDimensions();
                        enableRealTimePreview();
                    };
                    img.src = canvas.toDataURL();
                } catch (error) {
                    console.error('TIFF 加载错误:', error);
                    alert('无法处理此TIFF文件，可能已损坏或格式不受支持。');
                }
            };
            reader.onerror = () => {
                alert('文件读取失败。');
            };
            reader.readAsArrayBuffer(file);
        }

        function setupCanvases() {
            const { width, height } = originalImageData;
            
            // 设置处理后图像画布
            processedCanvas.width = width;
            processedCanvas.height = height;
            
            // 设置平铺预览画布
            tiledCanvas.width = width * 3;
            tiledCanvas.height = height * 3;
            
            // 设置调整画布
            adjustCanvas.width = width;
            adjustCanvas.height = height;
            
            // 设置旋转画布 - 保持原始尺寸
            rotatedCanvas.width = width;
            rotatedCanvas.height = height;
            
            // 设置箭头画布 - 修改为与显示尺寸一致，而不是图像原始尺寸
    const previewContent = document.querySelector('.preview-content');
    arrowCanvas.width = previewContent.clientWidth;
    arrowCanvas.height = previewContent.clientHeight;
            
            // 显示画布
            processedCanvas.style.display = 'block';
            tiledCanvas.style.display = 'block';
            document.getElementById('noImageMessage').style.display = 'none';
            document.getElementById('noTileMessage').style.display = 'none';
        }

        function drawOriginalImage() {
            processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
            processedCtx.drawImage(originalImageData.image, 0, 0);
            
            // 保存到调整画布
            adjustCtx.clearRect(0, 0, adjustCanvas.width, adjustCanvas.height);
            adjustCtx.drawImage(originalImageData.image, 0, 0);
        }

        function applyImageAdjustments() {
            if (!originalImageData) return;
            
            const brightness = document.getElementById('brightness').value;
            const contrast = document.getElementById('contrast').value;
            const saturation = document.getElementById('saturation').value;
            const hue = document.getElementById('hue').value;
            const rotation = document.getElementById('rotation').value;
            
            // 清除并重绘原图
            processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
            
            // 应用滤镜
            const filters = [
                `brightness(${brightness}%)`,
                `contrast(${contrast}%)`,
                `saturate(${saturation}%)`,
                `hue-rotate(${hue}deg)`
            ];
            
            processedCtx.filter = filters.join(' ');
            processedCtx.drawImage(originalImageData.image, 0, 0);
            processedCtx.filter = 'none';
            
            // 保存调整后的图像到调整画布
            adjustCtx.clearRect(0, 0, adjustCanvas.width, adjustCanvas.height);
            adjustCtx.filter = filters.join(' ');
            adjustCtx.drawImage(originalImageData.image, 0, 0);
            adjustCtx.filter = 'none';
            
            // 应用旋转（围绕中心旋转并铺满）
            applyRotation(rotation);
            
            // 根据显示模式更新预览
            if (showOriginal) {
                // 显示调整后的图像（未应用无缝效果）
                processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
                processedCtx.drawImage(rotatedCanvas, 0, 0);
            } else {
                // 应用无缝效果
                applySeamlessEffect();
            }
            
            // 更新平铺预览
            updateTiledPreview();
        }
        
        // --- 已修复的旋转函数 ---
        function applyRotation(rotation) {
            const { width, height } = adjustCanvas;

            // 设置旋转画布尺寸以保持原始尺寸
            rotatedCanvas.width = width;
            rotatedCanvas.height = height;
            rotatedCtx.clearRect(0, 0, width, height);

            // 如果不旋转，直接复制图像并返回
            if (rotation == 0) {
                rotatedCtx.drawImage(adjustCanvas, 0, 0);
                return;
            }

            const radians = rotation * Math.PI / 180;
            
            // 计算覆盖整个画布所需的缩放比例
            // 以确保旋转后的图像的边缘可以延伸到画布的角落之外
            const absCos = Math.abs(Math.cos(radians));
            const absSin = Math.abs(Math.sin(radians));
            
            // 这是为确保旋转后的矩形能填满原始矩形区域所需的最小放大比例
            // 计算缩放比例，使其能填满原始宽度和高度
            const scaleX = width / (width * absCos + height * absSin);
            const scaleY = height / (width * absSin + height * absCos);
            const scale = 1 / Math.min(scaleX, scaleY);

            // 保存当前上下文状态
            rotatedCtx.save();
            
            // 移动到画布中心
            rotatedCtx.translate(width / 2, height / 2);
            
            // 旋转上下文
            rotatedCtx.rotate(radians);
            
            // 缩放上下文以确保覆盖
            rotatedCtx.scale(scale, scale);
            
            // 在新的中心点绘制图像（原点现在是画布中心）
            rotatedCtx.drawImage(adjustCanvas, -width / 2, -height / 2);
            
            // 恢复上下文状态
            rotatedCtx.restore();
        }

        function enableRealTimePreview() {
            isRealTimePreview = true;
            document.getElementById('liveIndicator').style.display = 'none';
            
            // 立即应用无缝效果
            if (originalImageData) {
                applySeamlessEffect();
            }
        }

        function applySeamlessEffect() {
            if (!originalImageData || showOriginal) return;
            
            const tempCanvas = document.createElement('canvas');
            // 修复Canvas2D性能警告：设置willReadFrequently属性
            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
            tempCanvas.width = rotatedCanvas.width;
            tempCanvas.height = rotatedCanvas.height;
            
            // 复制旋转后的图像
            tempCtx.drawImage(rotatedCanvas, 0, 0);
            
            // 应用所有选中的无缝处理方法
            if (activeMethods.length > 0) {
                // 按照预设顺序应用方法
                const methodOrder = ['offset', 'gradient', 'mirror', 'blend'];
                
                methodOrder.forEach(method => {
                    if (activeMethods.includes(method)) {
                        switch (method) {
                            case 'mirror':
                                applyMirrorSeamless(tempCanvas);
                                break;
                            case 'gradient':
                                applyGradientCorrection(tempCanvas);
                                break;
                            case 'offset':
                                applyOffsetSeamless(tempCanvas);
                                break;
                            case 'blend':
                                applyBlendSeamless(tempCanvas);
                                break;
                        }
                    }
                });
            }
            
            // 更新显示
            processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
            processedCtx.drawImage(tempCanvas, 0, 0);
            updateTiledPreview();
        }

        // 修改后的applyGradientCorrection函数
        function applyGradientCorrection(sourceCanvas) {
            const { width, height } = sourceCanvas;
            const ctx = sourceCanvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // 获取参数值
            const angle = parseInt(document.getElementById('gradientAngle').value);
            const extend = parseInt(document.getElementById('gradientExtend').value) / 100;
            const brightness = parseInt(document.getElementById('gradientBrightness').value);
            
            // 计算角度对应的方向向量
            const rad = angle * Math.PI / 180;
            const dirX = Math.sin(rad);
            const dirY = -Math.cos(rad); // 负号是因为图像坐标系Y轴向下
            
            // 计算图像对角线长度作为最大距离
            const maxDist = Math.sqrt(width * width + height * height);
            
            // 计算图像中心
            const centerX = width / 2;
            const centerY = height / 2;
            
            // 计算四个角点在方向向量上的投影值，找到最小和最大值
            let minProjection = Infinity;
            let maxProjection = -Infinity;
            
            // 检查四个角点
            const corners = [
                [0, 0],          // 左上
                [width, 0],      // 右上
                [0, height],     // 左下
                [width, height]  // 右下
            ];
            
            corners.forEach(([x, y]) => {
                const relX = x - centerX;
                const relY = y - centerY;
                const projection = relX * dirX + relY * dirY;
                minProjection = Math.min(minProjection, projection);
                maxProjection = Math.max(maxProjection, projection);
            });
            
            const projectionRange = maxProjection - minProjection;
            
            // 处理每个像素
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = (y * width + x) * 4;
                    
                    // 计算像素相对于图像中心的位置
                    const relX = x - centerX;
                    const relY = y - centerY;
                    
                    // 计算在渐变方向上的投影距离
                    const projection = relX * dirX + relY * dirY;
                    
                    // 归一化投影值到[0,1]范围
                    const normalizedProjection = (projection - minProjection) / projectionRange;
                    
                    // 应用延伸参数
                    const effectiveProjection = Math.max(0, Math.min(1, normalizedProjection * extend));
                    
                    // 应用亮度调整
                    const adjust = brightness * effectiveProjection;
                    
                    for (let i = 0; i < 3; i++) {
                        data[index + i] = Math.max(0, Math.min(255, data[index + i] + adjust));
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        // 渐变过渡参数处理函数 - 修改为处理亮度
        function applyMirrorSeamless(sourceCanvas) {
            const { width, height } = sourceCanvas;
            const ctx = sourceCanvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const newData = new Uint8ClampedArray(data);
            
            const strength = parseInt(document.getElementById('mirrorStrength').value);
            const gradientStrength = parseInt(document.getElementById('gradientStrength').value);
            const edgeSize = Math.min(width, height) * strength / 100;
            
            // 计算图像中心点
            const centerX = width / 2;
            const centerY = height / 2;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = (y * width + x) * 4;
                    
                    // 计算到边缘的距离
                    const distLeft = x;
                    const distRight = width - 1 - x;
                    const distTop = y;
                    const distBottom = height - 1 - y;
                    
                    const minDistX = Math.min(distLeft, distRight);
                    const minDistY = Math.min(distTop, distBottom);
                    
                    // 计算到中心的归一化距离 (0-1)
                    const distToCenterX = Math.abs(x - centerX) / centerX;
                    const distToCenterY = Math.abs(y - centerY) / centerY;
                    const distanceToCenter = Math.sqrt(distToCenterX * distToCenterX + distToCenterY * distToCenterY);
                    
                    // 处理边缘像素
                    if (minDistX < edgeSize || minDistY < edgeSize) {
                        const weightX = minDistX < edgeSize ? minDistX / edgeSize : 1;
                        const weightY = minDistY < edgeSize ? minDistY / edgeSize : 1;
                        const weight = Math.min(weightX, weightY);
                        
                        // 获取镜像位置的像素
                        const mirrorX = distLeft < distRight ? width - 1 - x : x;
                        const mirrorY = distTop < distBottom ? height - 1 - y : y;
                        const mirrorIndex = (mirrorY * width + mirrorX) * 4;
                        
                        // 混合像素
                        for (let i = 0; i < 3; i++) {
                            newData[index + i] = data[index + i] * weight + data[mirrorIndex + i] * (1 - weight);
                        }
                    }
                    
                    // 应用渐变亮度调整（如果有设置）
                    if (gradientStrength !== 0) {
                        // 计算边缘影响因子 (0-1)
                        let edgeFactor = 0;
                        if (minDistX < edgeSize) edgeFactor = Math.max(edgeFactor, 1 - (minDistX / edgeSize));
                        if (minDistY < edgeSize) edgeFactor = Math.max(edgeFactor, 1 - (minDistY / edgeSize));
                        
                        // 应用亮度调整（基于边缘影响因子和渐变强度）
                        const brightnessAdjustment = gradientStrength * edgeFactor;
                        
                        for (let i = 0; i < 3; i++) {
                            let newValue = newData[index + i] + brightnessAdjustment;
                            newData[index + i] = Math.max(0, Math.min(255, newValue));
                        }
                    }
                }
            }
            
            const newImageData = new ImageData(newData, width, height);
            ctx.putImageData(newImageData, 0, 0);
        }

        function applyOffsetSeamless(sourceCanvas) {
            const { width, height } = sourceCanvas;
            const ctx = sourceCanvas.getContext('2d');
            
            const offsetX = parseInt(document.getElementById('offsetX').value);
            const offsetY = parseInt(document.getElementById('offsetY').value);
            
            const actualOffsetX = Math.floor(width * offsetX / 100);
            const actualOffsetY = Math.floor(height * offsetY / 100);
            
            // 创建临时画布保存原图
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = width;
            tempCanvas.height = height;
            tempCtx.drawImage(sourceCanvas, 0, 0);
            
            // 清空原画布
            ctx.clearRect(0, 0, width, height);
            
            // 重新排列四象限
            // 左上 -> 右下
            ctx.drawImage(tempCanvas, 
                0, 0, width - actualOffsetX, height - actualOffsetY,
                actualOffsetX, actualOffsetY, width - actualOffsetX, height - actualOffsetY
            );
            
            // 右上 -> 左下
            ctx.drawImage(tempCanvas,
                width - actualOffsetX, 0, actualOffsetX, height - actualOffsetY,
                0, actualOffsetY, actualOffsetX, height - actualOffsetY
            );
            
            // 左下 -> 右上
            ctx.drawImage(tempCanvas,
                0, height - actualOffsetY, width - actualOffsetX, actualOffsetY,
                actualOffsetX, 0, width - actualOffsetX, actualOffsetY
            );
            
            // 右下 -> 左上
            ctx.drawImage(tempCanvas,
                width - actualOffsetX, height - actualOffsetY, actualOffsetX, actualOffsetY,
                0, 0, actualOffsetX, actualOffsetY
            );
        }

        function applyBlendSeamless(sourceCanvas) {
            const { width, height } = sourceCanvas;
            const ctx = sourceCanvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const newData = new Uint8ClampedArray(data);
            
            const strength = parseInt(document.getElementById('blendStrength').value);
            const blendSize = Math.floor(Math.min(width, height) * strength / 200);
            
            if (blendSize === 0) return;
            
            // 水平边缘混合
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < blendSize; x++) {
                    const leftIndex = (y * width + x) * 4;
                    const rightIndex = (y * width + (width - 1 - x)) * 4;
                    const weight = (x + 1) / (blendSize + 1);
                    
                    for (let i = 0; i < 3; i++) {
                        const leftOriginal = data[leftIndex + i];
                        const rightOriginal = data[rightIndex + i];
                        
                        newData[leftIndex + i] = leftOriginal * weight + rightOriginal * (1 - weight);
                        newData[rightIndex + i] = rightOriginal * weight + leftOriginal * (1 - weight);
                    }
                }
            }
            
            // 垂直边缘混合
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < blendSize; y++) {
                    const topIndex = (y * width + x) * 4;
                    const bottomIndex = ((height - 1 - y) * width + x) * 4;
                    const weight = (y + 1) / (blendSize + 1);
                    
                    for (let i = 0; i < 3; i++) {
                        const topOriginal = data[topIndex + i];
                        const bottomOriginal = data[bottomIndex + i];
                        
                        newData[topIndex + i] = topOriginal * weight + bottomOriginal * (1 - weight);
                        newData[bottomIndex + i] = bottomOriginal * weight + topOriginal * (1 - weight);
                    }
                }
            }
            
            const finalImageData = new ImageData(newData, width, height);
            ctx.putImageData(finalImageData, 0, 0);
        }

        function updateTiledPreview() {
            if (!originalImageData) return;
            
            const { width, height } = processedCanvas;
            
            // 清空平铺画布
            tiledCtx.clearRect(0, 0, tiledCanvas.width, tiledCanvas.height);
            
            // 确定要绘制的源画布
            const sourceCanvas = showTiledOriginal ? rotatedCanvas : processedCanvas;
            
            // 绘制3x3网格
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    tiledCtx.drawImage(sourceCanvas, x * width, y * height);
                }
            }
        }

        function updateMethodOrderIndicators() {
            document.querySelectorAll('.method-btn').forEach(btn => {
                const method = btn.dataset.method;
                const indicator = btn.querySelector('.order-indicator');
                
                if (activeMethods.includes(method)) {
                    const order = activeMethods.indexOf(method) + 1;
                    indicator.textContent = order;
                    indicator.style.display = 'flex';
                } else {
                    indicator.style.display = 'none';
                }
            });
        }

        function showControls() {
            document.getElementById('imageControls').style.display = 'block';
            document.getElementById('seamlessControls').style.display = 'block';
            document.getElementById('headerExport').style.display = 'flex';
        }

        function updateImageDimensions() {
            if (originalImageData) {
                document.getElementById('imageDimensions').textContent = 
                    `${rotatedCanvas.width} × ${rotatedCanvas.height}`;
            }
        }

        function resetAdjustments() {
            // 重置滑块和输入框的值
            document.getElementById('brightness').value = 100;
            document.getElementById('brightnessInput').value = 100;
            document.getElementById('contrast').value = 100;
            document.getElementById('contrastInput').value = 100;
            document.getElementById('saturation').value = 100;
            document.getElementById('saturationInput').value = 100;
            document.getElementById('hue').value = 0;
            document.getElementById('hueInput').value = 0;
            document.getElementById('rotation').value = 0;
            document.getElementById('rotationInput').value = 0;
            
            applyImageAdjustments();
        }

        function toggleOriginalPreview() {
            showOriginal = !showOriginal;
            const btn = document.getElementById('toggleOriginalBtn');
            
            if (showOriginal) {
                // 显示原图（调整后的图像）
                processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
                processedCtx.drawImage(rotatedCanvas, 0, 0);
                btn.classList.add('active');
                btn.innerHTML = `
                    <i class="fa-solid fa-eye-slash"></i>
                    显示修改
                `;
            } else {
                // 显示处理结果，重新应用无缝处理
                applySeamlessEffect();
                btn.classList.remove('active');
                btn.innerHTML = `
                    <i class="fas fa-eye fa-icon"></i>
                    显示原图
                `;
            }
        }
        
        function resetSeamlessParameters() {
            // 重置滑块和输入框为初始值
            document.getElementById('mirrorStrength').value = 20;
            document.getElementById('mirrorStrengthInput').value = 20;
            document.getElementById('blendStrength').value = 20;
            document.getElementById('blendStrengthInput').value = 20;
            document.getElementById('gradientStrength').value = 0;
            document.getElementById('gradientStrengthInput').value = 0;
            document.getElementById('offsetX').value = 50;
            document.getElementById('offsetXInput').value = 50;
            document.getElementById('offsetY').value = 50;
            document.getElementById('offsetYInput').value = 50;
            
            // 新增光影矫正参数重置
            document.getElementById('gradientAngle').value = 180;
            document.getElementById('gradientAngleInput').value = 180;
            document.getElementById('gradientExtend').value = 50;
            document.getElementById('gradientExtendInput').value = 50;
            document.getElementById('gradientBrightness').value = 50;
            document.getElementById('gradientBrightnessInput').value = 50;
            
            // 重置所有方法选择按钮
            activeMethods = [];
            document.querySelectorAll('.method-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.querySelector('.order-indicator').style.display = 'none';
                // 隐藏所有控制面板
                toggleMethodControls(btn.dataset.method, false);
            });
            
            // 重新应用效果
            if (originalImageData) {
                applySeamlessEffect();
            }
        }
        
        // 图像放大功能
        function zoomImage() {
            if (!originalImageData) return;
            
            const dataURL = processedCanvas.toDataURL();
            const modal = document.getElementById('imageModal');
            const modalImage = document.getElementById('modalImage');
            
            modalImage.src = dataURL;
            modal.style.display = 'flex';
        }
        
        function zoomTiledImage() {
            if (!originalImageData) return;
            
            const dataURL = tiledCanvas.toDataURL();
            const modal = document.getElementById('imageModal');
            const modalImage = document.getElementById('modalImage');
            
            modalImage.src = dataURL;
            modal.style.display = 'flex';
        }
        
        function closeModal() {
            document.getElementById('imageModal').style.display = 'none';
        }

        function exportImage() {
            if (!originalImageData) return;
            
            const format = document.getElementById('exportFormat').value;
            let quality = 1;
            let extension = 'png';
            
            // 根据格式设置质量和扩展名
            switch (format) {
                case 'image/jpeg':
                    quality = 0.9;
                    extension = 'jpg';
                    break;
                case 'image/webp':
                    quality = 0.9;
                    extension = 'webp';
                    break;
                case 'image/tiff':
                    // TIFF导出会转换为高质量PNG
                    extension = 'tiff';
                    break;
                default:
                    extension = 'png';
            }
            
            const actualFormat = format === 'image/tiff' ? 'image/png' : format;
            
            processedCanvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `seamless-texture-${Date.now()}.${extension}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, actualFormat, quality);
        }

        function clearImage() {
            originalImageData = null;
            isRealTimePreview = false;
            showOriginal = false;
            activeMethods = [];
            
            // 隐藏画布
            processedCanvas.style.display = 'none';
            tiledCanvas.style.display = 'none';
            
            // 显示占位消息
            document.getElementById('noImageMessage').style.display = 'block';
            document.getElementById('noTileMessage').style.display = 'block';
            
            // 隐藏控制面板
            document.getElementById('imageControls').style.display = 'none';
            document.getElementById('seamlessControls').style.display = 'none';
            document.getElementById('headerExport').style.display = 'none';
            document.getElementById('liveIndicator').style.display = 'none';
            
            // 重置文件输入
            document.getElementById('fileInput').value = '';
            
            // 清空尺寸显示
            document.getElementById('imageDimensions').textContent = '';
            
            // 重置切换按钮
            const btn = document.getElementById('toggleOriginalBtn');
            btn.classList.remove('active');
            btn.innerHTML = `
                <i class="fas fa-eye fa-icon"></i>
                显示原图
            `;
            
            // 重置调整值
            resetAdjustments();
            
            // 重置方法选择
            document.querySelectorAll('.method-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.querySelector('.order-indicator').style.display = 'none';
            });
            
            // 新增：确保所有方法控制面板被隐藏
            hideAllMethodControls();
        }
        
        // 箭头指示器相关函数
        function showArrowIndicator() {
            if (!originalImageData) return;
            
            // 清除之前的定时器
            if (arrowTimeout) {
                clearTimeout(arrowTimeout);
                arrowTimeout = null;
            }
            
            // 显示箭头画布
            arrowCanvas.style.display = 'block';
            
            // 绘制箭头
            drawArrow();
        }
        
        function hideArrowIndicator() {
            // 设置定时器，延迟隐藏箭头
            arrowTimeout = setTimeout(() => {
                arrowCanvas.style.display = 'none';
                arrowTimeout = null;
            }, 1000); // 1秒后隐藏
        }
        
function drawArrow() {
    const angle = parseInt(document.getElementById('gradientAngle').value);
    const { width, height } = arrowCanvas;
    
    // 清除画布
    arrowCtx.clearRect(0, 0, width, height);
    
    // 计算中心点 - 使用画布的中心而不是图像的中心
    const centerX = width / 2;
    const centerY = height / 2;
    
    // 计算箭头长度（画布对角线的一半）
    const arrowLength = Math.min(width, height) * 0.3;
    
    // 转换为弧度 - 注意：这里需要调整角度系统
    // 画布的坐标系是Y轴向下，而角度系统是Y轴向上
    // 所以需要将角度调整为从顶部开始，顺时针为正
    const rad = (angle + 90) * Math.PI / 180; // 减去90度使0°指向顶部
    
    // 计算箭头终点
    const endX = centerX + Math.cos(rad) * arrowLength;
    const endY = centerY + Math.sin(rad) * arrowLength;
    
    // 设置箭头样式
    arrowCtx.strokeStyle = '#fff';
    arrowCtx.lineWidth = 2;
    arrowCtx.lineCap = 'round';
    
    // 绘制箭头线
    arrowCtx.beginPath();
    arrowCtx.moveTo(centerX, centerY);
    arrowCtx.lineTo(endX, endY);
    arrowCtx.stroke();
    
    // 绘制箭头头部
    const headLength = 15;
    const angle1 = rad + Math.PI * 0.2; // 箭头角度1
    const angle2 = rad - Math.PI * 0.2; // 箭头角度2
    
    arrowCtx.beginPath();
    arrowCtx.moveTo(endX, endY);
    arrowCtx.lineTo(endX - Math.cos(angle1) * headLength, endY - Math.sin(angle1) * headLength);
    arrowCtx.moveTo(endX, endY);
    arrowCtx.lineTo(endX - Math.cos(angle2) * headLength, endY - Math.sin(angle2) * headLength);
    arrowCtx.stroke();
}
    </script>
</body>
</html>