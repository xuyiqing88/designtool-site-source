<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>在线无缝纹理制作工具 - 专业3D无缝贴图生成工具</title>
    
    <script src="https://cdn.jsdelivr.net/npm/utif@3.1.0/UTIF.min.js"></script>
    <script src="menu.js" defer></script>
    <link rel="icon" href="img/gongjuxiang.svg" type="image/svg">
    <script defer src="https://cloud.umami.is/script.js" data-website-id="5a2e10cd-bf73-47df-be48-079c9ba7783c" data-domains="designtool.site"></script>    
    
    <style>
        /* 全局样式重置 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', 'Microsoft YaHei', sans-serif;
            background: #0f172a;
            color: #e2e8f0;
            height: 100vh;
            overflow: hidden;
        }
        .icon {
    display: inline-block;
    width: 1.2em;
    height: 1.2em;
    fill: currentColor;
}
.tabicon {position: absolute;
    right: -5px;
    bottom: -10px;
    font-size: 28px;
	color: #a0a7b230;}
.vue {
	width: 10px;}
/* 标签页样式 */
.tabs-container {
    margin-bottom: 1rem;
    flex: 1;
}

.tabs-header {
    display: flex;
    border-bottom: 1px solid #334155;
}

.tab-btn {
    flex: 1;
    padding: 0.75rem 1rem;
    background: #141d2f;
    border: none;
    color: #94a3b8;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
	    border-bottom: 2px solid transparent;
	    font-size: 0.9rem;
}

.tab-btn:hover {
    background: #293950;
    color: #e2e8f0;
}

.tab-btn.active {
    background: #293950;
    color: #60a5fa;
	border-color: #60a5fa;
}

.tab-content {
    display: none;
    padding: 0;
}

.tab-content.active {
    display: block;
}
  /* 分隔条样式 */
  .divider {
    width: 8px;
    background: none;
    cursor: col-resize;
    position: relative;
    z-index: 10;
    transition: background-color 0.2s;
  }

  .divider:hover {
    
  }
.kuang {
    padding: 14px;
    border-radius: 6px;
	background: #141d2f;}
/* 添加在现有CSS中 */
#mirrorControls, #blendControls, #offsetControls, #gradientControls {
    display: none;
	margin-bottom: 8px;
}

        /* 头部样式 */
        .header {
            background: linear-gradient(135deg, #1e293b, #334155);
            padding: 0rem 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            position: relative;
	    margin-left: 60px;
        }
	.selectpng {
	}
	.toptitle {
	display: flex;  
	align-items: center; 
	gap: 10px;
	}
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
	height: 60px;
        }

        .header h1 {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 1.65rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .header p {
            color: #94a3b8;
            margin-top: 0.25rem;
        }

        /* 导出控制面板 - 移到右上角 */
        .header-export {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .export-select {
            padding: 0.5rem;
            background: #374151;
            color: white;
            border: 1px solid #4b5563;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        /* 主容器 */
        .container {
            display: flex;
            height: calc(100vh - 60px);
	margin-left: 60px;
        }

        /* 左侧控制面板 */
        .sidebar {
            width: 360px;
            background: #1c2637;
            overflow-y: auto;
	    display: flex;
    flex-direction: column;
        }

        /* 主预览区域 */
        .main-content {
            flex: 1;
            display: flex;
            padding: 1rem 1rem 0.5rem;
    display: flex;
    height: calc(100vh - 60px);
        }

        .preview-panel {
            background: linear-gradient(135deg, #1e293b, #334155);
            border-radius: 6px;
            border: 1px solid #475569;
            overflow: hidden;
            display: flex;
            flex-direction: column;
	    flex: 1 1 50%; 
		/*height: calc(100vh - 160px);*/
        }

        .preview-header {
            background: linear-gradient(135deg, #374151, #4b5563);
            padding: 0.75rem 1rem;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
	height: 3rem;
        }

        .preview-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            background: 
                linear-gradient(45deg, #374151 25%, transparent 25%), 
                linear-gradient(-45deg, #374151 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #374151 75%), 
                linear-gradient(-45deg, transparent 75%, #374151 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            cursor: pointer;
	overflow: hidden;
            position: relative; /* 为箭头画布提供定位上下文 */
        }

        canvas {
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
    object-fit: contain;
    border-radius: 4px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        }

        /* 文件上传区域 */
        .upload-area {
            border: 2px dashed #475569;
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #0f172a, #1e293b);
            transition: all 0.3s ease;
            cursor: pointer;
	    margin: 14px;
        }

        .upload-area:hover {
            border-color: #3b82f6;
            background: linear-gradient(135deg, #1e293b, #334155);
        }

        .upload-area.dragover {
            border-color: #3b82f6;
            background: linear-gradient(135deg, #1e3a8a, #3730a3);
        }

        .upload-icon {
            margin-bottom: 0.5rem;
            color: #5a73f5;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            display: flex;
            justify-content: center;
        }

        /* 控制组 */
        .control-group, .control-group1 {
            margin-bottom: 0;
            padding: 14px;
            background: none;
            border-radius: 0;
            border: none;
        }

        .control-group h3, .control-group1 h3 {
            color: #f59e0b;
            margin-bottom: 1rem;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .control-item {
            margin-bottom: 0.5rem;
        }

        .control-item label {
            display: block;
            margin-bottom: 0.5rem;
            color: #cbd5e1;
            font-weight: 500;
        }

        .control-item input[type="range"] {
            width: 100%;
            height: 6px;
            background: #374151;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .control-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(59, 130, 246, 0.4);
        }

        .control-item input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* 按钮样式 */
        .btn {
            padding: 0.65rem 1.5rem;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.1s ease;
            margin: 0.25rem;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #2563eb, #1e40af);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .btn-secondary {
            background: none;
    	color: #94a3b8;
    	border: 1px solid #94a3b8;
	    padding: 0.5rem 0.8rem;
	display: flex;
    justify-content: center;
	margin: auto;
        }

        .btn-secondary:hover {
            border-color: #fff;
	background: #404958;
	color: #fff;
        }

        .btn-success {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }

        .btn-success:hover {
            background: linear-gradient(135deg, #0d9668, #047857);
        }

        .btn-orange {
            background: linear-gradient(113deg, #4c73ff, #6a52ff);
            color: white;
        }

        .btn-orange:hover {
            opacity: 0.92;
    box-shadow: 0 7px 18px rgba(89, 99, 255, 0.35);
	scale: 1.05;
        }

        /* 无缝化方法选择 */
        .method-selector {
            display: grid;
            gap: 0.5rem;
            margin-bottom: 1rem;
	grid-template-columns: 1fr 1fr;
        }

        .method-btn {
            padding: 0.5rem;
            background: #374151;
            border: 1px solid #4b5563;
            border-radius: 6px;
            color: #e2e8f0;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            position: relative;
	    overflow: hidden;
        }

        .method-btn:hover {
            border-color: #6b7280;
            background: #4b5563;
        }

        .method-btn.active {
            border-color: #10b981;
            background: linear-gradient(135deg, #065f46, #047857);
            color: white;
        }

        .method-btn strong {
            display: block;
            margin-bottom: 0.25rem;
            padding-right: 20px;
        }

        .method-btn small {
            opacity: 0.8;
            font-size: 0.8rem;
            display: block;
        }

        .method-btn .order-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.3);
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
	display: none;
        }

        /* 切换按钮样式 */
        .toggle-btn {
            padding: 0.5rem;
            border-radius: 6px;
            font-size: 0.85rem;
            background: none;
            border: none;
            color: #e2e8f0;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .toggle-btn:hover {
            background: #334155;
            border-color: #64748b;
        }

        /* 数字输入框样式 */
        .number-input {
            width: 60px;
            padding: 0.25rem;
            background: #374151;
            border: 1px solid #4b5563;
            border-radius: 4px;
            color: white;
            text-align: center;
            margin-left: 8px;
        }

        .number-input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 5px;
        }

        .slider-container input[type="range"] {
            flex: 1;
        }

        /* 滚动条样式 */
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: #1e293b;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 3px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        /* 隐藏文件输入 */
        #fileInput {
            display: none;
        }

        /* 加载状态 */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* 实时预览标识 */
        .live-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.8rem;
            color: #10b981;
            margin-bottom: 1rem;
        }

        .live-dot {
            width: 6px;
            height: 6px;
            background: #10b981;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* 模态框 - 放大查看 */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            cursor: zoom-out;
            border-radius: 8px;
        }

        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            background: rgba(0,0,0,0.5);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            body {
                overflow-y: auto;
                height: auto;
            }
.tabs-container {margin-bottom: 18rem;}
	.selectpng {
	display: none;}
	.toptitle {
		flex-direction: column;
	        gap: 0;}
	.control-group1 {
		margin-bottom: 0;}
            .header {
		margin-left: 0;
	        padding: 0.5rem;
		}
            .container {
                flex-direction: column;
                height: auto;
                overflow-y: visible;
		margin-left: 0;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                border-right: none;
                border-bottom: 2px solid #475569;
            }
            
            .main-content {
                flex-direction: column;
                height: auto;
            }
            
            .header-content {
                flex-direction: column;
                gap: 1rem;
                text-align: center;
	        height: auto;
            }
            
            .header-export {
                width: 100%;
                justify-content: center;
                flex-wrap: wrap;
            }
            
            .preview-panel {
                max-height: 40vh;
	        position: fixed;
        bottom: 0;
        width: 100%;
        left: 0;
            }
            .preview-content {
		height: 80%;}
            .preview-header {
                flex-direction: column;
                gap: 0.5rem;
		display: none;
            }
            
            #toggleOriginalBtn {
                margin-top: 0.5rem;
            }
        }
        
        /* 旋转控制样式 */
        .rotation-control {
            position: relative;
            margin-bottom: 0.5rem;
        }
        
        /* 图标样式 */
        .icon {
            width: 1.2rem;
            height: 1.2rem;
        }
        
        .icon-large {
	font-size: 2.5rem;
        }
        
        .icon-xl {
            width: 4rem;
            height: 4rem;
	font-size: 4rem;
        }
        
        .fa-icon {
        }
        
        /* 箭头画布样式 */
        #arrowCanvas {
            position: absolute;
            top: 0;
            left: 0;
            display: none;
            pointer-events: none;
        }
    </style>
</head>
<body>
<svg width="0" height="0" class="hidden">
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="arrow-down-up-across-line-solid-full">
    <path d="M329.4 169.4L425.4 73.4C437.9 60.9 458.2 60.9 470.7 73.4L566.7 169.4C579.2 181.9 579.2 202.2 566.7 214.7C554.2 227.2 533.9 227.2 521.4 214.7L480 173.3L480 288L544 288C561.7 288 576 302.3 576 320C576 337.7 561.7 352 544 352L224 352L224 466.7L265.4 425.3C277.9 412.8 298.2 412.8 310.7 425.3C323.2 437.8 323.2 458.1 310.7 470.6L214.7 566.6C202.2 579.1 181.9 579.1 169.4 566.6L73.4 470.6C60.9 458.1 60.9 437.8 73.4 425.3C85.9 412.8 106.2 412.8 118.7 425.3L160 466.7L160 352L96 352C78.3 352 64 337.7 64 320C64 302.3 78.3 288 96 288L416 288L416 173.3L374.6 214.7C362.1 227.2 341.8 227.2 329.3 214.7C316.8 202.2 316.8 181.9 329.3 169.4zM480 400L480 544C480 561.7 465.7 576 448 576C430.3 576 416 561.7 416 544L416 400L480 400zM160 240L160 96C160 78.3 174.3 64 192 64C209.7 64 224 78.3 224 96L224 240L160 240z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="circle-exclamation-solid-full">
    <path d="M320 576C178.6 576 64 461.4 64 320C64 178.6 178.6 64 320 64C461.4 64 576 178.6 576 320C576 461.4 461.4 576 320 576zM320 384C302.3 384 288 398.3 288 416C288 433.7 302.3 448 320 448C337.7 448 352 433.7 352 416C352 398.3 337.7 384 320 384zM320 192C301.8 192 287.3 207.5 288.6 225.7L296 329.7C296.9 342.3 307.4 352 319.9 352C332.5 352 342.9 342.3 343.8 329.7L351.2 225.7C352.5 207.5 338.1 192 319.8 192z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="circle-half-stroke-solid-full">
    <path d="M512 320C512 214 426 128 320 128L320 512C426 512 512 426 512 320zM64 320C64 178.6 178.6 64 320 64C461.4 64 576 178.6 576 320C576 461.4 461.4 576 320 576C178.6 576 64 461.4 64 320z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="cloud-arrow-up-solid-full">
    <path d="M176 544C96.5 544 32 479.5 32 400C32 336.6 73 282.8 129.9 263.5C128.6 255.8 128 248 128 240C128 160.5 192.5 96 272 96C327.4 96 375.5 127.3 399.6 173.1C413.8 164.8 430.4 160 448 160C501 160 544 203 544 256C544 271.7 540.2 286.6 533.5 299.7C577.5 320 608 364.4 608 416C608 486.7 550.7 544 480 544L176 544zM337 255C327.6 245.6 312.4 245.6 303.1 255L231.1 327C221.7 336.4 221.7 351.6 231.1 360.9C240.5 370.2 255.7 370.3 265 360.9L296 329.9L296 432C296 445.3 306.7 456 320 456C333.3 456 344 445.3 344 432L344 329.9L375 360.9C384.4 370.3 399.6 370.3 408.9 360.9C418.2 351.5 418.3 336.3 408.9 327L336.9 255z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="cube-solid-full">
    <path d="M288.3 61.5C308.1 50.1 332.5 50.1 352.3 61.5L528.2 163C548 174.4 560.2 195.6 560.2 218.4L560.2 421.4C560.2 444.3 548 465.4 528.2 476.8L352.3 578.5C332.5 589.9 308.1 589.9 288.3 578.5L112.5 477C92.7 465.6 80.5 444.4 80.5 421.6L80.5 218.6C80.5 195.7 92.7 174.6 112.5 163.2L288.3 61.5zM496.1 421.5L496.1 255.4L352.3 338.4L352.3 504.5L496.1 421.5z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="download-solid-full">
    <path d="M352 96C352 78.3 337.7 64 320 64C302.3 64 288 78.3 288 96L288 306.7L246.6 265.3C234.1 252.8 213.8 252.8 201.3 265.3C188.8 277.8 188.8 298.1 201.3 310.6L297.3 406.6C309.8 419.1 330.1 419.1 342.6 406.6L438.6 310.6C451.1 298.1 451.1 277.8 438.6 265.3C426.1 252.8 405.8 252.8 393.3 265.3L352 306.7L352 96zM160 384C124.7 384 96 412.7 96 448L96 480C96 515.3 124.7 544 160 544L480 544C515.3 544 544 515.3 544 480L544 448C544 412.7 515.3 384 480 384L433.1 384L376.5 440.6C345.3 471.8 294.6 471.8 263.4 440.6L206.9 384L160 384zM464 440C477.3 440 488 450.7 488 464C488 477.3 477.3 488 464 488C450.7 488 440 477.3 440 464C440 450.7 450.7 440 464 440z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="eye-slash-solid-full">
    <path d="M73 39.1C63.6 29.7 48.4 29.7 39.1 39.1C29.8 48.5 29.7 63.7 39 73.1L567 601.1C576.4 610.5 591.6 610.5 600.9 601.1C610.2 591.7 610.3 576.5 600.9 567.2L504.5 470.8C507.2 468.4 509.9 466 512.5 463.6C559.3 420.1 590.6 368.2 605.5 332.5C608.8 324.6 608.8 315.8 605.5 307.9C590.6 272.2 559.3 220.2 512.5 176.8C465.4 133.1 400.7 96.2 319.9 96.2C263.1 96.2 214.3 114.4 173.9 140.4L73 39.1zM236.5 202.7C260 185.9 288.9 176 320 176C399.5 176 464 240.5 464 320C464 351.1 454.1 379.9 437.3 403.5L402.6 368.8C415.3 347.4 419.6 321.1 412.7 295.1C399 243.9 346.3 213.5 295.1 227.2C286.5 229.5 278.4 232.9 271.1 237.2L236.4 202.5zM357.3 459.1C345.4 462.3 332.9 464 320 464C240.5 464 176 399.5 176 320C176 307.1 177.7 294.6 180.9 282.7L101.4 203.2C68.8 240 46.4 279 34.5 307.7C31.2 315.6 31.2 324.4 34.5 332.3C49.4 368 80.7 420 127.5 463.4C174.6 507.1 239.3 544 320.1 544C357.4 544 391.3 536.1 421.6 523.4L357.4 459.2z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="eye-solid-full">
    <path d="M320 96C239.2 96 174.5 132.8 127.4 176.6C80.6 220.1 49.3 272 34.4 307.7C31.1 315.6 31.1 324.4 34.4 332.3C49.3 368 80.6 420 127.4 463.4C174.5 507.1 239.2 544 320 544C400.8 544 465.5 507.2 512.6 463.4C559.4 419.9 590.7 368 605.6 332.3C608.9 324.4 608.9 315.6 605.6 307.7C590.7 272 559.4 220 512.6 176.6C465.5 132.9 400.8 96 320 96zM176 320C176 240.5 240.5 176 320 176C399.5 176 464 240.5 464 320C464 399.5 399.5 464 320 464C240.5 464 176 399.5 176 320zM320 256C320 291.3 291.3 320 256 320C244.5 320 233.7 317 224.3 311.6C223.3 322.5 224.2 333.7 227.2 344.8C240.9 396 293.6 426.4 344.8 412.7C396 399 426.4 346.3 412.7 295.1C400.5 249.4 357.2 220.3 311.6 224.3C316.9 233.6 320 244.4 320 256z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="image-solid-full">
    <path d="M160 96C124.7 96 96 124.7 96 160L96 480C96 515.3 124.7 544 160 544L480 544C515.3 544 544 515.3 544 480L544 160C544 124.7 515.3 96 480 96L160 96zM224 176C250.5 176 272 197.5 272 224C272 250.5 250.5 272 224 272C197.5 272 176 250.5 176 224C176 197.5 197.5 176 224 176zM368 288C376.4 288 384.1 292.4 388.5 299.5L476.5 443.5C481 450.9 481.2 460.2 477 467.8C472.8 475.4 464.7 480 456 480L184 480C175.1 480 166.8 475 162.7 467.1C158.6 459.2 159.2 449.6 164.3 442.3L220.3 362.3C224.8 355.9 232.1 352.1 240 352.1C247.9 352.1 255.2 355.9 259.7 362.3L286.1 400.1L347.5 299.6C351.9 292.5 359.6 288.1 368 288.1z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="layer-group-solid-full">
    <path d="M296.5 69.2C311.4 62.3 328.6 62.3 343.5 69.2L562.1 170.2C570.6 174.1 576 182.6 576 192C576 201.4 570.6 209.9 562.1 213.8L343.5 314.8C328.6 321.7 311.4 321.7 296.5 314.8L77.9 213.8C69.4 209.8 64 201.3 64 192C64 182.7 69.4 174.1 77.9 170.2L296.5 69.2zM112.1 282.4L276.4 358.3C304.1 371.1 336 371.1 363.7 358.3L528 282.4L562.1 298.2C570.6 302.1 576 310.6 576 320C576 329.4 570.6 337.9 562.1 341.8L343.5 442.8C328.6 449.7 311.4 449.7 296.5 442.8L77.9 341.8C69.4 337.8 64 329.3 64 320C64 310.7 69.4 302.1 77.9 298.2L112 282.4zM77.9 426.2L112 410.4L276.3 486.3C304 499.1 335.9 499.1 363.6 486.3L527.9 410.4L562 426.2C570.5 430.1 575.9 438.6 575.9 448C575.9 457.4 570.5 465.9 562 469.8L343.4 570.8C328.5 577.7 311.3 577.7 296.4 570.8L77.9 469.8C69.4 465.8 64 457.3 64 448C64 438.7 69.4 430.1 77.9 426.2z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="recycle-solid-full">
    <path d="M216.3 124C262.5 44 378 44 424.2 124L461.5 188.6L489.2 172.6C497.6 167.7 508.1 168.4 515.8 174.3C523.5 180.2 526.9 190.2 524.4 199.6L500.9 287C497.5 299.8 484.3 307.4 471.5 304L384.1 280.6C374.7 278.1 367.8 270.2 366.5 260.6C365.2 251 369.9 241.5 378.3 236.7L406 220.7L368.7 156.1C347.1 118.8 293.3 118.8 271.7 156.1L266.4 165.2C257.6 180.5 238 185.7 222.7 176.9C207.4 168.1 202.2 148.5 211 133.1L216.3 124zM513.7 343.1C529 334.3 548.6 339.5 557.4 354.8L562.7 363.9C608.9 443.9 551.2 543.9 458.8 543.9L384.2 543.9L384.2 575.9C384.2 585.6 378.4 594.4 369.4 598.1C360.4 601.8 350.1 599.8 343.2 592.9L279.2 528.9C269.8 519.5 269.8 504.3 279.2 495L343.2 431C350.1 424.1 360.4 422.1 369.4 425.8C378.4 429.5 384.2 438.3 384.2 448L384.2 480L458.8 480C501.9 480 528.9 433.3 507.3 396L502 386.9C493.2 371.6 498.4 352 513.7 343.2zM115 299.4L87.3 283.4C78.9 278.5 74.2 269.1 75.5 259.5C76.8 249.9 83.7 242 93.1 239.5L180.5 216C193.3 212.6 206.5 220.2 209.9 233L233.3 320.4C235.8 329.8 232.4 339.7 224.7 345.7C217 351.7 206.5 352.3 198.1 347.4L170.4 331.4L133.1 396C111.5 433.3 138.5 480 181.6 480L192.2 480C209.9 480 224.2 494.3 224.2 512C224.2 529.7 209.9 544 192.2 544L181.6 544C89.3 544 31.6 444 77.8 364L115 299.4z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="rotate-right-solid-full">
    <path d="M552 256L408 256C398.3 256 389.5 250.2 385.8 241.2C382.1 232.2 384.1 221.9 391 215L437.7 168.3C362.4 109.7 253.4 115 184.2 184.2C109.2 259.2 109.2 380.7 184.2 455.7C259.2 530.7 380.7 530.7 455.7 455.7C463.9 447.5 471.2 438.8 477.6 429.6C487.7 415.1 507.7 411.6 522.2 421.7C536.7 431.8 540.2 451.8 530.1 466.3C521.6 478.5 511.9 490.1 501 501C401 601 238.9 601 139 501C39.1 401 39 239 139 139C233.3 44.7 382.7 39.4 483.3 122.8L535 71C541.9 64.1 552.2 62.1 561.2 65.8C570.2 69.5 576 78.3 576 88L576 232C576 245.3 565.3 256 552 256z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="signs-post-solid-full">
    <path d="M320.4 64C302.7 64 288.4 78.3 288.4 96L288.4 128L128.4 128C110.7 128 96.4 142.3 96.4 160L96.4 224C96.4 241.7 110.7 256 128.4 256L288.4 256L288.4 320L135 320C130.8 320 126.7 321.7 123.7 324.7L75.7 372.7C69.5 378.9 69.5 389.1 75.7 395.3L123.7 443.3C126.7 446.3 130.8 448 135 448L288.4 448L288.4 544C288.4 561.7 302.7 576 320.4 576C338.1 576 352.4 561.7 352.4 544L352.4 448L512.4 448C530.1 448 544.4 433.7 544.4 416L544.4 352C544.4 334.3 530.1 320 512.4 320L352.4 320L352.4 256L505.8 256C510 256 514.1 254.3 517.1 251.3L565.1 203.3C571.3 197.1 571.3 186.9 565.1 180.7L517.1 132.7C514.1 129.7 510 128 505.8 128L352.4 128L352.4 96C352.4 78.3 338.1 64 320.4 64z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="sliders-solid-full">
    <path d="M96 128C78.3 128 64 142.3 64 160C64 177.7 78.3 192 96 192L182.7 192C195 220.3 223.2 240 256 240C288.8 240 317 220.3 329.3 192L544 192C561.7 192 576 177.7 576 160C576 142.3 561.7 128 544 128L329.3 128C317 99.7 288.8 80 256 80C223.2 80 195 99.7 182.7 128L96 128zM96 288C78.3 288 64 302.3 64 320C64 337.7 78.3 352 96 352L342.7 352C355 380.3 383.2 400 416 400C448.8 400 477 380.3 489.3 352L544 352C561.7 352 576 337.7 576 320C576 302.3 561.7 288 544 288L489.3 288C477 259.7 448.8 240 416 240C383.2 240 355 259.7 342.7 288L96 288zM96 448C78.3 448 64 462.3 64 480C64 497.7 78.3 512 96 512L150.7 512C163 540.3 191.2 560 224 560C256.8 560 285 540.3 297.3 512L544 512C561.7 512 576 497.7 576 480C576 462.3 561.7 448 544 448L297.3 448C285 419.7 256.8 400 224 400C191.2 400 163 419.7 150.7 448L96 448z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="star-solid-full">
    <path d="M341.5 45.1C337.4 37.1 329.1 32 320.1 32C311.1 32 302.8 37.1 298.7 45.1L225.1 189.3L65.2 214.7C56.3 216.1 48.9 222.4 46.1 231C43.3 239.6 45.6 249 51.9 255.4L166.3 369.9L141.1 529.8C139.7 538.7 143.4 547.7 150.7 553C158 558.3 167.6 559.1 175.7 555L320.1 481.6L464.4 555C472.4 559.1 482.1 558.3 489.4 553C496.7 547.7 500.4 538.8 499 529.8L473.7 369.9L588.1 255.4C594.5 249 596.7 239.6 593.9 231C591.1 222.4 583.8 216.1 574.8 214.7L415 189.3L341.5 45.1z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="table-cells-large-solid-full">
    <path d="M480 160L352 160L352 288L480 288L480 160zM544 288L544 480C544 515.3 515.3 544 480 544L160 544C124.7 544 96 515.3 96 480L96 160C96 124.7 124.7 96 160 96L480 96C515.3 96 544 124.7 544 160L544 288zM160 352L160 480L288 480L288 352L160 352zM288 288L288 160L160 160L160 288L288 288zM352 352L352 480L480 480L480 352L352 352z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" id="trash-solid-full">
    <path d="M232.7 69.9L224 96L128 96C110.3 96 96 110.3 96 128C96 145.7 110.3 160 128 160L512 160C529.7 160 544 145.7 544 128C544 110.3 529.7 96 512 96L416 96L407.3 69.9C402.9 56.8 390.7 48 376.9 48L263.1 48C249.3 48 237.1 56.8 232.7 69.9zM512 208L128 208L149.1 531.1C150.7 556.4 171.7 576 197 576L443 576C468.3 576 489.3 556.4 490.9 531.1L512 208z"></path>
  </symbol>
</svg>
    <div class="header">
        <div class="header-content">
            <div class="toptitle">
                <h1>
                    3D无缝纹理制作工具
                </h1>
                <p>专业的无缝贴图制作与编辑工具</p>
            </div>
            
            <div class="header-export" id="headerExport" style="display: none;">
                <span class="selectpng">选择格式</span>
		<select id="exportFormat" class="export-select">
                    <option value="image/png">PNG</option>
                    <option value="image/jpeg">JPEG</option>
                    <option value="image/webp">WebP</option>
                    <option value="image/tiff">TIFF</option>
                </select>
                <div style="display: flex; gap: 10px;"><button class="btn btn-orange" onclick="exportImage()">
                    <svg class="icon"><use xlink:href="#download-solid-full"></use></svg>
                    下载纹理
                </button>
                <button class="btn btn-secondary" onclick="clearImage()">
                    <svg class="icon"><use xlink:href="#trash-solid-full"></use></svg>
                    清空
                </button>
	</div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="sidebar">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon icon-large">
                    <svg class="icon"><use xlink:href="#cloud-arrow-up-solid-full"></use></svg>
                </div>
                <h3>拖拽或点击图像上传</h3>
                <small>支持 PNG, JPG, BMP, WebP, TIFF</small>
            </div>
            <input type="file" id="fileInput" accept="image/*,.tiff,.tif">

<div class="tabs-container">
    <div class="tabs-header">
        <button class="tab-btn active" data-tab="seamless">
            <svg class="icon"><use xlink:href="#layer-group-solid-full"></use></svg>
            无缝化处理
        </button>
        <button class="tab-btn" data-tab="adjustment">
            <svg class="icon"><use xlink:href="#sliders-solid-full"></use></svg>
            图像调整
        </button>
    </div>

    <div class="tab-content active" id="seamlessTab">
        <div class="control-group" id="seamlessControls">
        <span class="live-indicator" id="liveIndicator" style="display: none;">
            <span class="live-dot"></span>
            实时预览
        </span>
        <button class="btn btn-secondary" style="width: 100%; margin-bottom: 16px;" onclick="resetSeamlessParameters()" >
            <svg class="icon"><use xlink:href="#rotate-right-solid-full"></use></svg>
            重置参数
        </button>
                
                <div class="method-selector">
                    <div class="method-btn" data-method="mirror">
			<div class="tabicon"><svg class="icon"><use xlink:href="#signs-post-solid-full"></use></svg></div>
                        <strong>镜像边缘</strong>
                        <small>镜像边缘像素</small>
                        <span class="order-indicator">1</span>
                    </div>

<div class="method-btn" data-method="gradient">
<div class="tabicon"><svg class="icon"><use xlink:href="#circle-half-stroke-solid-full"></use></svg></div>
    <strong>光影矫正</strong>
    <small>渐变调整图像亮度</small>
    <span class="order-indicator">2</span>
</div>

                    <div class="method-btn" data-method="blend">
			<div class="tabicon"><svg class="icon"><use xlink:href="#recycle-solid-full"></use></svg></div>
                        <strong>边缘混合</strong>
                        <small>混合相对边缘</small>
                        <span class="order-indicator">2</span>
                    </div>
                    <div class="method-btn" data-method="offset">
			<div class="tabicon"><svg class="icon"><use xlink:href="#arrow-down-up-across-line-solid-full"></use></svg></div>
                        <strong>偏移映射</strong>
                        <small>重新排列图像象限</small>
                        <span class="order-indicator">3</span>
                    </div>
                </div>
                
                <div style="margin-bottom:1rem; font-size:0.9rem; color:#94a3b8;">
                    <small>提示：可同时选择多个方法，按顺序应用</small>
                </div>
                
<div id="mirrorControls" class="kuang">
    <div class="control-item">
        <label>镜像强度</label>
        <div class="slider-container">
            <input type="range" id="mirrorStrength" min="0" max="50" value="20">
            <input type="number" id="mirrorStrengthInput" class="number-input" min="0" max="50" value="20"><span class="vue">%</span>
        </div>
    </div>
    <!-- 添加渐变控制 -->
                    <div class="control-item">
                        <label>边缘亮度调整</label>
                        <div class="slider-container">
                            <input type="range" id="gradientStrength" min="-100" max="100" value="0">
                            <input type="number" id="gradientStrengthInput" class="number-input" min="-100" max="100" value="0"><span class="vue">%</span>
                        </div>
                    </div>
</div>

<!-- 在mirrorControls之后，blendControls之前添加 -->
<div id="gradientControls" style="display: none;" class="kuang">
    <div class="control-item">
        <label>渐变角度</label>
        <div class="slider-container">
            <input type="range" id="gradientAngle" min="0" max="360" value="180">
            <input type="number" id="gradientAngleInput" class="number-input" min="0" max="360" value="180"><span class="vue">°</span>
        </div>
    </div>
    <div class="control-item">
        <label>渐变延伸</label>
        <div class="slider-container">
            <input type="range" id="gradientExtend" min="0" max="100" value="50">
            <input type="number" id="gradientExtendInput" class="number-input" min="0, max="100" value="50"><span class="vue">%</span>
        </div>
    </div>
    <div class="control-item">
        <label>渐变亮度</label>
        <div class="slider-container">
            <input type="range" id="gradientBrightness" min="-100" max="100" value="50">
            <input type="number" id="gradientBrightnessInput" class="number-input" min="-100" max="100" value="50"><span class="vue">%</span>
        </div>
    </div>
</div>
                
                <div id="blendControls"  class="kuang">
                    <div class="control-item">
                        <label>混合强度</label>
                        <div class="slider-container">
                            <input type="range" id="blendStrength" min="0" max="50" value="20">
                            <input type="number" id="blendStrengthInput" class="number-input" min="0" max="50" value="20"><span class="vue">%</span>
                        </div>
                    </div>
                </div>
                
                <div id="offsetControls"  class="kuang">
                    <div class="control-item">
                        <label>水平偏移</label>
                        <div class="slider-container">
                            <input type="range" id="offsetX" min="0" max="100" value="50">
                            <input type="number" id="offsetXInput" class="number-input" min="0" max="100" value="50"><span class="vue">%</span>
                        </div>
                    </div>
                    <div class="control-item">
                        <label>垂直偏移</label>
                        <div class="slider-container">
                            <input type="range" id="offsetY" min="0" max="100" value="50">
                            <input type="number" id="offsetYInput" class="number-input" min="0" max="100" value="50"><span class="vue">%</span>
                        </div>
                    </div>
                </div>
            </div>
       </div>


    <div class="tab-content" id="adjustmentTab">
        <div class="control-group1" id="imageControls">

    <!-- 将重置按钮移到标题右侧 -->
    <button class="btn btn-secondary" style="width: 100%; margin-bottom: 16px;" onclick="resetAdjustments()" >
        <svg class="icon"><use xlink:href="#rotate-right-solid-full"></use></svg>
        重置调整
    </button>

                <div class="control-item rotation-control">
                    <label>旋转</label>
                    <div class="slider-container">
                        <input type="range" id="rotation" min="0" max="360" value="0">
                        <input type="number" id="rotationInput" class="number-input" min="0" max="360" value="0"><span class="vue">°</span>
                    </div>
                </div>
                
                <div class="control-item">
                    <label>亮度</label>
                    <div class="slider-container">
                        <input type="range" id="brightness" min="0" max="200" value="100">
                        <input type="number" id='brightnessInput' class="number-input" min="0" max="200" value="100"><span class="vue">%</span>
                    </div>
                </div>
                
                <div class="control-item">
                    <label>对比度</label>
                    <div class="slider-container">
                        <input type="range" id="contrast" min="0" max="200" value="100">
                        <input type="number" id="contrastInput" class="number-input" min="0" max="200" value="100"><span class="vue">%</span>
                    </div>
                </div>
                
                <div class="control-item">
                    <label>饱和度</label>
                    <div class="slider-container">
                        <input type="range" id="saturation" min="0" max="200" value="100">
                        <input type="number" id="saturationInput" class="number-input" min="0" max="200" value="100"><span class="vue">%</span>
                    </div>
                </div>
                
                <div class="control-item">
                    <label>色调</label>
                    <div class="slider-container">
                        <input type="range" id="hue" min="-180" max="180" value="0">
                        <input type="number" id="hueInput" class="number-input" min="-180" max="180" value="0"><span class="vue">%</span>
                    </div>
                </div>

            </div>

        </div>
        </div>
    </div>
<div style="display: flex; flex-direction: column; flex: 1; min-width: 0;">
        <div class="main-content">
            <div class="preview-panel" id="leftPanel">
                <div class="preview-header">
                    <span>
                        <svg class="icon"><use xlink:href="#image-solid-full"></use></svg>
                        图像预览
                    </span>
                    <div style="display: flex; align-items: center;">
                        <span id="imageDimensions" style="margin-right: 10px;"></span>
                        <button class="toggle-btn" id="toggleOriginalBtn" onclick="toggleOriginalPreview()">
                            <svg class="icon"><use xlink:href="#eye-solid-full"></use></svg>
                            显示原图
                        </button>
                    </div>
                </div>
                <div class="preview-content" onclick="zoomImage()">
                    <canvas id="processedCanvas" style="display: none;"></canvas>
                    <canvas id="arrowCanvas"></canvas>
                    <div id="noImageMessage">
                        <div style="text-align: center; opacity: 0.6;">
                            <svg class="icon icon-xl" style="margin-bottom: 1rem;"><use xlink:href="#star-solid-full"></use></svg>
                            <h3>欢迎使用无缝纹理工具</h3>
                            <p>请上传图像开始制作</p>
                        </div>
                    </div>
                </div>
            </div>
<div class="divider" id="divider"></div>
            <div class="preview-panel" id="rightPanel">
<div class="preview-header">
    <span>
        <svg class="icon"><use xlink:href="#table-cells-solid-full"></use></svg>
        平铺预览
    </span>
    <div style="display: flex; align-items: center; gap: 10px;">
        <span>3×3 网格</span>
        <!-- 添加这个切换按钮 -->
        <button class="toggle-btn" id="toggleTiledBtn" onclick="toggleTiledPreview()">
            <svg class="icon"><use xlink:href="#eye-solid-full"></use></svg>
            显示原图
        </button>
    </div>
</div>
                <div class="preview-content" onclick="zoomTiledImage()">
                    <canvas id="tiledCanvas" style="display: none;"></canvas>
                    <div id="noTileMessage">
                        <div style="text-align: center; opacity: 0.6;">
                            <svg class="icon icon-xl" style="margin-bottom: 1rem;"><use xlink:href="#table-cells-large-solid-full"></use></svg>
                            <h3>平铺预览</h3>
                            <p>上传图像后查看无缝效果</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
<div style="display: none;">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3983418855272291"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="fluid"
     data-ad-layout-key="-hq-10+1x-12+2m"
     data-ad-client="ca-pub-3983418855272291"
     data-ad-slot="4487878994"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
</div>




    <div class="modal" id="imageModal">
        <div class="modal-close" onclick="closeModal()">×</div>
        <img id="modalImage" class="modal-content" src="" alt="放大图像">
    </div>

    <script>
        // 全局变量
        let showTiledOriginal = false;
        let originalImageData = null;
        let processedCanvas = document.getElementById('processedCanvas');
        // 修复Canvas2D性能警告：设置willReadFrequently属性
        let processedCtx = processedCanvas.getContext('2d', { willReadFrequently: true });
        let tiledCanvas = document.getElementById('tiledCanvas');
        let tiledCtx = tiledCanvas.getContext('2d', { willReadFrequently: true });
        let activeMethods = []; // 存储选中的无缝处理方法
        let isRealTimePreview = false;
        let showOriginal = false; // 是否显示原图模式
        let adjustCanvas = document.createElement('canvas'); // 用于保存调整后的图像
        let adjustCtx = adjustCanvas.getContext('2d', { willReadFrequently: true });
        let rotatedCanvas = document.createElement('canvas'); // 用于旋转后的图像
        let rotatedCtx = rotatedCanvas.getContext('2d', { willReadFrequently: true });
        
        // 箭头画布相关变量
        let arrowCanvas = document.getElementById('arrowCanvas');
        let arrowCtx = arrowCanvas.getContext('2d');
        let arrowTimeout = null; // 用于隐藏箭头的定时器

        // 初始化
        document.addEventListener('DOMContentLoaded', function() {
            initializeEventListeners();
            initializeSliders();
            initializeNumberInputs(); // 初始化数字输入框
            // 确保所有方法控制面板初始状态为隐藏
            hideAllMethodControls();
        });
        
        // 新增函数：隐藏所有方法控制面板
        function hideAllMethodControls() {
            document.getElementById('mirrorControls').style.display = 'none';
            document.getElementById('gradientControls').style.display = 'none';
            document.getElementById('blendControls').style.display = 'none';
            document.getElementById('offsetControls').style.display = 'none';
        }
        
        function initializeEventListeners() {
            // 文件上传
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');

            uploadArea.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect);

            // 拖拽上传
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    loadImage(files[0]);
                }
            });

    window.addEventListener('resize', function() {
    if (originalImageData) {
        const previewContent = document.querySelector('.preview-content');
        arrowCanvas.width = previewContent.clientWidth;
        arrowCanvas.height = previewContent.clientHeight;
        
        // 如果当前正在显示箭头，重新绘制
        if (arrowCanvas.style.display === 'block') {
            drawArrow();
        }
    }
});
            // 添加标签切换功能
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const tab = this.dataset.tab;
                    
                    // 更新按钮状态
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    
                    // 更新内容显示
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                    document.getElementById(tab + 'Tab').classList.add('active');
                });
            });
            
            // 分隔条拖动功能
            const divider = document.getElementById('divider');
            const leftPanel = document.getElementById('leftPanel');
            const rightPanel = document.getElementById('rightPanel');
            const container = document.querySelector('.main-content');
            
            let isResizing = false;
            
            divider.addEventListener('mousedown', function(e) {
                isResizing = true;
                document.body.style.cursor = 'col-resize';
                // 阻止拖动时选中文本
                leftPanel.style.userSelect = 'none';
                leftPanel.style.pointerEvents = 'none';
                rightPanel.style.userSelect = 'none';
                rightPanel.style.pointerEvents = 'none';
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isResizing) return;
                
                const containerRect = container.getBoundingClientRect();
                if (containerRect.width === 0) return; // 避免除以零错误
                
                const percentage = (e.clientX - containerRect.left) / containerRect.width * 100;
                
                // 设置最小宽度限制为10%
                const leftPercentage = Math.max(25, Math.min(75, percentage));
                
                leftPanel.style.flex = `1 1 ${leftPercentage}%`;
                rightPanel.style.flex = `1 1 ${100 - leftPercentage}%`;
            });
            
            document.addEventListener('mouseup', function() {
                if (!isResizing) return;
                isResizing = false;
                document.body.style.cursor = '';
                // 恢复面板的正常交互
                leftPanel.style.userSelect = '';
                leftPanel.style.pointerEvents = '';
                rightPanel.style.userSelect = '';
                rightPanel.style.pointerEvents = '';
            });

            // 模态框点击空白区域关闭
            const imageModal = document.getElementById('imageModal');
            imageModal.addEventListener('click', function(event) {
                // 检查点击事件的目标是否是模态框背景本身 (而不是图片)
                if (event.target === this) {
                    closeModal();
                }
            });

            // 方法选择事件处理
            document.querySelectorAll('.method-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    this.classList.toggle('active');
                    const method = this.dataset.method;
                    
                    if (this.classList.contains('active')) {
                        if (!activeMethods.includes(method)) {
                            activeMethods.push(method);
                        }
                    } else {
                        const index = activeMethods.indexOf(method);
                        if (index > -1) {
                            activeMethods.splice(index, 1);
                        }
                    }
                    
                    // 显示/隐藏对应的控制参数
                    toggleMethodControls(method, this.classList.contains('active'));
                    
                    // 更新顺序指示器
                    updateMethodOrderIndicators();
                    
                    // 如果启用实时预览，立即应用
                    if (isRealTimePreview && originalImageData) {
                        applySeamlessEffect();
                    }
                });
            });
        }

        // 添加这个新函数来控制参数显示/隐藏
        function toggleMethodControls(method, isActive) {
            switch(method) {
                case 'mirror':
                    document.getElementById('mirrorControls').style.display = isActive ? 'block' : 'none';
                    break;
                case 'blend':
                    document.getElementById('blendControls').style.display = isActive ? 'block' : 'none';
                    break;
                case 'offset':
                    document.getElementById('offsetControls').style.display = isActive ? 'block' : 'none';
                    break;
                case 'gradient':
                    document.getElementById('gradientControls').style.display = isActive ? 'block' : 'none';
                    break;
            }
        }
        
        // 添加切换函数
        function toggleTiledPreview() {
            showTiledOriginal = !showTiledOriginal;
            const btn = document.getElementById('toggleTiledBtn');
            
            if (showTiledOriginal) {
                btn.classList.add('active');
                btn.innerHTML = `
                    <svg class="icon"><use xlink:href="#eye-slash-solid-full"></use></svg>
                    显示修改
                `;
            } else {
                btn.classList.remove('active');
                btn.innerHTML = `
                    <svg class="icon"><use xlink:href="#eye-solid-full"></use></svg>
                    显示原图
                `;
            }
            
            updateTiledPreview();
        }

        function initializeSliders() {
            // 图像调整滑竿
            ['brightness', 'contrast', 'saturation', 'hue', 'rotation'].forEach(id => {
                const slider = document.getElementById(id);
                
                slider.addEventListener('input', function() {
                    applyImageAdjustments();
                });
            });

            // 镜像强度控制 - 实时预览
            const mirrorSlider = document.getElementById('mirrorStrength');
            mirrorSlider.addEventListener('input', function() {
                if (isRealTimePreview && activeMethods.includes('mirror') && originalImageData) {
                    applySeamlessEffect();
                }
            });
            
            // 渐变强度控制 - 实时预览
            const gradientSlider = document.getElementById('gradientStrength');
            gradientSlider.addEventListener('input', function() {
                if (isRealTimePreview && activeMethods.includes('mirror') && originalImageData) {
                    applySeamlessEffect();
                }
            });
            
            // 光影矫正控制 - 实时预览
            ['gradientAngle', 'gradientExtend', 'gradientBrightness'].forEach(id => {
                const slider = document.getElementById(id);
                slider.addEventListener('input', function() {
                    if (isRealTimePreview && activeMethods.includes('gradient') && originalImageData) {
                        applySeamlessEffect();
                    }
                });
                
                // 为渐变角度添加特殊处理 - 显示箭头
                if (id === 'gradientAngle') {
                    slider.addEventListener('input', function() {
                        showArrowIndicator();
                    });
                    
                    slider.addEventListener('change', function() {
                        hideArrowIndicator();
                    });
                }
            });
            
            // 偏移控制 - 实时预览
            ['offsetX', 'offsetY'].forEach(id => {
                const slider = document.getElementById(id);
                
                slider.addEventListener('input', function() {
                    if (isRealTimePreview && activeMethods.includes('offset') && originalImageData) {
                        applySeamlessEffect();
                    }
                });
            });

            // 混合强度 - 实时预览
            const blendSlider = document.getElementById('blendStrength');
            blendSlider.addEventListener('input', function() {
                if (isRealTimePreview && activeMethods.includes('blend') && originalImageData) {
                    applySeamlessEffect();
                }
            });
        }

        // 初始化数字输入框
        function initializeNumberInputs() {
            // 图像调整参数
            const adjustParams = [
                {id: 'brightness', min: 0, max: 200, unit: '%'},
                {id: 'contrast', min: 0, max: 200, unit: '%'},
                {id: 'saturation', min: 0, max: 200, unit: '%'},
                {id: 'hue', min: -180, max: 180, unit: '°'},
                {id: 'rotation', min: 0, max: 360, unit: '°'}
            ];
            
            // 无缝处理参数
            const seamlessParams = [
                {id: 'mirrorStrength', min: 0, max: 50, unit: '%'},
                {id: 'gradientStrength', min: -100, max: 100, unit: '%'},
                {id: 'blendStrength', min: 0, max: 50, unit: '%'},
                {id: 'offsetX', min: 0, max: 100, unit: '%'},
                {id: 'offsetY', min: 0, max: 100, unit: '%'},
                {id: 'gradientAngle', min: 0, max: 360, unit: '°'},
                {id: 'gradientExtend', min: 0, max: 100, unit: '%'},
                {id: 'gradientBrightness', min: -100, max: 100, unit: '%'}
            ];
            
            // 为所有参数设置输入框事件
            [...adjustParams, ...seamlessParams].forEach(param => {
                const slider = document.getElementById(param.id);
                const input = document.getElementById(param.id + 'Input');
                
                // 输入框变化时更新滑块
                input.addEventListener('input', function() {
                    let value = Math.max(param.min, Math.min(param.max, Number(this.value)));
                    this.value = value;
                    slider.value = value;
                    
                    // 触发相应的处理
                    if (adjustParams.find(p => p.id === param.id)) {
                        applyImageAdjustments();
                    } else if (isRealTimePreview && originalImageData) {
                        applySeamlessEffect();
                    }
                    
                    // 如果是渐变角度，显示箭头
                    if (param.id === 'gradientAngle') {
                        showArrowIndicator();
                    }
                });
                
                // 滑块变化时更新输入框
                slider.addEventListener('input', function() {
                    input.value = this.value;
                });
                
                // 如果是渐变角度输入框，添加失去焦点事件隐藏箭头
                if (param.id === 'gradientAngle') {
                    input.addEventListener('blur', function() {
                        hideArrowIndicator();
                    });
                }
            });
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                loadImage(file);
            }
        }

        function loadImage(file) {
            // 检查是否是TIFF文件
            if (file.type === 'image/tiff' || file.name.toLowerCase().endsWith('.tiff') || file.name.toLowerCase().endsWith('.tif')) {
                loadTiffImage(file);
                return;
            }
            
            // 处理其他格式
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    originalImageData = {
                        image: img,
                        width: img.width,
                        height: img.height
                    };
                    
                    setupCanvases();
                    drawOriginalImage();
                    applyImageAdjustments();
                    showControls();
                    updateImageDimensions();
                    enableRealTimePreview();
                    
		activeMethods.forEach(method => {
            toggleMethodControls(method, true);
        });
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // 添加窗口大小改变时的监听
        window.addEventListener('resize', adjustCanvasDisplay);
        
        function adjustCanvasDisplay() {
            if (!originalImageData) return;
            
            const container = document.querySelector('.preview-content');
            const canvas = document.getElementById('processedCanvas');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            const imgRatio = originalImageData.width / originalImageData.height;
            const containerRatio = containerWidth / containerHeight;
            
            // 根据容器和图片比例调整canvas显示尺寸
            if (imgRatio > containerRatio) {
                // 图片更宽，以宽度为基准
                canvas.style.width = '100%';
                canvas.style.height = 'auto';
            } else {
                // 图片更高，以高度为基准
                canvas.style.width = 'auto';
                canvas.style.height = '100%';
            }
        }

        function loadTiffImage(file) {
            // 检查 UTIF 库是否已加载。如果未加载，说明 <script> 标签加载失败。
            if (typeof UTIF === 'undefined') {
                alert('TIFF 支持库加载失败。请检查您的网络连接并刷新页面。');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const buffer = e.target.result;
                    const ifds = UTIF.decode(buffer);
                    // 处理多页TIFF，我们只使用第一页
                    const page = ifds[0];
                    UTIF.decodeImage(buffer, page);
                    
                    const canvas = document.createElement('canvas');
                    // 修复Canvas2D性能警告：设置willReadFrequently属性
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    canvas.width = page.width;
                    canvas.height = page.height;
                    
                    const rgba = UTIF.toRGBA8(page);
                    const imageData = new ImageData(
                        new Uint8ClampedArray(rgba), 
                        page.width, 
                        page.height
                    );
                    ctx.putImageData(imageData, 0, 0);
                    
                    const img = new Image();
                    img.onload = function() {
                        originalImageData = {
                            image: img,
                            width: img.width,
                            height: img.height
                        };
                        
                        setupCanvases();
                        drawOriginalImage();
                        applyImageAdjustments();
                        showControls();
                        updateImageDimensions();
                        enableRealTimePreview();
                    };
                    img.src = canvas.toDataURL();
                } catch (error) {
                    console.error('TIFF 加载错误:', error);
                    alert('无法处理此TIFF文件，可能已损坏或格式不受支持。');
                }
            };
            reader.onerror = () => {
                alert('文件读取失败。');
            };
            reader.readAsArrayBuffer(file);
        }

        function setupCanvases() {
            const { width, height } = originalImageData;
            
            // 设置处理后图像画布
            processedCanvas.width = width;
            processedCanvas.height = height;
            
            // 设置平铺预览画布
            tiledCanvas.width = width * 3;
            tiledCanvas.height = height * 3;
            
            // 设置调整画布
            adjustCanvas.width = width;
            adjustCanvas.height = height;
            
            // 设置旋转画布 - 保持原始尺寸
            rotatedCanvas.width = width;
            rotatedCanvas.height = height;
            
            // 设置箭头画布 - 修改为与显示尺寸一致，而不是图像原始尺寸
    const previewContent = document.querySelector('.preview-content');
    arrowCanvas.width = previewContent.clientWidth;
    arrowCanvas.height = previewContent.clientHeight;
            
            // 显示画布
            processedCanvas.style.display = 'block';
            tiledCanvas.style.display = 'block';
            document.getElementById('noImageMessage').style.display = 'none';
            document.getElementById('noTileMessage').style.display = 'none';
        }

        function drawOriginalImage() {
            processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
            processedCtx.drawImage(originalImageData.image, 0, 0);
            
            // 保存到调整画布
            adjustCtx.clearRect(0, 0, adjustCanvas.width, adjustCanvas.height);
            adjustCtx.drawImage(originalImageData.image, 0, 0);
        }

        function applyImageAdjustments() {
            if (!originalImageData) return;
            
            const brightness = document.getElementById('brightness').value;
            const contrast = document.getElementById('contrast').value;
            const saturation = document.getElementById('saturation').value;
            const hue = document.getElementById('hue').value;
            const rotation = document.getElementById('rotation').value;
            
            // 清除并重绘原图
            processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
            
            // 应用滤镜
            const filters = [
                `brightness(${brightness}%)`,
                `contrast(${contrast}%)`,
                `saturate(${saturation}%)`,
                `hue-rotate(${hue}deg)`
            ];
            
            processedCtx.filter = filters.join(' ');
            processedCtx.drawImage(originalImageData.image, 0, 0);
            processedCtx.filter = 'none';
            
            // 保存调整后的图像到调整画布
            adjustCtx.clearRect(0, 0, adjustCanvas.width, adjustCanvas.height);
            adjustCtx.filter = filters.join(' ');
            adjustCtx.drawImage(originalImageData.image, 0, 0);
            adjustCtx.filter = 'none';
            
            // 应用旋转（围绕中心旋转并铺满）
            applyRotation(rotation);
            
            // 根据显示模式更新预览
            if (showOriginal) {
                // 显示调整后的图像（未应用无缝效果）
                processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
                processedCtx.drawImage(rotatedCanvas, 0, 0);
            } else {
                // 应用无缝效果
                applySeamlessEffect();
            }
            
            // 更新平铺预览
            updateTiledPreview();
        }
        
        // --- 已修复的旋转函数 ---
        function applyRotation(rotation) {
            const { width, height } = adjustCanvas;

            // 设置旋转画布尺寸以保持原始尺寸
            rotatedCanvas.width = width;
            rotatedCanvas.height = height;
            rotatedCtx.clearRect(0, 0, width, height);

            // 如果不旋转，直接复制图像并返回
            if (rotation == 0) {
                rotatedCtx.drawImage(adjustCanvas, 0, 0);
                return;
            }

            const radians = rotation * Math.PI / 180;
            
            // 计算覆盖整个画布所需的缩放比例
            // 以确保旋转后的图像的边缘可以延伸到画布的角落之外
            const absCos = Math.abs(Math.cos(radians));
            const absSin = Math.abs(Math.sin(radians));
            
            // 这是为确保旋转后的矩形能填满原始矩形区域所需的最小放大比例
            // 计算缩放比例，使其能填满原始宽度和高度
            const scaleX = width / (width * absCos + height * absSin);
            const scaleY = height / (width * absSin + height * absCos);
            const scale = 1 / Math.min(scaleX, scaleY);

            // 保存当前上下文状态
            rotatedCtx.save();
            
            // 移动到画布中心
            rotatedCtx.translate(width / 2, height / 2);
            
            // 旋转上下文
            rotatedCtx.rotate(radians);
            
            // 缩放上下文以确保覆盖
            rotatedCtx.scale(scale, scale);
            
            // 在新的中心点绘制图像（原点现在是画布中心）
            rotatedCtx.drawImage(adjustCanvas, -width / 2, -height / 2);
            
            // 恢复上下文状态
            rotatedCtx.restore();
        }

        function enableRealTimePreview() {
            isRealTimePreview = true;
            document.getElementById('liveIndicator').style.display = 'none';
            
            // 立即应用无缝效果
            if (originalImageData) {
                applySeamlessEffect();
            }
        }

        function applySeamlessEffect() {
            if (!originalImageData || showOriginal) return;
            
            const tempCanvas = document.createElement('canvas');
            // 修复Canvas2D性能警告：设置willReadFrequently属性
            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
            tempCanvas.width = rotatedCanvas.width;
            tempCanvas.height = rotatedCanvas.height;
            
            // 复制旋转后的图像
            tempCtx.drawImage(rotatedCanvas, 0, 0);
            
            // 应用所有选中的无缝处理方法
            if (activeMethods.length > 0) {
                // 按照预设顺序应用方法
                const methodOrder = ['offset', 'gradient', 'mirror', 'blend'];
                
                methodOrder.forEach(method => {
                    if (activeMethods.includes(method)) {
                        switch (method) {
                            case 'mirror':
                                applyMirrorSeamless(tempCanvas);
                                break;
                            case 'gradient':
                                applyGradientCorrection(tempCanvas);
                                break;
                            case 'offset':
                                applyOffsetSeamless(tempCanvas);
                                break;
                            case 'blend':
                                applyBlendSeamless(tempCanvas);
                                break;
                        }
                    }
                });
            }
            
            // 更新显示
            processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
            processedCtx.drawImage(tempCanvas, 0, 0);
            updateTiledPreview();
        }

        // 修改后的applyGradientCorrection函数
        function applyGradientCorrection(sourceCanvas) {
            const { width, height } = sourceCanvas;
            const ctx = sourceCanvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // 获取参数值
            const angle = parseInt(document.getElementById('gradientAngle').value);
            const extend = parseInt(document.getElementById('gradientExtend').value) / 100;
            const brightness = parseInt(document.getElementById('gradientBrightness').value);
            
            // 计算角度对应的方向向量
            const rad = angle * Math.PI / 180;
            const dirX = Math.sin(rad);
            const dirY = -Math.cos(rad); // 负号是因为图像坐标系Y轴向下
            
            // 计算图像对角线长度作为最大距离
            const maxDist = Math.sqrt(width * width + height * height);
            
            // 计算图像中心
            const centerX = width / 2;
            const centerY = height / 2;
            
            // 计算四个角点在方向向量上的投影值，找到最小和最大值
            let minProjection = Infinity;
            let maxProjection = -Infinity;
            
            // 检查四个角点
            const corners = [
                [0, 0],          // 左上
                [width, 0],      // 右上
                [0, height],     // 左下
                [width, height]  // 右下
            ];
            
            corners.forEach(([x, y]) => {
                const relX = x - centerX;
                const relY = y - centerY;
                const projection = relX * dirX + relY * dirY;
                minProjection = Math.min(minProjection, projection);
                maxProjection = Math.max(maxProjection, projection);
            });
            
            const projectionRange = maxProjection - minProjection;
            
            // 处理每个像素
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = (y * width + x) * 4;
                    
                    // 计算像素相对于图像中心的位置
                    const relX = x - centerX;
                    const relY = y - centerY;
                    
                    // 计算在渐变方向上的投影距离
                    const projection = relX * dirX + relY * dirY;
                    
                    // 归一化投影值到[0,1]范围
                    const normalizedProjection = (projection - minProjection) / projectionRange;
                    
                    // 应用延伸参数
                    const effectiveProjection = Math.max(0, Math.min(1, normalizedProjection * extend));
                    
                    // 应用亮度调整
                    const adjust = brightness * effectiveProjection;
                    
                    for (let i = 0; i < 3; i++) {
                        data[index + i] = Math.max(0, Math.min(255, data[index + i] + adjust));
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        // 渐变过渡参数处理函数 - 修改为处理亮度
        function applyMirrorSeamless(sourceCanvas) {
            const { width, height } = sourceCanvas;
            const ctx = sourceCanvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const newData = new Uint8ClampedArray(data);
            
            const strength = parseInt(document.getElementById('mirrorStrength').value);
            const gradientStrength = parseInt(document.getElementById('gradientStrength').value);
            const edgeSize = Math.min(width, height) * strength / 100;
            
            // 计算图像中心点
            const centerX = width / 2;
            const centerY = height / 2;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = (y * width + x) * 4;
                    
                    // 计算到边缘的距离
                    const distLeft = x;
                    const distRight = width - 1 - x;
                    const distTop = y;
                    const distBottom = height - 1 - y;
                    
                    const minDistX = Math.min(distLeft, distRight);
                    const minDistY = Math.min(distTop, distBottom);
                    
                    // 计算到中心的归一化距离 (0-1)
                    const distToCenterX = Math.abs(x - centerX) / centerX;
                    const distToCenterY = Math.abs(y - centerY) / centerY;
                    const distanceToCenter = Math.sqrt(distToCenterX * distToCenterX + distToCenterY * distToCenterY);
                    
                    // 处理边缘像素
                    if (minDistX < edgeSize || minDistY < edgeSize) {
                        const weightX = minDistX < edgeSize ? minDistX / edgeSize : 1;
                        const weightY = minDistY < edgeSize ? minDistY / edgeSize : 1;
                        const weight = Math.min(weightX, weightY);
                        
                        // 获取镜像位置的像素
                        const mirrorX = distLeft < distRight ? width - 1 - x : x;
                        const mirrorY = distTop < distBottom ? height - 1 - y : y;
                        const mirrorIndex = (mirrorY * width + mirrorX) * 4;
                        
                        // 混合像素
                        for (let i = 0; i < 3; i++) {
                            newData[index + i] = data[index + i] * weight + data[mirrorIndex + i] * (1 - weight);
                        }
                    }
                    
                    // 应用渐变亮度调整（如果有设置）
                    if (gradientStrength !== 0) {
                        // 计算边缘影响因子 (0-1)
                        let edgeFactor = 0;
                        if (minDistX < edgeSize) edgeFactor = Math.max(edgeFactor, 1 - (minDistX / edgeSize));
                        if (minDistY < edgeSize) edgeFactor = Math.max(edgeFactor, 1 - (minDistY / edgeSize));
                        
                        // 应用亮度调整（基于边缘影响因子和渐变强度）
                        const brightnessAdjustment = gradientStrength * edgeFactor;
                        
                        for (let i = 0; i < 3; i++) {
                            let newValue = newData[index + i] + brightnessAdjustment;
                            newData[index + i] = Math.max(0, Math.min(255, newValue));
                        }
                    }
                }
            }
            
            const newImageData = new ImageData(newData, width, height);
            ctx.putImageData(newImageData, 0, 0);
        }

        function applyOffsetSeamless(sourceCanvas) {
            const { width, height } = sourceCanvas;
            const ctx = sourceCanvas.getContext('2d');
            
            const offsetX = parseInt(document.getElementById('offsetX').value);
            const offsetY = parseInt(document.getElementById('offsetY').value);
            
            const actualOffsetX = Math.floor(width * offsetX / 100);
            const actualOffsetY = Math.floor(height * offsetY / 100);
            
            // 创建临时画布保存原图
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = width;
            tempCanvas.height = height;
            tempCtx.drawImage(sourceCanvas, 0, 0);
            
            // 清空原画布
            ctx.clearRect(0, 0, width, height);
            
            // 重新排列四象限
            // 左上 -> 右下
            ctx.drawImage(tempCanvas, 
                0, 0, width - actualOffsetX, height - actualOffsetY,
                actualOffsetX, actualOffsetY, width - actualOffsetX, height - actualOffsetY
            );
            
            // 右上 -> 左下
            ctx.drawImage(tempCanvas,
                width - actualOffsetX, 0, actualOffsetX, height - actualOffsetY,
                0, actualOffsetY, actualOffsetX, height - actualOffsetY
            );
            
            // 左下 -> 右上
            ctx.drawImage(tempCanvas,
                0, height - actualOffsetY, width - actualOffsetX, actualOffsetY,
                actualOffsetX, 0, width - actualOffsetX, actualOffsetY
            );
            
            // 右下 -> 左上
            ctx.drawImage(tempCanvas,
                width - actualOffsetX, height - actualOffsetY, actualOffsetX, actualOffsetY,
                0, 0, actualOffsetX, actualOffsetY
            );
        }

        function applyBlendSeamless(sourceCanvas) {
            const { width, height } = sourceCanvas;
            const ctx = sourceCanvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const newData = new Uint8ClampedArray(data);
            
            const strength = parseInt(document.getElementById('blendStrength').value);
            const blendSize = Math.floor(Math.min(width, height) * strength / 200);
            
            if (blendSize === 0) return;
            
            // 水平边缘混合
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < blendSize; x++) {
                    const leftIndex = (y * width + x) * 4;
                    const rightIndex = (y * width + (width - 1 - x)) * 4;
                    const weight = (x + 1) / (blendSize + 1);
                    
                    for (let i = 0; i < 3; i++) {
                        const leftOriginal = data[leftIndex + i];
                        const rightOriginal = data[rightIndex + i];
                        
                        newData[leftIndex + i] = leftOriginal * weight + rightOriginal * (1 - weight);
                        newData[rightIndex + i] = rightOriginal * weight + leftOriginal * (1 - weight);
                    }
                }
            }
            
            // 垂直边缘混合
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < blendSize; y++) {
                    const topIndex = (y * width + x) * 4;
                    const bottomIndex = ((height - 1 - y) * width + x) * 4;
                    const weight = (y + 1) / (blendSize + 1);
                    
                    for (let i = 0; i < 3; i++) {
                        const topOriginal = data[topIndex + i];
                        const bottomOriginal = data[bottomIndex + i];
                        
                        newData[topIndex + i] = topOriginal * weight + bottomOriginal * (1 - weight);
                        newData[bottomIndex + i] = bottomOriginal * weight + topOriginal * (1 - weight);
                    }
                }
            }
            
            const finalImageData = new ImageData(newData, width, height);
            ctx.putImageData(finalImageData, 0, 0);
        }

        function updateTiledPreview() {
            if (!originalImageData) return;
            
            const { width, height } = processedCanvas;
            
            // 清空平铺画布
            tiledCtx.clearRect(0, 0, tiledCanvas.width, tiledCanvas.height);
            
            // 确定要绘制的源画布
            const sourceCanvas = showTiledOriginal ? rotatedCanvas : processedCanvas;
            
            // 绘制3x3网格
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    tiledCtx.drawImage(sourceCanvas, x * width, y * height);
                }
            }
        }

        function updateMethodOrderIndicators() {
            document.querySelectorAll('.method-btn').forEach(btn => {
                const method = btn.dataset.method;
                const indicator = btn.querySelector('.order-indicator');
                
                if (activeMethods.includes(method)) {
                    const order = activeMethods.indexOf(method) + 1;
                    indicator.textContent = order;
                    indicator.style.display = 'flex';
                } else {
                    indicator.style.display = 'none';
                }
            });
        }

        function showControls() {
            document.getElementById('imageControls').style.display = 'block';
            document.getElementById('seamlessControls').style.display = 'block';
            document.getElementById('headerExport').style.display = 'flex';
        }

        function updateImageDimensions() {
            if (originalImageData) {
                document.getElementById('imageDimensions').textContent = 
                    `${rotatedCanvas.width} × ${rotatedCanvas.height}`;
            }
        }

        function resetAdjustments() {
            // 重置滑块和输入框的值
            document.getElementById('brightness').value = 100;
            document.getElementById('brightnessInput').value = 100;
            document.getElementById('contrast').value = 100;
            document.getElementById('contrastInput').value = 100;
            document.getElementById('saturation').value = 100;
            document.getElementById('saturationInput').value = 100;
            document.getElementById('hue').value = 0;
            document.getElementById('hueInput').value = 0;
            document.getElementById('rotation').value = 0;
            document.getElementById('rotationInput').value = 0;
            
            applyImageAdjustments();
        }

        function toggleOriginalPreview() {
            showOriginal = !showOriginal;
            const btn = document.getElementById('toggleOriginalBtn');
            
            if (showOriginal) {
                // 显示原图（调整后的图像）
                processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
                processedCtx.drawImage(rotatedCanvas, 0, 0);
                btn.classList.add('active');
                btn.innerHTML = `
                    <svg class="icon"><use xlink:href="#eye-slash-solid-full"></use></svg>
                    显示修改
                `;
            } else {
                // 显示处理结果，重新应用无缝处理
                applySeamlessEffect();
                btn.classList.remove('active');
                btn.innerHTML = `
                    <svg class="icon"><use xlink:href="#eye-solid-full"></use></svg>
                    显示原图
                `;
            }
        }
        
        function resetSeamlessParameters() {
            // 重置滑块和输入框为初始值
            document.getElementById('mirrorStrength').value = 20;
            document.getElementById('mirrorStrengthInput').value = 20;
            document.getElementById('blendStrength').value = 20;
            document.getElementById('blendStrengthInput').value = 20;
            document.getElementById('gradientStrength').value = 0;
            document.getElementById('gradientStrengthInput').value = 0;
            document.getElementById('offsetX').value = 50;
            document.getElementById('offsetXInput').value = 50;
            document.getElementById('offsetY').value = 50;
            document.getElementById('offsetYInput').value = 50;
            
            // 新增光影矫正参数重置
            document.getElementById('gradientAngle').value = 180;
            document.getElementById('gradientAngleInput').value = 180;
            document.getElementById('gradientExtend').value = 50;
            document.getElementById('gradientExtendInput').value = 50;
            document.getElementById('gradientBrightness').value = 50;
            document.getElementById('gradientBrightnessInput').value = 50;
            
            // 重置所有方法选择按钮
            activeMethods = [];
            document.querySelectorAll('.method-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.querySelector('.order-indicator').style.display = 'none';
                // 隐藏所有控制面板
                toggleMethodControls(btn.dataset.method, false);
            });
            
            // 重新应用效果
            if (originalImageData) {
                applySeamlessEffect();
            }
        }
        
        // 图像放大功能
        function zoomImage() {
            if (!originalImageData) return;
            
            const dataURL = processedCanvas.toDataURL();
            const modal = document.getElementById('imageModal');
            const modalImage = document.getElementById('modalImage');
            
            modalImage.src = dataURL;
            modal.style.display = 'flex';
        }
        
        function zoomTiledImage() {
            if (!originalImageData) return;
            
            const dataURL = tiledCanvas.toDataURL();
            const modal = document.getElementById('imageModal');
            const modalImage = document.getElementById('modalImage');
            
            modalImage.src = dataURL;
            modal.style.display = 'flex';
        }
        
        function closeModal() {
            document.getElementById('imageModal').style.display = 'none';
        }

        function exportImage() {
            if (!originalImageData) return;
            
            const format = document.getElementById('exportFormat').value;
            let quality = 1;
            let extension = 'png';
            
            // 根据格式设置质量和扩展名
            switch (format) {
                case 'image/jpeg':
                    quality = 0.9;
                    extension = 'jpg';
                    break;
                case 'image/webp':
                    quality = 0.9;
                    extension = 'webp';
                    break;
                case 'image/tiff':
                    // TIFF导出会转换为高质量PNG
                    extension = 'tiff';
                    break;
                default:
                    extension = 'png';
            }
            
            const actualFormat = format === 'image/tiff' ? 'image/png' : format;
            
            processedCanvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `seamless-texture-${Date.now()}.${extension}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, actualFormat, quality);
        }

        function clearImage() {
            originalImageData = null;
            isRealTimePreview = false;
            showOriginal = false;
            activeMethods = [];
            
            // 隐藏画布
            processedCanvas.style.display = 'none';
            tiledCanvas.style.display = 'none';
            
            // 显示占位消息
            document.getElementById('noImageMessage').style.display = 'block';
            document.getElementById('noTileMessage').style.display = 'block';
            
            // 隐藏控制面板
            document.getElementById('imageControls').style.display = 'none';
            document.getElementById('seamlessControls').style.display = 'none';
            document.getElementById('headerExport').style.display = 'none';
            document.getElementById('liveIndicator').style.display = 'none';
            
            // 重置文件输入
            document.getElementById('fileInput').value = '';
            
            // 清空尺寸显示
            document.getElementById('imageDimensions').textContent = '';
            
            // 重置切换按钮
            const btn = document.getElementById('toggleOriginalBtn');
            btn.classList.remove('active');
            btn.innerHTML = `
                <svg class="icon"><use xlink:href="#eye-solid-full"></use></svg>
                显示原图
            `;
            
            // 重置调整值
            resetAdjustments();
            
            // 重置方法选择
            document.querySelectorAll('.method-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.querySelector('.order-indicator').style.display = 'none';
            });
            
            // 新增：确保所有方法控制面板被隐藏
            hideAllMethodControls();
        }
        
        // 箭头指示器相关函数
        function showArrowIndicator() {
            if (!originalImageData) return;
            
            // 清除之前的定时器
            if (arrowTimeout) {
                clearTimeout(arrowTimeout);
                arrowTimeout = null;
            }
            
            // 显示箭头画布
            arrowCanvas.style.display = 'block';
            
            // 绘制箭头
            drawArrow();
        }
        
        function hideArrowIndicator() {
            // 设置定时器，延迟隐藏箭头
            arrowTimeout = setTimeout(() => {
                arrowCanvas.style.display = 'none';
                arrowTimeout = null;
            }, 1000); // 1秒后隐藏
        }
        
function drawArrow() {
    const angle = parseInt(document.getElementById('gradientAngle').value);
    const { width, height } = arrowCanvas;
    
    // 清除画布
    arrowCtx.clearRect(0, 0, width, height);
    
    // 计算中心点 - 使用画布的中心而不是图像的中心
    const centerX = width / 2;
    const centerY = height / 2;
    
    // 计算箭头长度（画布对角线的一半）
    const arrowLength = Math.min(width, height) * 0.3;
    
    // 转换为弧度 - 注意：这里需要调整角度系统
    // 画布的坐标系是Y轴向下，而角度系统是Y轴向上
    // 所以需要将角度调整为从顶部开始，顺时针为正
    const rad = (angle + 90) * Math.PI / 180; // 减去90度使0°指向顶部
    
    // 计算箭头终点
    const endX = centerX + Math.cos(rad) * arrowLength;
    const endY = centerY + Math.sin(rad) * arrowLength;
    
    // 设置箭头样式
    arrowCtx.strokeStyle = '#fff';
    arrowCtx.lineWidth = 2;
    arrowCtx.lineCap = 'round';
    
    // 绘制箭头线
    arrowCtx.beginPath();
    arrowCtx.moveTo(centerX, centerY);
    arrowCtx.lineTo(endX, endY);
    arrowCtx.stroke();
    
    // 绘制箭头头部
    const headLength = 15;
    const angle1 = rad + Math.PI * 0.2; // 箭头角度1
    const angle2 = rad - Math.PI * 0.2; // 箭头角度2
    
    arrowCtx.beginPath();
    arrowCtx.moveTo(endX, endY);
    arrowCtx.lineTo(endX - Math.cos(angle1) * headLength, endY - Math.sin(angle1) * headLength);
    arrowCtx.moveTo(endX, endY);
    arrowCtx.lineTo(endX - Math.cos(angle2) * headLength, endY - Math.sin(angle2) * headLength);
    arrowCtx.stroke();
}
    </script>
</body>
</html>