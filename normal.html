<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PBR全流程贴图生成器 - 法线/置换/AO/反射/光泽度 - GPU加速版 + 3D预览</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/utif@3.1.0/UTIF.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="menu.js" defer></script>
    <link rel="icon" href="img/gongjuxiang.svg" type="image/svg">
<script defer src="https://cloud.umami.is/script.js" data-website-id="5a2e10cd-bf73-47df-be48-079c9ba7783c" data-domains="designtool.site"></script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3983418855272291"
     crossorigin="anonymous"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        :root {
            --main-color: #8080FF;
            --reverse-color: #FF8A65;
            --bg-background: #242428;
            --btcolor: linear-gradient(to left, #6450ff, #8f56fa);
            --text1: #fff;
            --text2: #c7d1e2;
            --text3: #969dbb;
            --line: #7878784d;
            --mainbg: #2e2e33d9;
            --shadow: #8080ff99;
            --btbg: #babac5;
            --lightbg: #36363b;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1b1c;
            min-height: 100vh;
            overflow-x: hidden;
            color: var(--text2);
        }
	.under {
		display: grid; 
		grid-template-columns: 1fr 1fr;
		font-size: 0.9rem;
	}
        .topgroup {
            gap: 10px;
            display: flex;
            position: fixed;
            margin-top: 20px;
            left: 20px;
            background: #2b2b2f;
            border-radius: 30px;
            padding: 4px;
            z-index: 999;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }
        .home-icon {
            font-size: 40px;
            cursor: pointer;
            transition: all 0.3s;
            padding: 8px; 
            border-radius: 50%;
            width: 1em; 
            height: 1em;
            vertical-align: -0.15em;
            overflow: hidden;
        }
        .topgroup:hover {
            background:#36363b;
        }
        .kuang {
            background: var(--lightbg);
            border-radius: 10px;
            border: 1px solid var(--line);
        }
        .scrib{
            color: var(--text3); 
            font-size: 0.9rem;
            margin-left: 10px;
            font-weight: 400;
        }
        .canshu {
            background: #2b2b2f;
            padding: 0 6px;
            border-radius: 4px;
        }
        .line {
            width: 100%;
            height: 1px;
            background: var(--line);
        }
        .line2 {
            width: 100%;
            height: 1px;
            background: #0a0a14b3;
        }
        .container {
            max-width: 1300px;
            margin: 0 auto;
            padding: 20px;
	display: flex;
    flex-direction: column;
    gap: 20px;
        }
        
        header {
            text-align: center;
            position: relative;
            overflow: hidden;
            padding: 0 20px;
        }
        
        h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            color: var(--main-color);
            letter-spacing: 1px;
            position: relative;
	    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
	margin-top: 20px;
        }
        
        .header-subtitle {
            color: var(--text3);
            font-size: 0.9rem;
            max-width: 800px;
            margin: 0 auto
        }
        
        .content-n {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        
        .panel {
            background: var(--mainbg);
            border-radius: 10px;
            padding: 25px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            flex-direction: column;
            height: 100%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .panel h2 {
            font-size: 1.1rem;
            margin-bottom: 25px;
            color: var(--text1);
            display: flex;
            align-items: center;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--line);
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            padding: 12px 20px;
            justify-content: space-between;
        }
        

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        label {
            color: var(--text2);
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.95rem;
        }
        
        input[type="range"] {
            width: 100%;
            height: 10px;
            background: var(--main-color);
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--main-color);
            transition: all 0.2s ease;
            box-shadow: 0 0 8px rgba(128, 128, 255, 0.6);
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }
        
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--main-color);
            cursor: pointer;
        }
        
        .btn-group {
            display: flex;
            gap: 15px;
            grid-column: 1 / -1;
            margin: 20px 0 25px 0;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        button {
            background: none;
            color: #fff;
            border: none;
            padding: 16px 25px;
            border-radius: 30px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            position: relative;
            overflow: hidden;
            height: 46px;
	    width: 40%;
        }
        
        button:hover {
            box-shadow: 0px 8px 10px var(--bg-background);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        #downloadMapBtn {
            background: var(--btcolor);
            color: #fff;
        }
        
        #downloadMapBtn:hover {
            box-shadow: 0 10px 16px -6px var(--shadow);
        }
        
        .canvas-container {
            position: relative;
            background: rgba(10, 10, 20, 0.7);
            border-radius: 10px;
            overflow: hidden;
            min-height: 300px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(128, 128, 255, 0.1);
            width: 100%;
        }
        
        .canvas-container:hover {
            border-color: var(--main-color);
        }
        
        canvas {
            max-width: 100%;
            max-height: 320px;
            background: #111;
            border-radius: 8px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.6);
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            -ms-interpolation-mode: nearest-neighbor;
            transition: transform 0.3s ease;
        }
        
        canvas:hover {
            transform: scale(1.015);
        }
        
        .placeholder {
            color: var(--text2);
            text-align: center;
            padding: 40px;
            font-size: 1rem;
            line-height: 1.7;
        }
        
        .placeholder i {
            font-size: 3.5rem;
            display: block;
            margin-bottom: 25px;
            color: var(--text2);
            text-shadow: 0 0 15px rgba(128, 128, 255, 0.4);
        }
        
        .value-display {
            display: flex;
            justify-content: space-between;
            font-size: 1rem;
            color: #90caf9;
            background: rgba(0, 0, 40, 0.5);
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid var(--line);
            color: var(--text3);
            font-size: 1rem;
        }
        
        .example-images {
            display: flex;
            gap: 20px;
            margin-right: 20px;
            flex-direction: column;
        }
        
        .example-image {
            width: 70px;
            height: 70px;
            border-radius: 10px;
            overflow: hidden;
            cursor: pointer;
            opacity: 0.9;
            transition: all 0.3s ease;
            border: 2px solid var(--line);
            position: relative;
        }
        
        .example-image:hover {
            opacity: 1;
            transform: translateY(-7px);
            border-color: #8080FF;
            box-shadow: 0 8px 20px rgba(128, 128, 255, 0.6);
        }
        
        .example-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .example-image .label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(0deg, #242424, transparent);
            color: white;
            text-align: center;
            font-size: 0.8rem;
        }
        
        .progress-container {
            display: none;
            z-index: 999;
            position: fixed;
            padding: 10px 20px;
            margin: 0 auto;
            width: 30%;
            background: var(--line);
            border-radius: 10px;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            left: 0;
            right: 0;
            top: 50px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        
        .progress-bar {
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00c853, #76ff03);
            width: 0%;
            transition: width 0.4s ease;
            border-radius: 6px;
        }
        
        .quality-indicator {
            display: flex;
            justify-content: space-between;
            font-size: 0.95rem;
            color: var(--text2);
            margin-bottom: 10px;
        }
        
        .param-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: var(--text3);
        }
        
        .section-title {
            text-align: center;
            margin: 20px 0 15px;
            color: #bbdefb;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .file-upload-area {
            background: var(--bg-background);
            border-radius: 10px;
            padding: 20px;
            border: 2px dashed var(--line);
            text-align: center;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }
        
        .file-upload-area:hover {
            border-color: var(--main-color);
            background: rgba(0, 0, 30, 0.4);
        }
        
        .file-upload-area label {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            font-size: 1rem;
        }
        
        .file-upload-area i {
            font-size: 3.5rem;
            color: #454559;
            transition: all 0.3s ease;
        }
        
        .file-upload-area:hover i {
            color: var(--main-color);
        }
        
        .info-text {
            background: rgba(10, 10, 20, 0.6);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            font-size: 0.95rem;
            color: var(--text3);
            line-height: 1.7;
        }
        
        .info-text i {
            color: var(--main-color);
            margin-right: 8px;
        }
        
        .panel-title {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        .panel-title h2 {
            margin: 0;
            padding-bottom: 0;
            border: none;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            max-width: 90%;
            max-height: 90%;
            border-radius: 10px;
        }
        
        .close {
            position: absolute;
            top: 20px;
            right: 35px;
            color: #f1f1f1;
            font-size: 40px;
            font-weight: bold;
            transition: 0.3s;
            cursor: pointer;
        }
        
        .close:hover,
        .close:focus {
            color: #8080FF;
            text-decoration: none;
        }
        
        .drag-over {
            border-color: var(--main-color) !important;
            background: rgba(128, 128, 255, 0.1) !important;
        }
        
        .reverse-info {
            background: rgba(255, 138, 101, 0.1);
            border-left: 4px solid var(--reverse-color);
            padding: 15px;
            border-radius: 0 8px 8px 0;
            margin-top: 15px;
            font-size: 0.9rem;
        }
        
        .algorithm-info {
            display: flex;
            flex-direction: row;
            gap: 10px;
            margin-top: 15px;
            align-items: center;
        }
        
        .algorithm-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 20px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .algorithm-option input[type="radio"] {
            accent-color:var(--main-color);
        }
        
        .algorithm-option label {
            cursor: pointer;
            font-size: 0.9rem;
        }
        .algorithm-option label:hover {
            color: var(--main-color);
        }
        .algorithm-description {
            font-size: 0.8rem;
            color: var(--text3);
            padding-left: 28px;
            margin-top: 4px;
        }
        
        .format-badge {
            background: rgba(128, 128, 255, 0.2);
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 0.8rem;
            margin-left: 8px;
        }
        
        .drag-hint {
            position: absolute;
            bottom: 15px;
            left: 0;
            right: 0;
            text-align: center;
            color: var(--text3);
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .mode-toggle {
            display: flex;
            justify-content: center;
        }
        
        .toggle-btn {
            border: 1px solid var(--btbg);
            color: var(--btbg);
            padding: 6px 19px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .toggle-btn.active {
            background: var(--btbg);
            color: #000;
        }
        
        .toggle-btn:hover {
            background: var(--btbg);
            color: #000;
        }
        
        .perf-info {
            background: var(--lightbg);
            padding: 10px;
            border-radius: 8px;
            margin-top: 20px;
            text-align: center;
            font-size: 0.9rem;
        }
        
        .value-input {
            background: var(--bg-background);
            border: 1px solid #454559;
            color: var(--text1);
            border-radius: 4px;
            padding: 6px 8px;
            width: 70px;
            text-align: center;
            font-size: 0.95rem;
            outline: none;
        }
        
        .value-input:focus {
            border-color: var(--main-color);
            box-shadow: 0 0 5px rgba(128, 128, 255, 0.5);
        }
        
        .size-toggle {
            display: flex;
            gap: 10px;
        }
        
        .size-toggle .toggle-btn {
            border-radius: 30px;
            padding: 4px 12px;
            font-size: 0.8rem;
        }
        
        #preview3dContainer {
            position: relative;
            width: 100%;
            height: 320px;
            background: #111;
            border-radius: 8px;
            overflow: hidden;
            display: none;
            margin-top: 20px;
        }
        
        #preview3dContainer canvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 8px;
        }
        
        .preview-controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 10;
            display: flex;
        }
        
        .preview-controls .toggle-btn {
            padding: 4px 10px;
            font-size: 0.75rem;
            margin-right: -1px;
        }
        
        .preview-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--text3);
            font-size: 0.9rem;
            text-align: center;
            max-width: 80%;
        }

        .preview-ready {
            display: block !important;
        }
        
        .progress-fill {
            transition: width 0.3s ease-out;
        }

        /* 新增样式 for tabs */
        .map-type-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            background-color: var(--bg-background);
            padding: 5px;
            border-radius: 8px;
        }
        .tab-btn {
            flex-grow: 1;
            padding: 10px 5px;
            cursor: pointer;
            border-radius: 6px;
            border: none;
            background: transparent;
            color: var(--text2);
            font-size: 0.9rem;
            transition: background-color 0.3s, color 0.3s;
            text-align: center;
	height: auto;
        }
        .tab-btn:hover {
            background-color: var(--lightbg);
        }
        .tab-btn.active {
                background-color: var(--btbg);
    		color: var(--lightbg);
            font-weight: bold;
        }
        .param-panel {
            display: none; /* Hide all panels by default */
        }
        .param-panel.active {
            display: block; /* Show active panel */
        }
        /* End of new styles */


        @media (max-width: 768px) {
	.progress-container {
		width: 80%;}
            .content-n {
		    display: flex;
	    	flex-direction: column;
		    padding: 0;}
	.under {
		grid-template-columns: 1fr;
	}
	.container {
		    padding: 20px 0;
		}
            .panel {
                padding: 20px 15px;
                min-width: auto;
            }
            
            .file-upload-area {
                padding: 10px;
            }
            .scrib {
		display: none;
		}
            .controls {
                padding: 15px;
                gap: 8px;
	grid-template-columns: 1fr;
            }
            .example-images {
		gap: 10px;
    		margin-right: 10px;
		}
            button {
                padding: 14px;
                font-size: 1rem;
                min-width: auto;
                width: 80%;
            }
        .toggle-btn{
            font-size: 0.88rem;
        }
	.algorithm-option {
	    padding: 8px 14px;}
        .map-type-tabs {
        }
        .tab-btn {
            font-size: 0.8rem;
        }
        }
    </style>
</head>
<script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "0fa9d31287314fffb488e27ef3d5c9d7"}'></script>
<body>
<div id="global-sidebar"></div>
    <div class="container">
        <header>
            <h1>PBR全流程贴图生成器 <span class="format-badge">法线/置换/AO等</span></h1>
            <p class="header-subtitle">上传灰度图，一键生成多种PBR贴图。法线/AO模式支持GPU加速处理，法线模式支持3D预览</p>
        </header>
        
        <div class="content-n">
            <div class="progress-container" id="progressContainer">
                <div class="quality-indicator">
                    <span><i class="fas fa-sync fa-spin"></i> 处理中...</span>
                    <span id="progressPercent">0%</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>

            <div class="panel">
                <div id="cpuGpuToggleContainer">
                    <div class="mode-toggle">
                        <div class="toggle-btn active" style="border-radius: 30px 0 0 30px;" id="cpuModeBtn">CPU模式 (高精)</div>
                        <div class="toggle-btn" style="border-radius: 0 30px 30px 0;" id="gpuModeBtn">GPU模式 (超快)</div>
                    </div>
                    <div class="perf-info" id="perfInfo">
                        <i class="fas fa-info-circle"></i> 
                        <span>当前模式：<span id="currentMode">CPU模式</span> | 处理时间：<span id="processingTime">0</span>ms</span>
                    </div>
                </div>
                <div class="panel-title">
                    <h2>输入图像<span class="scrib">上传灰度或彩色图像</span></h2>               
                </div>
                
                <div class="file-upload-area" id="inputUploadArea">
                    <label for="fileInput">
                        <i class="fas fa-cloud-upload-alt"></i>
                        <span>点击选择文件或拖放图像到此处</span>
                        <span style="font-size: 0.9rem; color: var(--text3);">支持 JPG, PNG, BMP, TIFF, WEBP 等格式</span>
                    </label>
                    <input type="file" id="fileInput" accept="image/*" style="display: none;">
                </div>
                <div class="line2"></div>
                <div class="panel-title"> 
                    <h2>示例图像 <span class="scrib">点击左侧图标可预览</span></h2>
                </div>
                
                <div style="display: flex; flex-direction: row;">
                    <div class="example-images">
                        <div class="example-image" data-img="bricks">
                            <img src="data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100' viewBox='0 0 100 100'%3e%3crect width='100' height='100' fill='%23333'/%3e%3crect x='0' y='0' width='100' height='10' fill='%23999'/%3e%3crect x='0' y='20' width='100' height='10' fill='%23999'/%3e%3crect x='0' y='40' width='100' height='10' fill='%23999'/%3e%3crect x='0' y='60' width='100' height='10' fill='%23999'/%3e%3crect x='0' y='80' width='100' height='10' fill='%23999'/%3e%3c/svg%3e" alt="砖块">
                            <div class="label">砖块</div>
                        </div>
                        <div class="example-image" data-img="cobblestone">
                            <img src="data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100' viewBox='0 0 100 100'%3e%3crect width='100' height='100' fill='%23333'/%3e%3cellipse cx='30' cy='30' rx='15' ry='15' fill='%23999'/%3e%3cellipse cx='70' cy='30' rx='15' ry='15' fill='%23999'/%3e%3cellipse cx='30' cy='70' rx='15' ry='15' fill='%23999'/%3e%3cellipse cx='70' cy='70' rx='15' ry='15' fill='%23999'/%3e%3cellipse cx='50' cy='50' rx='20' ry='20' fill='%23ccc'/%3e%3c/svg%3e" alt="鹅卵石">
                            <div class="label">鹅卵石</div>
                        </div>
                        <div class="example-image" data-img="metal">
                            <img src="data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100' viewBox='0 0 100 100'%3e%3crect width='100' height='100' fill='%23333'/%3e%3crect x='10' y='10' width='80' height='80' fill='%23666'/%3e%3crect x='20' y='20' width='60' height='60' fill='%23999'/%3e%3crect x='30' y='30' width='40' height='40' fill='%23ccc'/%3e%3c/svg%3e" alt="金属板">
                            <div class="label">金属板</div>
                        </div>
                        <div class="example-image" data-img="rock">
                            <img src="data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100' viewBox='0 0 100 100'%3e%3crect width='100' height='100' fill='%23333'/%3e%3cpath d='M20,30 Q40,10 60,30 Q80,50 60,70 Q40,90 20,70 Q10,50 20,30' fill='%23999'/%3e%3c/svg%3e" alt="岩石">
                            <div class="label">岩石</div>
                        </div>
                    </div>
                    
                    <div class="canvas-container" id="inputCanvasContainer">
                        <canvas id="inputCanvas"></canvas>
                        <div id="inputPlaceholder" class="placeholder">
                            <i class="fas fa-cloud-upload-alt"></i>
                            请上传灰度图或选择示例图像
                        </div>
                    </div>
                </div>

                <div style="display: flex; justify-content: center; margin-top: 15px;">
                    <button id="downloadGrayBtn" class="button" style="background: var(--btcolor);">
                        <i class="fas fa-download"></i> 下载灰度图
                    </button>
                </div>
            </div>
            
            <div class="panel">
                <div class="map-type-tabs">
                    <button class="tab-btn active" data-map-type="normal">nor法线</button>
                    <button class="tab-btn" data-map-type="displacement">disp置换/凹凸</button>
                    <button class="tab-btn" data-map-type="ao">AO(OCC)</button>
                    <button class="tab-btn" data-map-type="reflection">ref反射</button>
                    <button class="tab-btn" data-map-type="glossiness">gloss光泽度</button>
                </div>

                <div id="normalParams" class="param-panel active">
                    <div class="panel-title" style="margin-top: 0;">
                        <h2>法线参数设置<span class="scrib">强度和方向调节</span></h2>
                    </div>
                    <div class="kuang">
                        <div class="controls">
                            <div class="control-group">
                                <label for="strengthSlider">法线强度: 
                                    <input type="text" id="strengthValue" class="value-input" value="0.10">
                                </label>
                                <input type="range" id="strengthSlider" min="0.01" max="0.5" step="0.01" value="0.10">
                                <div class="param-info">
                                    <span class="canshu">柔和</span>
                                    <span class="canshu">强烈</span>
                                </div>
                            </div>
                            <div class="control-group">
                                <label for="blurSlider">模糊程度: 
                                    <input type="text" id="blurValue" class="value-input" value="0.0">
                                </label>
                                <input type="range" id="blurSlider" min="0" max="5" step="0.1" value="0">
                                <div class="param-info">
                                    <span class="canshu">锐利</span>
                                    <span class="canshu">模糊</span>
                                </div>
                            </div>
                        </div>
                        <div class="line"></div>
                        <div class="controls" style="display: flex;">
                            <div class="control-group"><label for="invertX"><input type="checkbox" id="invertX"> 反转X方向</label></div>
                            <div class="control-group"><label for="invertY"><input type="checkbox" id="invertY" checked> 反转Y方向</label></div>
                            <div class="control-group"><label for="highQuality"><input type="checkbox" id="highQuality" checked> 高质量模式</label></div>
                        </div>
                    </div>
                </div>

                <div id="displacementParams" class="param-panel">
                     <div class="panel-title" style="margin-top: 0;">
                        <h2>置换参数设置<span class="scrib">控制高度和细节</span></h2>
                    </div>
                    <div class="kuang">
                        <div class="controls">
                            <div class="control-group">
                                <label>强度: <input type="text" id="dispStrengthValue" class="value-input" value="1.0"></label>
                                <input type="range" id="dispStrengthSlider" min="0" max="2" step="0.05" value="1.0">
                                <div class="param-info"><span>弱</span><span>强</span></div>
                            </div>
                            <div class="control-group">
                                <label>细节层次: <input type="text" id="dispLevelValue" class="value-input" value="0.5"></label>
                                <input type="range" id="dispLevelSlider" min="0" max="1" step="0.05" value="0.5">
                                <div class="param-info"><span>低</span><span>高</span></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="aoParams" class="param-panel">
                    <div class="panel-title" style="margin-top: 0;">
                        <h2>AO参数设置<span class="scrib">控制遮蔽效果</span></h2>
                    </div>
                    <div class="kuang">
                        <div class="controls">
                            <div class="control-group">
                                <label>强度: <input type="text" id="aoStrengthValue" class="value-input" value="1.0"></label>
                                <input type="range" id="aoStrengthSlider" min="0" max="5" step="0.1" value="1.0">
                                <div class="param-info"><span>弱</span><span>强</span></div>
                            </div>
                            <div class="control-group">
                                <label>范围: <input type="text" id="aoSpreadValue" class="value-input" value="10"></label>
                                <input type="range" id="aoSpreadSlider" min="1" max="50" step="1" value="10">
                                <div class="param-info"><span>小</span><span>大</span></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div id="reflectionParams" class="param-panel">
                    <div class="panel-title" style="margin-top: 0;">
                        <h2>反射参数设置<span class="scrib">控制反射强度</span></h2>
                    </div>
                    <div class="kuang">
                        <div class="controls">
                            <div class="control-group">
                                <label>强度: <input type="text" id="reflectStrengthValue" class="value-input" value="1.0"></label>
                                <input type="range" id="reflectStrengthSlider" min="0" max="2" step="0.05" value="1.0">
                                 <div class="param-info"><span>弱</span><span>强</span></div>
                            </div>
                            <div class="control-group">
                                <label>对比度: <input type="text" id="reflectContrastValue" class="value-input" value="1.0"></label>
                                <input type="range" id="reflectContrastSlider" min="0" max="3" step="0.05" value="1.0">
                                <div class="param-info"><span>低</span><span>高</span></div>
                            </div>
                        </div>
                         <div class="line"></div>
                        <div class="controls" style="display: flex;">
                             <div class="control-group"><label><input type="checkbox" id="reflectInvert"> 反相</label></div>
                        </div>
                    </div>
                </div>
                
                <div id="glossinessParams" class="param-panel">
                     <div class="panel-title" style="margin-top: 0;">
                        <h2>光泽度参数设置<span class="scrib">控制表面光滑度</span></h2>
                    </div>
                    <div class="kuang">
                         <div class="controls">
                            <div class="control-group">
                                <label>强度: <input type="text" id="glossStrengthValue" class="value-input" value="1.0"></label>
                                <input type="range" id="glossStrengthSlider" min="0" max="2" step="0.05" value="1.0">
                                <div class="param-info"><span>弱</span><span>强</span></div>
                            </div>
                            <div class="control-group">
                                <label>对比度: <input type="text" id="glossContrastValue" class="value-input" value="1.0"></label>
                                <input type="range" id="glossContrastSlider" min="0" max="3" step="0.05" value="1.0">
                                <div class="param-info"><span>低</span><span>高</span></div>
                            </div>
                        </div>
                        <div class="line"></div>
                        <div class="controls" style="display: flex;">
                           <div class="control-group"><label><input type="checkbox" id="glossInvert" checked> 反相</label></div>
                        </div>
                    </div>
                </div>


                <div class="btn-group">
                    <button id="resetParamsBtn" class="toggle-btn">
                        <i class="fas fa-redo"></i> 重置参数
                    </button>

                    <button id="downloadMapBtn">
                        <i class="fas fa-download"></i> <span>下载法线图</span>
                    </button>
                </div>
                
                <div class="mode-toggle" style="width: 100%;" id="previewModeToggle">
                    <div class="toggle-btn active" id="normalPreviewBtn" style="width: 50%; border-radius: 30px 0 0 30px;">2D预览</div>
                    <div class="toggle-btn" id="modelPreviewBtn" style="width: 50%; border-radius: 0 30px 30px 0;">3D模型预览</div>
                </div>
                
                <div class="panel-title" style="justify-content: space-between;" id="outputPreviewTitleContainer"> 
                    <h2 id="previewTitle">法线图预览<span class="scrib">支持大小图切换</span></h2>
                    
                   <div class="size-toggle">
                        <div class="toggle-btn active" id="smallSizeBtn">小图</div>
                        <div class="toggle-btn" id="largeSizeBtn">大图</div>
                    </div>
                </div>

                <div class="canvas-container" id="outputCanvasContainer">
                    <canvas id="outputCanvas"></canvas>
                    <div id="outputPlaceholder" class="placeholder">
                        生成的贴图将显示在这里
                    </div>
                </div>
                
                <div id="preview3dContainer">
                    <div class="preview-hint" id="previewHint">
                        <i class="fas fa-cube"></i>
                        <p>使用鼠标左键旋转模型，滚轮缩放</p>
                    </div>
                    <div class="preview-controls">
                        <div class="toggle-btn active" data-shape="box" style="border-radius: 8px 0 0 8px;">立方体</div>
                        <div class="toggle-btn" data-shape="sphere">球体</div>
                        <div class="toggle-btn" data-shape="cylinder">圆柱</div>
                        <div class="toggle-btn" data-shape="torus" style="border-radius: 0 8px 8px 0;">圆环</div>
                    </div>
                </div>
                
                <div id="reverseSection">
                    <div class="panel-title">
                        <h2>反推灰度图<span class="scrib">拖拽法线图上传反推出灰度图</span></h2>
                        <button id="reverseBtn" class="toggle-btn" style="font-size: 14px; height: 38px; width: 120px;">
                            一键反推
                        </button>
                    </div>

                    <div class="kuang" style="display: flex; align-items: center; padding-left: 20px;">反推算法
                        <div class="algorithm-option">
                            <input type="radio" id="poissonAlgorithm" name="algorithm" value="poisson" checked>
                            <label for="poissonAlgorithm">Poisson重建算法 (推荐)</label>
                        </div>
                        
                        <div class="algorithm-option">
                            <input type="radio" id="simpleAlgorithm" name="algorithm" value="simple">
                            <label for="simpleAlgorithm">简单累加算法 (旧版)</label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    <div class="panel">
<h2>通道贴图对应关系</h2>
	<div class="under">
	<li>diff-漫反射（COL）</li>
	<li>nor-法线（NRM）</li>
	<li>disp-置换（DIS）</li>
	<li>AO-环境吸收（OCC）</li>
	<li>reflection/specular-反射/高光（REF）</li>
	<li>glossiness-光泽度</li>
	<li>bump/height-黑白凹凸、高度图</li>
	<li>metalness-金属度（Metallic）</li>
	<li>roungh-粗糙度（金属度的粗糙度）</li>
	<li>curvature-曲率</li>
	</div>
</div>
	
    </div>

    <div id="inputModal" class="modal">
        <span class="close">&times;</span>
        <img class="modal-content" id="inputModalImg">
    </div>
    
    <div id="outputModal" class="modal">
        <span class="close">&times;</span>
        <img class="modal-content" id="outputModalImg">
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // 获取DOM元素
            const fileInput = document.getElementById('fileInput');
            const inputCanvas = document.getElementById('inputCanvas');
            const outputCanvas = document.getElementById('outputCanvas');
            const inputPlaceholder = document.getElementById('inputPlaceholder');
            const outputPlaceholder = document.getElementById('outputPlaceholder');
            const downloadMapBtn = document.getElementById('downloadMapBtn');
            const downloadMapBtnText = downloadMapBtn.querySelector('span');
            const resetParamsBtn = document.getElementById('resetParamsBtn');
            const reverseBtn = document.getElementById('reverseBtn');
            const exampleImages = document.querySelectorAll('.example-image');
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const progressPercent = document.getElementById('progressPercent');
            const inputUploadArea = document.getElementById('inputUploadArea');
            const poissonAlgorithm = document.getElementById('poissonAlgorithm');
            const simpleAlgorithm = document.getElementById('simpleAlgorithm');
            const cpuModeBtn = document.getElementById('cpuModeBtn');
            const gpuModeBtn = document.getElementById('gpuModeBtn');
            const perfInfo = document.getElementById('perfInfo');
            const currentModeSpan = document.getElementById('currentMode');
            const processingTimeSpan = document.getElementById('processingTime');
            const smallSizeBtn = document.getElementById('smallSizeBtn');
            const largeSizeBtn = document.getElementById('largeSizeBtn');
            const outputCanvasContainer = document.getElementById('outputCanvasContainer');
            const previewTitle = document.getElementById('previewTitle');
            const cpuGpuToggleContainer = document.getElementById('cpuGpuToggleContainer');
            const reverseSection = document.getElementById('reverseSection');
            const previewModeToggle = document.getElementById('previewModeToggle');
            const outputPreviewTitleContainer = document.getElementById('outputPreviewTitleContainer');


            // 新增3D预览相关元素
            const normalPreviewBtn = document.getElementById('normalPreviewBtn');
            const modelPreviewBtn = document.getElementById('modelPreviewBtn');
            const preview3dContainer = document.getElementById('preview3dContainer');
            const previewHint = document.getElementById('previewHint');
            const shapeButtons = document.querySelectorAll('.preview-controls .toggle-btn');
            
            // 模态框元素
            const inputModal = document.getElementById('inputModal');
            const outputModal = document.getElementById('outputModal');
            const inputModalImg = document.getElementById('inputModalImg');
            const outputModalImg = document.getElementById('outputModalImg');
            const closeBtns = document.querySelectorAll('.close');
            
            // Canvas容器元素
            const inputCanvasContainer = document.getElementById('inputCanvasContainer');

            // --- 新增：Tab和参数面板元素 ---
            const mapTypeTabs = document.querySelectorAll('.tab-btn');
            const paramPanels = document.querySelectorAll('.param-panel');
            
            // 法线参数
            const strengthSlider = document.getElementById('strengthSlider');
            const blurSlider = document.getElementById('blurSlider');
            const strengthValueInput = document.getElementById('strengthValue');
            const blurValueInput = document.getElementById('blurValue');
            const invertX = document.getElementById('invertX');
            const invertY = document.getElementById('invertY');
            const highQuality = document.getElementById('highQuality');
            
            // 置换参数
            const dispStrengthSlider = document.getElementById('dispStrengthSlider');
            const dispLevelSlider = document.getElementById('dispLevelSlider');
            const dispStrengthValue = document.getElementById('dispStrengthValue');
            const dispLevelValue = document.getElementById('dispLevelValue');

            // AO参数
            const aoStrengthSlider = document.getElementById('aoStrengthSlider');
            const aoSpreadSlider = document.getElementById('aoSpreadSlider');
            const aoStrengthValue = document.getElementById('aoStrengthValue');
            const aoSpreadValue = document.getElementById('aoSpreadValue');

            // 反射参数
            const reflectStrengthSlider = document.getElementById('reflectStrengthSlider');
            const reflectContrastSlider = document.getElementById('reflectContrastSlider');
            const reflectInvert = document.getElementById('reflectInvert');
            const reflectStrengthValue = document.getElementById('reflectStrengthValue');
            const reflectContrastValue = document.getElementById('reflectContrastValue');

            // 光泽度参数
            const glossStrengthSlider = document.getElementById('glossStrengthSlider');
            const glossContrastSlider = document.getElementById('glossContrastSlider');
            const glossInvert = document.getElementById('glossInvert');
            const glossStrengthValue = document.getElementById('glossStrengthValue');
            const glossContrastValue = document.getElementById('glossContrastValue');

            let currentMapType = 'normal'; // 'normal', 'displacement', 'ao', etc.
            let originalWidth = 0;
            let originalHeight = 0;
            let currentImageData = null;
            let blurredImageData = null;
            let updateTimeout = null;
            let useGPU = false;
            let gl = null;
            let normalMapProgram = null;
            let aoMapProgram = null; 
            let progressInterval = null;
            
            // Three.js相关变量
            let scene, camera, renderer, mesh, controls;
            let currentNormalMap = null;
            let currentShape = 'box';
            let is3dPreviewActive = false;
            let isThreeInitialized = false; // 标记Three.js是否已初始化
            let animationId = null;

            // --- 核心逻辑 ---

            function scheduleMapUpdate() {
                if (updateTimeout) {
                    clearTimeout(updateTimeout);
                }
                
                updateTimeout = setTimeout(() => {
                    if (currentImageData) {
                        generateMap();
                    }
                }, 300);
            }

            // 总的生成函数
            function generateMap() {
                 if (!currentImageData) return;
                
                progressContainer.style.display = 'block';
                progressFill.style.width = '0%';
                progressPercent.textContent = '0%';
                
                const startTime = performance.now();

                // 模糊预处理（仅用于法线贴图）
                if (currentMapType === 'normal') {
                    const blurLevel = parseFloat(blurSlider.value);
                    if (blurLevel > 0) {
                        blurredImageData = new Uint8ClampedArray(currentImageData.data);
                        applyBlur(blurredImageData, originalWidth, originalHeight, blurLevel);
                    } else {
                        blurredImageData = new Uint8ClampedArray(currentImageData.data);
                    }
                } else {
                     blurredImageData = new Uint8ClampedArray(currentImageData.data);
                }


                let processFunction;
                switch(currentMapType) {
                    case 'normal':
                        processFunction = useGPU ? convertWithGPU : convertWithCPU;
                        break;
                    case 'displacement':
                        processFunction = convertToDisplacementMap;
                        break;
                    case 'ao':
                        processFunction = useGPU ? convertAOMapWithGPU : convertToAOMap;
                        break;
                    case 'reflection':
                        processFunction = convertToReflectionMap;
                        break;
                    case 'glossiness':
                        processFunction = convertToGlossinessMap;
                        break;
                }
                
                // 执行生成
                if(processFunction) {
                   processFunction();
                }

                const endTime = performance.now();
                const elapsed = endTime - startTime;
                
                // 更新UI (GPU模式有自己的计时器，所以这里排除)
                const isGpuMode = useGPU && (currentMapType === 'normal' || currentMapType === 'ao');
                if (!isGpuMode) {
                    processingTimeSpan.textContent = elapsed.toFixed(2);
                    setTimeout(() => {
                        progressContainer.style.display = 'none';
                    }, 500);
                }

                outputPlaceholder.style.display = 'none';
                outputCanvas.style.display = 'block';

                 // 更新3D预览（如果激活且是法线模式）
                if (is3dPreviewActive && currentMapType === 'normal') {
                    update3dPreview();
                }
            }
            
            // --- UI 更新与模式切换 ---
            
            function updateUIAfterTabSwitch() {
                let mapName = "法线";
                switch(currentMapType) {
                    case 'displacement': mapName = '置换'; break;
                    case 'ao': mapName = 'AO'; break;
                    case 'reflection': mapName = '反射'; break;
                    case 'glossiness': mapName = '光泽度'; break;
                }

                previewTitle.childNodes[0].nodeValue = `${mapName}图预览`;
                downloadMapBtnText.textContent = `下载${mapName}图`;
                
                // 只有法线图和AO图支持GPU加速
                const canUseGPU = currentMapType === 'normal' || currentMapType === 'ao';
                cpuGpuToggleContainer.style.display = canUseGPU ? 'block' : 'none';

                // 只有法线图支持反推和3D预览
                const isNormalMode = currentMapType === 'normal';
                reverseSection.style.display = isNormalMode ? 'block' : 'none';
                previewModeToggle.style.display = isNormalMode ? 'flex' : 'none';

                // 如果从法线模式切换走，且3D预览是激活的，则切回2D
                if (!isNormalMode && is3dPreviewActive) {
                    normalPreviewBtn.click();
                }

                // 如果不是法线模式，确保2D预览区是可见的
                if (!isNormalMode) {
                    outputPreviewTitleContainer.style.display = 'flex';
                    outputCanvasContainer.style.display = 'flex';
                }

                scheduleMapUpdate();
            }

            mapTypeTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // 移除所有 active class
                    mapTypeTabs.forEach(t => t.classList.remove('active'));
                    paramPanels.forEach(p => p.classList.remove('active'));
                    
                    // 添加 active class 到点击的tab和对应的panel
                    tab.classList.add('active');
                    currentMapType = tab.dataset.mapType;
                    const activePanel = document.getElementById(`${currentMapType}Params`);
                    if (activePanel) {
                        activePanel.classList.add('active');
                    }
                    
                    updateUIAfterTabSwitch();
                });
            });

            // 初始化Three.js场景
            function initThreeScene() {
                // 创建场景
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1a1b1c);
                
                // 创建相机
                camera = new THREE.PerspectiveCamera(75, preview3dContainer.clientWidth / preview3dContainer.clientHeight, 0.1, 1000);
                camera.position.z = 3;
                
                // 创建渲染器
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(preview3dContainer.clientWidth, preview3dContainer.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                preview3dContainer.appendChild(renderer.domElement);
                
                // 添加光源
                const ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(1, 1, 1);
                scene.add(directionalLight);
                
                // 添加点光源
                const pointLight1 = new THREE.PointLight(0xffe7db, 1, 100);
                pointLight1.position.set(5, 5, 5);
                scene.add(pointLight1);
                
                const pointLight2 = new THREE.PointLight(0xadb7ff, 1, 100);
                pointLight2.position.set(-5, -5, -5);
                scene.add(pointLight2);
                
                // 创建初始网格（立方体）
                createMesh('box');
                
                // 添加轨道控制器
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                
                // 处理窗口大小变化
                window.addEventListener('resize', () => {
                    if (is3dPreviewActive) {
                        updateRendererSize();
                    }
                });
                
                // 标记为已初始化
                isThreeInitialized = true;
            }
            
            // 更新渲染器尺寸
            function updateRendererSize() {
                if (!renderer || !preview3dContainer) return;
                
                const width = preview3dContainer.clientWidth;
                const height = preview3dContainer.clientHeight;
                
                // 避免尺寸为0
                if (width === 0 || height === 0) {
                    return;
                }
                
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            }
            
            // 创建网格
            function createMesh(shape) {
                currentShape = shape;
                
                // 移除现有网格
                if (mesh) {
                    scene.remove(mesh);
                }
                
                let geometry;
                
                switch(shape) {
                    case 'sphere':
                        geometry = new THREE.SphereGeometry(1.5, 32, 32);
                        break;
                    case 'cylinder':
                        geometry = new THREE.CylinderGeometry(1, 1, 2, 32);
                        break;
                    case 'torus':
                        geometry = new THREE.TorusGeometry(1.5, 0.5, 16, 100);
                        break;
                    case 'box':
                    default:
                        geometry = new THREE.BoxGeometry(2, 2, 2);
                        break;
                }
                
                // 创建材质
                const material = new THREE.MeshPhongMaterial({
                    color: 0x808080,
                    shininess: 30,
                    side: THREE.DoubleSide
                });
                
                // 应用法线贴图（如果存在）
                if (currentNormalMap) {
                    material.normalMap = currentNormalMap;
                    material.normalScale.set(1, 1);
                }
                
                // 创建网格
                mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);
            }
            
            // 更新法线贴图
            function updateNormalMap(texture) {
                if (!mesh) return;
                
                currentNormalMap = texture;
                
                // 更新材质
                if (mesh.material) {
                    mesh.material.normalMap = texture;
                    mesh.material.needsUpdate = true;
                }
            }
            
            // 动画循环
            function animate() {
                animationId = requestAnimationFrame(animate);
                
                if (controls) {
                    controls.update();
                }
                
                if (mesh && is3dPreviewActive) { // 检查是否处于3D预览模式
                    // 添加轻微旋转
                    mesh.rotation.x += 0.002;
                    mesh.rotation.y += 0.003;
                }
                
                renderer.render(scene, camera);
            }
            
            // 设置GPU模式
            function setGPUMode(enabled) {
                useGPU = enabled;
                if (useGPU) {
                    gpuModeBtn.classList.add('active');
                    cpuModeBtn.classList.remove('active');
                    currentModeSpan.textContent = "GPU模式";
                    
                    // 初始化WebGL (如果还没初始化)
                    if (!gl) {
                       initWebGL();
                    }
                } else {
                    gpuModeBtn.classList.remove('active');
                    cpuModeBtn.classList.add('active');
                    currentModeSpan.textContent = "CPU模式";
                }
                scheduleMapUpdate();
            }
            
            // 初始化WebGL
            function initWebGL() {
                try {
                    // 创建离屏Canvas用于WebGL处理
                    const glCanvas = document.createElement('canvas');
                    gl = glCanvas.getContext('webgl') || glCanvas.getContext('experimental-webgl');
                    
                    if (!gl) {
                        console.log('WebGL初始化失败，将使用CPU模式');
                        setGPUMode(false);
                        return;
                    }
                    
                    // 通用顶点着色器
                    const vertexShaderSource = `
                        attribute vec2 a_position;
                        attribute vec2 a_texCoord;
                        varying vec2 v_texCoord;
                        void main() {
                            gl_Position = vec4(a_position, 0.0, 1.0);
                            v_texCoord = a_texCoord;
                        }
                    `;
                    
                    // 法线贴图片段着色器
                    const normalFragmentShaderSource = `
                        precision mediump float;
                        uniform sampler2D u_image;
                        uniform float u_strength;
                        uniform float u_invertX;
                        uniform float u_invertY;
                        uniform vec2 u_resolution;
                        
                        varying vec2 v_texCoord;
                        
                        void main() {
                            // 获取周围像素的高度值
                            float left = texture2D(u_image, v_texCoord + vec2(-1.0/u_resolution.x, 0.0)).r;
                            float right = texture2D(u_image, v_texCoord + vec2(1.0/u_resolution.x, 0.0)).r;
                            float top = texture2D(u_image, v_texCoord + vec2(0.0, -1.0/u_resolution.y)).r;
                            float bottom = texture2D(u_image, v_texCoord + vec2(0.0, 1.0/u_resolution.y)).r;
                            
                            // 计算梯度
                            float dx = (right - left) * u_strength * 10.0;
                            float dy = (bottom - top) * u_strength * 10.0;
                            
                            // 应用方向反转
                            dx *= u_invertX;
                            dy *= u_invertY;
                            
                            // 计算法线向量
                            vec3 normal = normalize(vec3(dx, dy, 1.0));
                            
                            // 映射到0-1范围
                            normal = (normal + 1.0) * 0.5;
                            
                            gl_FragColor = vec4(normal, 1.0);
                        }
                    `;

                    // ================= 修复点: 全新设计的、高效的AO片段着色器 =================
                    const aoFragmentShaderSource = `
                        precision mediump float;

                        uniform sampler2D u_image;
                        uniform vec2 u_resolution;
                        uniform float u_strength;
                        uniform float u_spread; 

                        varying vec2 v_texCoord;

                        const float PI = 3.14159265359;
                        const int SAMPLE_COUNT = 24; // 使用固定的样本数量

                        float getHeight(vec2 coord) {
                            return texture2D(u_image, coord).r;
                        }

                        void main() {
                            float centerHeight = getHeight(v_texCoord);
                            float occlusion = 0.0;
                            vec2 texelSize = 1.0 / u_resolution;
                            
                            // spread 现在控制采样半径，而不是循环次数
                            float radius = u_spread * texelSize.x;

                            // 在一个圆环上进行8次采样
                            for (int i = 0; i < SAMPLE_COUNT; i++) {
                                float angle = float(i) / float(SAMPLE_COUNT) * 2.0 * PI;
                                vec2 offset = vec2(cos(angle), sin(angle)) * radius;
                                
                                float sampleHeight = getHeight(v_texCoord + offset);
                                float heightDiff = sampleHeight - centerHeight;
                                
                                if (heightDiff > 0.0) {
                                    // 一个简化的遮蔽计算，将高度差的影响放大并限制
                                    occlusion += clamp(heightDiff * 50.0, 0.0, 1.0);
                                }
                            }
                            
                            // 根据样本数进行归一化
                            occlusion /= float(SAMPLE_COUNT);

                            // 应用强度并翻转、限制范围
                            float aoValue = 1.0 - clamp(occlusion * u_strength, 0.0, 1.0);

                            gl_FragColor = vec4(aoValue, aoValue, aoValue, 1.0);
                        }
                    `;
                    
                    // 创建法线着色器程序
                    normalMapProgram = createProgram(gl, vertexShaderSource, normalFragmentShaderSource);
                    if (!normalMapProgram) {
                        console.error('法线贴图 WebGL 程序创建失败，退回到CPU模式');
                        setGPUMode(false);
                        return;
                    }
                    
                    // 创建 AO 着色器程序
                    aoMapProgram = createProgram(gl, vertexShaderSource, aoFragmentShaderSource);
                     if (!aoMapProgram) {
                        console.error('AO贴图 WebGL 程序创建失败，AO模式将仅使用CPU');
                    }
                    
                    console.log('WebGL初始化成功');
                } catch (e) {
                    console.error('WebGL初始化错误:', e);
                    setGPUMode(false);
                }
            }
            
            // 创建WebGL程序
            function createProgram(gl, vertexSource, fragmentSource) {
                const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
                
                if (!vertexShader || !fragmentShader) {
                    return null;
                }
                
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('无法链接程序:', gl.getProgramInfoLog(program));
                    gl.deleteProgram(program);
                    return null;
                }
                
                return program;
            }
            
            // 创建着色器
            function createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('无法编译着色器:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }
            
            // 模式切换按钮事件
            cpuModeBtn.addEventListener('click', () => setGPUMode(false));
            gpuModeBtn.addEventListener('click', () => setGPUMode(true));
            
            // 大小图切换功能
            smallSizeBtn.addEventListener('click', () => {
                smallSizeBtn.classList.add('active');
                largeSizeBtn.classList.remove('active');
                outputCanvasContainer.style.maxHeight = '320px';
                outputCanvas.style.maxHeight = '320px';
            });
            
            largeSizeBtn.addEventListener('click', () => {
                largeSizeBtn.classList.add('active');
                smallSizeBtn.classList.remove('active');
                outputCanvasContainer.style.maxHeight = '600px';
                outputCanvas.style.maxHeight = '600px';
            });
            
            // ---  通用参数绑定 ---
            function bindSliderToInput(slider, input, scheduleUpdate, isFloat=true) {
                slider.addEventListener('input', () => {
                    input.value = slider.value;
                    scheduleUpdate();
                });
                input.addEventListener('input', () => {
                     let value = isFloat ? parseFloat(input.value) : parseInt(input.value);
                    if (isNaN(value)) return;
                    slider.value = value;
                    const min = parseFloat(slider.min);
                    const max = parseFloat(slider.max);
                    if (value < min) slider.min = value;
                    if (value > max) slider.max = value;
                    scheduleUpdate();
                });
            }

            // 绑定所有参数
            bindSliderToInput(strengthSlider, strengthValueInput, scheduleMapUpdate);
            bindSliderToInput(blurSlider, blurValueInput, scheduleMapUpdate);
            bindSliderToInput(dispStrengthSlider, dispStrengthValue, scheduleMapUpdate);
            bindSliderToInput(dispLevelSlider, dispLevelValue, scheduleMapUpdate);
            bindSliderToInput(aoStrengthSlider, aoStrengthValue, scheduleMapUpdate);
            bindSliderToInput(aoSpreadSlider, aoSpreadValue, scheduleMapUpdate, false);
            bindSliderToInput(reflectStrengthSlider, reflectStrengthValue, scheduleMapUpdate);
            bindSliderToInput(reflectContrastSlider, reflectContrastValue, scheduleMapUpdate);
            bindSliderToInput(glossStrengthSlider, glossStrengthValue, scheduleMapUpdate);
            bindSliderToInput(glossContrastSlider, glossContrastValue, scheduleMapUpdate);

            // Checkboxes
            [invertX, invertY, highQuality, reflectInvert, glossInvert].forEach(checkbox => {
                checkbox.addEventListener('change', scheduleMapUpdate);
            });
            
            // 示例图像点击事件
            exampleImages.forEach(img => {
                img.addEventListener('click', () => {
                    const imgType = img.dataset.img;
                    generateExampleImage(imgType);
                    scheduleMapUpdate();
                });
            });
            
            // 重置参数按钮
            resetParamsBtn.addEventListener('click', () => {
                // 重置法线参数
                strengthSlider.value = 0.10; strengthValueInput.value = '0.10';
                blurSlider.value = 0; blurValueInput.value = '0.0';
                invertX.checked = false;
                invertY.checked = true;
                highQuality.checked = true;
                // 重置其他参数...
                dispStrengthSlider.value = 1.0; dispStrengthValue.value = '1.0';
                dispLevelSlider.value = 0.5; dispLevelValue.value = '0.5';
                aoStrengthSlider.value = 1.0; aoStrengthValue.value = '1.0';
                aoSpreadSlider.value = 10; aoSpreadValue.value = '10';
                reflectStrengthSlider.value = 1.0; reflectStrengthValue.value = '1.0';
                reflectContrastSlider.value = 1.0; reflectContrastValue.value = '1.0';
                reflectInvert.checked = false;
                glossStrengthSlider.value = 1.0; glossStrengthValue.value = '1.0';
                glossContrastSlider.value = 1.0; glossContrastValue.value = '1.0';
                glossInvert.checked = true;
                
                scheduleMapUpdate();
            });
            
            // 文件上传处理
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                loadImageFile(file);
            });
            
            // 加载图像文件
            function loadImageFile(file) {
                const validTypes = ['image/jpeg', 'image/png', 'image/bmp', 'image/tiff', 'image/webp', 'image/gif'];
                
                // 检查是否为TIFF格式
                if (file.type === 'image/tiff' || file.name.toLowerCase().endsWith('.tif') || file.name.toLowerCase().endsWith('.tiff')) {
                    // 使用UTIF.js处理TIFF文件
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const arrayBuffer = event.target.result;
                            const ifds = UTIF.decode(arrayBuffer);
                            
                            // 获取第一个图像
                            UTIF.decodeImage(arrayBuffer, ifds[0]);
                            const width = ifds[0].width;
                            const height = ifds[0].height;
                            
                            // 将TIFF转换为RGBA格式
                            const rgba = UTIF.toRGBA8(ifds[0]);
                            
                            // 创建ImageData对象
                            const imageData = new ImageData(width, height);
                            imageData.data.set(new Uint8ClampedArray(rgba));
                            
                            // 更新canvas
                            inputCanvas.width = width;
                            inputCanvas.height = height;
                            const ctx = inputCanvas.getContext('2d');
                            ctx.putImageData(imageData, 0, 0);
                            
                            inputPlaceholder.style.display = 'none';
                            inputCanvas.style.display = 'block';
                            
                            // 存储图像数据
                            originalWidth = width;
                            originalHeight = height;
                            currentImageData = ctx.getImageData(0, 0, width, height);
                            blurredImageData = new Uint8ClampedArray(currentImageData.data);
                            
                            // 立即更新法线图
                            scheduleMapUpdate();
                        } catch (error) {
                            console.error('TIFF处理错误:', error);
                            alert('无法处理此TIFF文件，请尝试其他文件');
                        }
                    };
                    reader.readAsArrayBuffer(file);
                } else if (validTypes.includes(file.type)) {
                    // 处理其他图像格式
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            // 存储原始尺寸
                            originalWidth = img.width;
                            originalHeight = img.height;
                            
                            // 设置canvas为原始尺寸
                            inputCanvas.width = originalWidth;
                            inputCanvas.height = originalHeight;
                            
                            const ctx = inputCanvas.getContext('2d');
                            ctx.clearRect(0, 0, originalWidth, originalHeight);
                            ctx.drawImage(img, 0, 0);
                            
                            inputPlaceholder.style.display = 'none';
                            inputCanvas.style.display = 'block';
                            
                            // 存储图像数据
                            currentImageData = ctx.getImageData(0, 0, originalWidth, originalHeight);
                            // 初始化模糊图像数据
                            blurredImageData = new Uint8ClampedArray(currentImageData.data);
                            
                            // 立即更新法线图
                            scheduleMapUpdate();
                        };
                        img.onerror = () => {
                            alert('图片加载失败，请重试');
                        };
                        img.src = event.target.result;
                    };
                    reader.onerror = () => {
                        alert('文件读取失败');
                    };
                    reader.readAsDataURL(file);
                } else {
                    alert('不支持的图片格式，请上传JPG, PNG, BMP, TIFF或WEBP格式的图片');
                }
            }
            
            // 下载按钮事件
            downloadMapBtn.addEventListener('click', () => {
                if (outputCanvas.style.display === 'none') {
                    alert('请先生成贴图');
                    return;
                }
                
                const link = document.createElement('a');
                link.download = `${currentMapType}-map.png`;
                link.href = outputCanvas.toDataURL('image/png');
                link.click();
            });

            // 下载灰度图按钮事件
            document.getElementById('downloadGrayBtn').addEventListener('click', () => {
                if (inputCanvas.style.display === 'none') {
                    alert('请先上传或生成灰度图');
                    return;
                }
                
                const link = document.createElement('a');
                link.download = 'height-map.png';
                link.href = inputCanvas.toDataURL('image/png');
                link.click();
            });

            // 图像放大功能
            inputCanvasContainer.addEventListener('click', () => {
                if (inputCanvas.style.display === 'none') return;
                
                inputModalImg.src = inputCanvas.toDataURL('image/png');
                inputModal.style.display = 'flex';
            });
            
            outputCanvasContainer.addEventListener('click', () => {
                if (outputCanvas.style.display === 'none') return;
                
                outputModalImg.src = outputCanvas.toDataURL('image/png');
                outputModal.style.display = 'flex';
            });
            
            // 关闭模态框
            closeBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    inputModal.style.display = 'none';
                    outputModal.style.display = 'none';
                });
            });
            
            // 点击模态框外部关闭
            window.addEventListener('click', (e) => {
                if (e.target === inputModal) inputModal.style.display = 'none';
                if (e.target === outputModal) outputModal.style.display = 'none';
            });
            
            // 生成示例图像
            function generateExampleImage(type) {
                const ctx = inputCanvas.getContext('2d');
                const width = 512;
                const height = 512;
                
                // 更新canvas尺寸
                inputCanvas.width = width;
                inputCanvas.height = height;
                originalWidth = width;
                originalHeight = height;
                
                ctx.clearRect(0, 0, width, height);
                
                switch(type) {
                    case 'bricks':
                        drawBricks(ctx, width, height);
                        break;
                    case 'cobblestone':
                        drawCobblestone(ctx, width, height);
                        break;
                    case 'metal':
                        drawMetal(ctx, width, height);
                        break;
                    case 'rock':
                        drawRock(ctx, width, height);
                        break;
                }
            
                inputPlaceholder.style.display = 'none';
                inputCanvas.style.display = 'block';
                
                // 存储原始图像数据
                currentImageData = ctx.getImageData(0, 0, width, height);
                // 初始化模糊图像数据
                blurredImageData = new Uint8ClampedArray(currentImageData.data);
            }
            
            // 绘制砖块图案
            function drawBricks(ctx, width, height) {
                ctx.fillStyle = '#333';
                ctx.fillRect(0, 0, width, height);
                
                const brickWidth = width / 8;
                const brickHeight = height / 16;
                
                ctx.fillStyle = '#999';
                
                for (let y = 0; y < height; y += brickHeight) {
                    for (let x = 0; x < width; x += brickWidth) {
                        // 每行偏移砖块
                        const offset = (y / brickHeight) % 2 === 0 ? 0 : brickWidth / 2;
                        ctx.fillRect(x + offset, y, brickWidth - 4, brickHeight - 4);
                    }
                }
            }
            
            // 绘制鹅卵石图案
            function drawCobblestone(ctx, width, height) {
                ctx.fillStyle = '#333';
                ctx.fillRect(0, 0, width, height);
                
                const stoneSize = width / 8;
                ctx.fillStyle = '#999';
                
                for (let y = stoneSize/2; y < height; y += stoneSize) {
                    for (let x = stoneSize/2; x < width; x += stoneSize) {
                        ctx.beginPath();
                        ctx.arc(x, y, stoneSize/2.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // 绘制金属板图案
            function drawMetal(ctx, width, height) {
                ctx.fillStyle = '#333';
                ctx.fillRect(0, 0, width, height);
                
                const cellSize = width / 8;
                ctx.fillStyle = '#666';
                
                for (let y = 0; y < height; y += cellSize) {
                    for (let x = 0; x < width; x += cellSize) {
                        ctx.fillRect(x, y, cellSize, cellSize);
                        
                        // 内部方块
                        ctx.fillStyle = '#999';
                        ctx.fillRect(x + 4, y + 4, cellSize - 8, cellSize - 8);
                        ctx.fillStyle = '#ccc';
                        ctx.fillRect(x + 8, y + 8, cellSize - 16, cellSize - 16);
                        ctx.fillStyle = '#666';
                    }
                }
            }
            
            // 绘制岩石图案
            function drawRock(ctx, width, height) {
                ctx.fillStyle = '#333';
                ctx.fillRect(0, 0, width, height);
                
                ctx.fillStyle = '#999';
                ctx.beginPath();
                ctx.ellipse(width/2, height/2, width/3, height/3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // 岩石纹理
                ctx.fillStyle = '#777';
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * width/4;
                    const x = width/2 + Math.cos(angle) * radius;
                    const y = height/2 + Math.sin(angle) * radius;
                    const size = 5 + Math.random() * 15;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // 封装一个通用的GPU处理函数，减少代码重复
            function runGpuProcess(program, uniforms) {
                 const startTime = performance.now();
                
                progressContainer.style.display = 'block';
                
                const offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = originalWidth;
                offscreenCanvas.height = originalHeight;
                const offscreenCtx = offscreenCanvas.getContext('2d');
                const imageData = new ImageData(
                    blurredImageData, 
                    originalWidth, 
                    originalHeight
                );
                offscreenCtx.putImageData(imageData, 0, 0);
                
                if (!gl || !program) {
                    console.error('WebGL program is not available. Falling back to CPU.');
                    setGPUMode(false);
                    return;
                }
                
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, offscreenCanvas);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                
                const targetTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, targetTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, originalWidth, originalHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                
                const framebuffer = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, targetTexture, 0);
                
                gl.viewport(0, 0, originalWidth, originalHeight);
                gl.useProgram(program);
                
                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
                
                const texCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
                
                const positionLocation = gl.getAttribLocation(program, 'a_position');
                gl.enableVertexAttribArray(positionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                
                const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
                gl.enableVertexAttribArray(texCoordLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                const imageLocation = gl.getUniformLocation(program, 'u_image');
                gl.uniform1i(imageLocation, 0);
                
                // 设置传入的uniforms
                for(const key in uniforms) {
                    const location = gl.getUniformLocation(program, key);
                    if (location) {
                       if(key === 'u_resolution') {
                           gl.uniform2f(location, uniforms[key][0], uniforms[key][1]);
                       } else {
                           gl.uniform1f(location, uniforms[key]);
                       }
                    }
                }
                
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                const pixels = new Uint8Array(originalWidth * originalHeight * 4);
                gl.readPixels(0, 0, originalWidth, originalHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
                
                outputCanvas.width = originalWidth;
                outputCanvas.height = originalHeight;
                const outputCtx = outputCanvas.getContext('2d');
                const outputImageData = outputCtx.createImageData(originalWidth, originalHeight);
                outputImageData.data.set(pixels);
                outputCtx.putImageData(outputImageData, 0, 0);
                
                gl.deleteTexture(texture);
                gl.deleteTexture(targetTexture);
                gl.deleteFramebuffer(framebuffer);
                gl.deleteBuffer(positionBuffer);
                gl.deleteBuffer(texCoordBuffer);
                
                const endTime = performance.now();
                const elapsed = endTime - startTime;
                processingTimeSpan.textContent = elapsed.toFixed(2);
                console.log(`GPU处理完成 (${currentMapType})，耗时: ${elapsed.toFixed(2)}ms`);
                
                progressFill.style.width = '100%';
                progressPercent.textContent = '100%';
                
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                }, 500);
            }

            // GPU加速的法线图生成
            function convertWithGPU() {
                runGpuProcess(normalMapProgram, {
                    'u_strength': parseFloat(strengthSlider.value),
                    'u_invertX': invertX.checked ? -1.0 : 1.0,
                    'u_invertY': invertY.checked ? -1.0 : 1.0,
                    'u_resolution': [originalWidth, originalHeight]
                });
            }
            
            function convertAOMapWithGPU() {
                 runGpuProcess(aoMapProgram, {
                    'u_strength': parseFloat(aoStrengthSlider.value),
                    'u_spread': parseFloat(aoSpreadSlider.value),
                    'u_resolution': [originalWidth, originalHeight]
                });
            }

            // CPU模式生成法线图（使用分块处理）
            function convertWithCPU() {
                const strength = parseFloat(strengthSlider.value);
                const invertXVal = invertX.checked ? -1 : 1;
                const invertYVal = invertY.checked ? -1 : 1;
                const useHighQuality = highQuality.checked;
                
                outputCanvas.width = originalWidth;
                outputCanvas.height = originalHeight;
                
                const outputCtx = outputCanvas.getContext('2d');
                const outputImageData = outputCtx.createImageData(originalWidth, originalHeight);
                const outputData = outputImageData.data;
                
                // 分块处理参数
                let y = 0;
                const chunkSize = 10; // 每次处理10行
                
                function processChunk() {
                    const chunkStartTime = performance.now();
                    const endY = Math.min(y + chunkSize, originalHeight);
                    
                    for (; y < endY; y++) {
                        for (let x = 0; x < originalWidth; x++) {
                            // 使用双线性插值采样
                            function getPixel(x, y) {
                                // 确保坐标在有效范围内
                                const cx = Math.max(0.5, Math.min(x, originalWidth - 1.5));
                                const cy = Math.max(0.5, Math.min(y, originalHeight - 1.5));
                                
                                if (useHighQuality) {
                                    return getPixelBicubic(blurredImageData, originalWidth, originalHeight, cx, cy);
                                } else {
                                    return getPixelBilinear(blurredImageData, originalWidth, originalHeight, cx, cy);
                                }
                            }
                            
                            // 使用Sobel算子计算梯度（减少锯齿）
                            let dx, dy;
                            
                            if (useHighQuality) {
                                // Sobel算子
                                dx = 
                                    -1 * getPixel(x-1, y-1) + 
                                    1 * getPixel(x+1, y-1) +
                                    -2 * getPixel(x-1, y)   + 
                                    2 * getPixel(x+1, y) +
                                    -1 * getPixel(x-1, y+1) + 
                                    1 * getPixel(x+1, y+1);
                                
                                dy = 
                                    -1 * getPixel(x-1, y-1) - 
                                    2 * getPixel(x, y-1) - 
                                    1 * getPixel(x+1, y-1) +
                                    1 * getPixel(x-1, y+1) + 
                                    2 * getPixel(x, y+1) + 
                                    1 * getPixel(x+1, y+1);
                                
                                // 缩放因子（Sobel算子结果较大）
                                dx *= 0.125;
                                dy *= 0.125;
                            } else {
                                // 中心差分法
                                dx = (getPixel(x + 1, y) - getPixel(x - 1, y)) * 0.5;
                                dy = (getPixel(x, y + 1) - getPixel(x, y - 1)) * 0.5;
                            }
                            
                            // 应用强度参数
                            const scaledDx = dx * strength;
                            const scaledDy = dy * strength;
                            
                            // 应用方向反转
                            const finalDx = scaledDx * invertXVal;
                            const finalDy = scaledDy * invertYVal;
                            
                            // 计算法线向量
                            const dz = 1.0;
                            const length = Math.sqrt(finalDx * finalDx + finalDy * finalDy + dz * dz);
                            
                            // 归一化
                            const nx = finalDx / length;
                            const ny = finalDy / length;
                            const nz = dz / length;
                            
                            // 将法线向量映射到RGB颜色空间
                            const idx = (y * originalWidth + x) * 4;
                            outputData[idx] = Math.round((nx + 1) * 127.5);     // R
                            outputData[idx + 1] = Math.round((ny + 1) * 127.5); // G
                            outputData[idx + 2] = Math.round((nz + 1) * 127.5); // B
                            outputData[idx + 3] = 255;                          // Alpha
                        }
                    }
                    
                    // 更新进度条
                    const percent = Math.round((y / originalHeight) * 100);
                    progressFill.style.width = `${percent}%`;
                    progressPercent.textContent = `${percent}%`;
                    
                    // 如果还有行要处理
                    if (y < originalHeight) {
                        setTimeout(processChunk, 0); // 让出UI线程
                    } else {
                        // 处理完成
                        outputCtx.putImageData(outputImageData, 0, 0);
                        progressFill.style.width = `100%`;
                        progressPercent.textContent = `100%`;
                    }
                }
                processChunk();
            }

            // --- 其他贴图生成函数 ---

            function convertToDisplacementMap() {
                const strength = parseFloat(dispStrengthSlider.value);
                const level = parseFloat(dispLevelSlider.value);
                const inputData = currentImageData.data;
                
                outputCanvas.width = originalWidth;
                outputCanvas.height = originalHeight;
                const outputCtx = outputCanvas.getContext('2d');
                const outputImageData = outputCtx.createImageData(originalWidth, originalHeight);
                const outputData = outputImageData.data;

                const midLevel = 128 * (1 - level);

                for (let i = 0; i < inputData.length; i += 4) {
                    const gray = (inputData[i] + inputData[i+1] + inputData[i+2]) / 3;
                    let value = 128 + (gray - midLevel) * strength;
                    value = Math.max(0, Math.min(255, value)); // Clamp
                    
                    outputData[i] = value;
                    outputData[i+1] = value;
                    outputData[i+2] = value;
                    outputData[i+3] = 255;
                }
                outputCtx.putImageData(outputImageData, 0, 0);
                progressFill.style.width = '100%';
                progressPercent.textContent = '100%';
            }

            // 这是原始的、缓慢的CPU版AO生成函数，保留作为CPU模式的选项
            function convertToAOMap() {
                const strength = parseFloat(aoStrengthSlider.value);
                const spread = parseInt(aoSpreadSlider.value);
                const inputData = currentImageData.data;
                const heightMap = new Float32Array(originalWidth * originalHeight);

                for(let i=0; i<heightMap.length; i++) {
                    heightMap[i] = (inputData[i*4] + inputData[i*4+1] + inputData[i*4+2]) / 3;
                }

                outputCanvas.width = originalWidth;
                outputCanvas.height = originalHeight;
                const outputCtx = outputCanvas.getContext('2d');
                const outputImageData = outputCtx.createImageData(originalWidth, originalHeight);
                const outputData = outputImageData.data;

                let y = 0;
                const chunkSize = 10;

                function processChunk() {
                    const endY = Math.min(y + chunkSize, originalHeight);
                     for (; y < endY; y++) {
                        for (let x = 0; x < originalWidth; x++) {
                            const centerIdx = y * originalWidth + x;
                            const centerHeight = heightMap[centerIdx];
                            let occlusion = 0;

                            for (let j = -spread; j <= spread; j++) {
                                for (let i = -spread; i <= spread; i++) {
                                    if (i === 0 && j === 0) continue;
                                    
                                    const sampleX = Math.max(0, Math.min(originalWidth - 1, x + i));
                                    const sampleY = Math.max(0, Math.min(originalHeight - 1, y + j));
                                    const sampleIdx = sampleY * originalWidth + sampleX;
                                    const sampleHeight = heightMap[sampleIdx];
                                    
                                    const heightDiff = sampleHeight - centerHeight;
                                    if (heightDiff > 0) {
                                        const dist = Math.sqrt(i*i + j*j);
                                        occlusion += heightDiff / (dist * dist + 1);
                                    }
                                }
                            }
                            const aoValue = 255 - Math.min(255, occlusion * strength);
                            const outIdx = centerIdx * 4;
                            outputData[outIdx] = aoValue;
                            outputData[outIdx+1] = aoValue;
                            outputData[outIdx+2] = aoValue;
                            outputData[outIdx+3] = 255;
                        }
                    }
                    const percent = Math.round((y / originalHeight) * 100);
                    progressFill.style.width = `${percent}%`;
                    progressPercent.textContent = `${percent}%`;
                    if (y < originalHeight) {
                        setTimeout(processChunk, 0);
                    } else {
                        outputCtx.putImageData(outputImageData, 0, 0);
                    }
                }
                processChunk();
            }

            function convertToSimpleTextureMap(type) {
                const strength = parseFloat(document.getElementById(`${type}StrengthSlider`).value);
                const contrast = parseFloat(document.getElementById(`${type}ContrastSlider`).value);
                const invert = document.getElementById(`${type}Invert`).checked;

                const inputData = currentImageData.data;
                outputCanvas.width = originalWidth;
                outputCanvas.height = originalHeight;
                const outputCtx = outputCanvas.getContext('2d');
                const outputImageData = outputCtx.createImageData(originalWidth, originalHeight);
                const outputData = outputImageData.data;

                for (let i = 0; i < inputData.length; i += 4) {
                    let gray = (inputData[i] + inputData[i+1] + inputData[i+2]) / 3;
                    if (invert) gray = 255 - gray;

                    let value = 128 + (gray - 128) * contrast;
                    value = value * strength;
                    value = Math.max(0, Math.min(255, value)); // Clamp
                    
                    outputData[i] = value;
                    outputData[i+1] = value;
                    outputData[i+2] = value;
                    outputData[i+3] = 255;
                }
                outputCtx.putImageData(outputImageData, 0, 0);
                progressFill.style.width = '100%';
                progressPercent.textContent = '100%';
            }
            
            function convertToReflectionMap() {
                convertToSimpleTextureMap('reflect');
            }

            function convertToGlossinessMap() {
                 convertToSimpleTextureMap('gloss');
            }
            
            // 更新3D预览
            function update3dPreview() {
                if (!outputCanvas.style.display || outputCanvas.style.display === 'none' || currentMapType !== 'normal') return;
                
                // 创建Three.js纹理
                const texture = new THREE.CanvasTexture(outputCanvas);
                texture.needsUpdate = true;
                
                // 更新法线贴图
                updateNormalMap(texture);
                
                // 显示提示信息
                previewHint.style.display = 'none';
            }
                                  
            // 优化的的高斯模糊函数
            function applyBlur(data, width, height, radius) {
                if (radius <= 0) return;
                
                const kernelSize = Math.floor(radius) * 2 + 1;
                const kernel = createGaussianKernel(kernelSize, radius);
                const r = Math.floor(kernelSize / 2);
                const tempData = new Uint8ClampedArray(data.length);
                
                // 水平模糊
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let rVal = 0, gVal = 0, bVal = 0;
                        let weightSum = 0;
                        
                        for (let kx = -r; kx <= r; kx++) {
                            const px = Math.max(0, Math.min(width - 1, x + kx));
                            const idx = (y * width + px) * 4;
                            const weight = kernel[kx + r];
                            
                            rVal += data[idx] * weight;
                            gVal += data[idx + 1] * weight;
                            bVal += data[idx + 2] * weight;
                            weightSum += weight;
                        }
                        
                        const idx = (y * width + x) * 4;
                        tempData[idx] = rVal / weightSum;
                        tempData[idx + 1] = gVal / weightSum;
                        tempData[idx + 2] = bVal / weightSum;
                        tempData[idx + 3] = data[idx + 3];
                    }
                }
                
                // 垂直模糊
                for (let x = 0; x < width; x++) {
                    for (let y = 0; y < height; y++) {
                        let rVal = 0, gVal = 0, bVal = 0;
                        let weightSum = 0;
                        
                        for (let ky = -r; ky <= r; ky++) {
                            const py = Math.max(0, Math.min(height - 1, y + ky));
                            const idx = (py * width + x) * 4;
                            const weight = kernel[ky + r];
                            
                            rVal += tempData[idx] * weight;
                            gVal += tempData[idx + 1] * weight;
                            bVal += tempData[idx + 2] * weight;
                            weightSum += weight;
                        }
                        
                        const idx = (y * width + x) * 4;
                        data[idx] = rVal / weightSum;
                        data[idx + 1] = gVal / weightSum;
                        data[idx + 2] = bVal / weightSum;
                    }
                }
            }
            
            // 创建高斯核
            function createGaussianKernel(size, sigma) {
                const kernel = [];
                const mean = size / 2;
                let sum = 0;
                
                for (let i = 0; i < size; i++) {
                    const x = i - mean;
                    kernel[i] = Math.exp(-(x * x) / (2 * sigma * sigma)) 
                                / (Math.sqrt(2 * Math.PI) * sigma);
                    sum += kernel[i];
                }
                
                // 归一化
                for (let i = 0; i < size; i++) {
                    kernel[i] /= sum;
                }
                
                return kernel;
            }
            
            // 双线性插值函数
            function getPixelBilinear(data, width, height, x, y) {
                const x1 = Math.floor(x);
                const y1 = Math.floor(y);
                const x2 = Math.min(width - 1, x1 + 1);
                const y2 = Math.min(height - 1, y1 + 1);
                
                const dx = x - x1;
                const dy = y - y1;
                
                const idx11 = (y1 * width + x1) * 4;
                const idx12 = (y1 * width + x2) * 4;
                const idx21 = (y2 * width + x1) * 4;
                const idx22 = (y2 * width + x2) * 4;
                
                // 双线性插值
                const top = interpolate(
                    getGray(data, idx11),
                    getGray(data, idx12),
                    dx
                );
                
                const bottom = interpolate(
                    getGray(data, idx21),
                    getGray(data, idx22),
                    dx
                );
                
                return interpolate(top, bottom, dy);
            }
            
            // 双三次插值函数（高质量模式）
            function getPixelBicubic(data, width, height, x, y) {
                const px = Math.floor(x);
                const py = Math.floor(y);
                
                // 获取16个周围像素
                const values = [];
                for (let j = -1; j <= 2; j++) {
                    for (let i = -1; i <= 2; i++) {
                        const sampleX = Math.max(0, Math.min(width - 1, px + i));
                        const sampleY = Math.max(0, Math.min(height - 1, py + j));
                        const idx = (sampleY * width + sampleX) * 4;
                        values.push(getGray(data, idx));
                    }
                }
                
                // 水平插值
                const horiz = [];
                for (let j = 0; j < 4; j++) {
                    const row = values.slice(j * 4, j * 4 + 4);
                    horiz.push(cubicInterpolate(row, x - px));
                }
                
                // 垂直插值
                return cubicInterpolate(horiz, y - py);
            }
            
            function cubicInterpolate(values, t) {
                // 三次插值公式
                const a0 = values[0];
                const a1 = values[1];
                const a2 = values[2];
                const a3 = values[3];
                
                // 使用Catmull-Rom样条
                return a1 + 0.5 * t * (a2 - a0 + 
                       t * (2*a0 - 5*a1 + 4*a2 - a3 + 
                       t * (3*(a1 - a2) + a3 - a0)));
            }
            
            function getGray(data, idx) {
                return (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
            }
            
            function interpolate(a, b, t) {
                return a + (b - a) * t;
            }
            
            // 初始化示例图像
            generateExampleImage('bricks');
            // 初始生成法线图
            setTimeout(() => {
                scheduleMapUpdate();
            }, 500);
            
            // 初始化拖放功能
            function setupDragAndDrop() {
                // 输入区域拖放事件
                inputUploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    inputUploadArea.classList.add('drag-over');
                });
                
                inputUploadArea.addEventListener('dragleave', () => {
                    inputUploadArea.classList.remove('drag-over');
                });
                
                inputUploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    inputUploadArea.classList.remove('drag-over');
                    
                    if (e.dataTransfer.files.length) {
                        loadImageFile(e.dataTransfer.files[0]);
                    }
                });
                
                // 输出区域拖放事件（反推功能）
                outputCanvasContainer.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    if (currentMapType !== 'normal') return;
                    outputCanvasContainer.classList.add('drag-over');
                });
                
                outputCanvasContainer.addEventListener('dragleave', () => {
                     if (currentMapType !== 'normal') return;
                    outputCanvasContainer.classList.remove('drag-over');
                });
                
                outputCanvasContainer.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (currentMapType !== 'normal') return;
                    outputCanvasContainer.classList.remove('drag-over');
                    
                    if (e.dataTransfer.files.length) {
                        const file = e.dataTransfer.files[0];
                        reverseNormalMap(file);
                    }
                });
            }
            
            // 反推功能：从法线图生成高度图
            function reverseNormalMap(file) {
                const validTypes = ['image/jpeg', 'image/png', 'image/bmp', 'image/tiff', 'image/webp', 'image/gif'];
                const isTiffFile = file.type === 'image/tiff' || file.name.toLowerCase().endsWith('.tif') || file.name.toLowerCase().endsWith('.tiff');
                const isValidFile = validTypes.includes(file.type) || isTiffFile;
                
                if (!isValidFile) {
                    alert('不支持的图片格式，请上传JPG, PNG, BMP, TIFF或WEBP格式的图片');
                    return;
                }
                
                const reader = new FileReader();
                
                if (isTiffFile) {
                    // 使用ArrayBuffer读取TIFF
                    reader.onload = function(event) {
                        try {
                            const arrayBuffer = event.target.result;
                            const ifds = UTIF.decode(arrayBuffer);
                            
                            // 获取第一个图像
                            UTIF.decodeImage(arrayBuffer, ifds[0]);
                            const width = ifds[0].width;
                            const height = ifds[0].height;
                            
                            // 将TIFF转换为RGBA格式
                            const rgba = UTIF.toRGBA8(ifds[0]);
                            
                            // 创建ImageData对象
                            const normalImageData = new ImageData(width, height);
                            normalImageData.data.set(new Uint8ClampedArray(rgba));
                            
                            // 创建高度图数据
                            const heightImageData = new ImageData(width, height);
                            
                            // 选择算法
                            const usePoisson = poissonAlgorithm.checked;
                            
                            if (usePoisson) {
                                // 使用Poisson重建算法
                                reconstructWithPoisson(normalImageData.data, heightImageData.data, width, height);
                            } else {
                                // 使用简单累加算法
                                reconstructWithSimple(normalImageData.data, heightImageData.data, width, height);
                            }
                            
                            // 绘制到输入canvas
                            inputCanvas.width = width;
                            inputCanvas.height = height;
                            const inputCtx = inputCanvas.getContext('2d');
                            inputCtx.putImageData(heightImageData, 0, 0);
                            
                            inputPlaceholder.style.display = 'none';
                            inputCanvas.style.display = 'block';
                            
                            // 存储图像数据
                            currentImageData = inputCtx.getImageData(0, 0, width, height);
                            blurredImageData = new Uint8ClampedArray(currentImageData.data);
                            
                            // 更新UI
                            outputPlaceholder.style.display = 'block';
                            outputCanvas.style.display = 'none';
                            scheduleMapUpdate(); // Re-generate normal map
                            
                            // 提示用户
                            alert('法线图已成功反推为高度图！您可以在左侧查看并进一步调整参数生成新的法线图。');
                        } catch (error) {
                            console.error('TIFF处理错误:', error);
                            alert('无法处理此TIFF文件，请尝试其他文件');
                        }
                    };
                    reader.readAsArrayBuffer(file);
                } else {
                    // 使用DataURL读取其他图片
                    reader.onload = function(event) {
                        const img = new Image();
                        img.onload = function() {
                            // 设置canvas尺寸
                            originalWidth = img.width;
                            originalHeight = img.height;
                            
                            // 在临时canvas绘制
                            const tempCanvas = document.createElement('canvas');
                            tempCanvas.width = originalWidth;
                            tempCanvas.height = originalHeight;
                            const tempCtx = tempCanvas.getContext('2d');
                            tempCtx.drawImage(img, 0, 0);

                            
                            // 获取图像数据
                            const normalImageData = tempCtx.getImageData(0, 0, originalWidth, originalHeight);
                            const normalData = normalImageData.data;
                            
                            // 创建高度图数据
                            const heightImageData = tempCtx.createImageData(originalWidth, originalHeight);
                            const heightData = heightImageData.data;
                            
                            // 选择算法
                            const usePoisson = poissonAlgorithm.checked;
                            
                            if (usePoisson) {
                                // 使用Poisson重建算法
                                reconstructWithPoisson(normalData, heightData, originalWidth, originalHeight);
                            } else {
                                // 使用简单累加算法
                                reconstructWithSimple(normalData, heightData, originalWidth, originalHeight);
                            }
                            
                            // 绘制到输入canvas
                            inputCanvas.width = originalWidth;
                            inputCanvas.height = originalHeight;
                            const inputCtx = inputCanvas.getContext('2d');
                            inputCtx.putImageData(heightImageData, 0, 0);
                            
                            inputPlaceholder.style.display = 'none';
                            inputCanvas.style.display = 'block';
                            
                            // 存储图像数据
                            currentImageData = inputCtx.getImageData(0, 0, originalWidth, originalHeight);
                            blurredImageData = new Uint8ClampedArray(currentImageData.data);
                            
                            // 更新UI
                            outputPlaceholder.style.display = 'block';
                            outputCanvas.style.display = 'none';
                            scheduleMapUpdate(); // Re-generate normal map

                            // 提示用户
                            alert('法线图已成功反推为高度图！您可以在左侧查看并进一步调整参数生成新的法线图。');
                        };
                        img.onerror = function() {
                            alert('图片加载失败，请重试');
                        };
                        img.src = event.target.result;
                    };
                    reader.onerror = function() {
                        alert('文件读取失败');
                    };
                    reader.readAsDataURL(file);
                }
            }
            
            // 简单累加算法（旧版，有斜线问题）
            function reconstructWithSimple(normalData, heightData, width, height) {
                // 初始化高度数组
                const heightMap = new Array(width * height).fill(0);
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        
                        // 从法线图获取法线向量
                        const nx = (normalData[idx] / 127.5) - 1;
                        const ny = (normalData[idx + 1] / 127.5) - 1;
                        const nz = (normalData[idx + 2] / 127.5) - 1;
                        
                        // 计算高度梯度
                        const dx = nx / nz;
                        const dy = ny / nz;
                        
                        // 累积高度（简化方法）
                        let heightVal = 0;
                        if (x > 0) heightVal += heightMap[y * width + (x-1)] + dx * 10;
                        if (y > 0) heightVal += heightMap[(y-1) * width + x] + dy * 10;
                        if (x > 0 && y > 0) heightVal /= 2;
                        
                        heightMap[y * width + x] = heightVal;
                    }
                }
                
                // 归一化高度图
                let min = Number.MAX_VALUE, max = -Number.MAX_VALUE;
                for (let i = 0; i < heightMap.length; i++) {
                    if (heightMap[i] < min) min = heightMap[i];
                    if (heightMap[i] > max) max = heightMap[i];
                }
                
                const range = max - min;
                
                // 转换为灰度图像
                for (let i = 0; i < heightMap.length; i++) {
                    const heightValue = range > 0 ? Math.round(((heightMap[i] - min) / range) * 255) : 0;
                    const idx = i * 4;
                    heightData[idx] = heightValue;
                    heightData[idx + 1] = heightValue;
                    heightData[idx + 2] = heightValue;
                    heightData[idx + 3] = 255;
                }
            }
            
            // Poisson重建算法（解决斜线问题）
            function reconstructWithPoisson(normalData, heightData, width, height) {
                // 计算梯度场
                const dxMap = new Float64Array(width * height);
                const dyMap = new Float64Array(width * height);
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        
                        // 从法线图获取法线向量
                        const nx = (normalData[idx] / 127.5) - 1;
                        const ny = (normalData[idx + 1] / 127.5) - 1;
                        const nz = (normalData[idx + 2] / 127.5) - 1;
                        
                        // 计算高度梯度
                        dxMap[y * width + x] = nx / nz;
                        dyMap[y * width + x] = ny / nz;
                    }
                }
                
                // 计算散度
                const div = new Float64Array(width * height);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = y * width + x;
                        
                        // 计算散度 (div = d(dx)/dx + d(dy)/dy)
                        let ddx = 0, ddy = 0;
                        
                        if (x > 0 && x < width - 1) {
                            ddx = (dxMap[idx + 1] - dxMap[idx - 1]) * 0.5;
                        }
                        
                        if (y > 0 && y < height - 1) {
                            ddy = (dyMap[idx + width] - dyMap[idx - width]) * 0.5;
                        }
                        
                        div[idx] = ddx + ddy;
                    }
                }
                
                // 使用迭代法求解Poisson方程
                const heightMap = new Float64Array(width * height);
                const temp = new Float64Array(width * height);
                
                // 迭代次数
                const iterations = 100;
                
                for (let iter = 0; iter < iterations; iter++) {
                    // 更新高度图
                    for (let y = 1; y < height - 1; y++) {
                        for (let x = 1; x < width - 1; x++) {
                            const idx = y * width + x;
                            
                            // 计算周围四个点的平均值
                            const sum = 
                                heightMap[idx - 1] + 
                                heightMap[idx + 1] + 
                                heightMap[idx - width] + 
                                heightMap[idx + width];
                            
                            // 更新高度值
                            temp[idx] = (sum - div[idx]) * 0.25;
                        }
                    }
                    
                    // 交换数组
                    const swap = heightMap;
                    heightMap.set(temp);
                    temp.set(swap);
                }
                
                // 归一化高度图
                let min = Number.MAX_VALUE, max = -Number.MAX_VALUE;
                for (let i = 0; i < heightMap.length; i++) {
                    if (heightMap[i] < min) min = heightMap[i];
                    if (heightMap[i] > max) max = heightMap[i];
                }
                
                const range = max - min;
                
                // 转换为灰度图像
                for (let i = 0; i < heightMap.length; i++) {
                     const heightValue = range > 0 ? Math.round(((heightMap[i] - min) / range) * 255) : 0;
                    const idx = i * 4;
                    heightData[idx] = heightValue;
                    heightData[idx + 1] = heightValue;
                    heightData[idx + 2] = heightValue;
                    heightData[idx + 3] = 255;
                }
            }
            
            // 反推按钮事件
            reverseBtn.addEventListener('click', () => {
                if (outputCanvas.style.display === 'none') {
                    alert('请先生成法线图');
                    return;
                }
                
                // 创建一个临时canvas用于处理
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = outputCanvas.width;
                tempCanvas.height = outputCanvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(outputCanvas, 0, 0);
                
                // 获取图像数据
                const normalImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                
                // 创建高度图数据
                const heightImageData = tempCtx.createImageData(tempCanvas.width, tempCanvas.height);
                
                // 选择算法
                const usePoisson = poissonAlgorithm.checked;
                
                if (usePoisson) {
                    // 使用Poisson重建算法
                    reconstructWithPoisson(normalImageData.data, heightImageData.data, tempCanvas.width, tempCanvas.height);
                } else {
                    // 使用简单累加算法
                    reconstructWithSimple(normalImageData.data, heightImageData.data, tempCanvas.width, tempCanvas.height);
                }
                
                // 绘制到输入canvas
                inputCanvas.width = tempCanvas.width;
                inputCanvas.height = tempCanvas.height;
                const inputCtx = inputCanvas.getContext('2d');
                inputCtx.putImageData(heightImageData, 0, 0);
                
                inputPlaceholder.style.display = 'none';
                inputCanvas.style.display = 'block';
                
                // 存储图像数据
                currentImageData = inputCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                blurredImageData = new Uint8ClampedArray(currentImageData.data);
                
                // 提示用户
                alert('法线图已成功反推为高度图！将根据新的灰度图重新生成法线图。');
                scheduleMapUpdate();
            });
            
            // 初始化拖放功能
            setupDragAndDrop();
            
            // 默认使用GPU模式
            setGPUMode(true);
            
            // 修改normalPreviewBtn事件监听器
            normalPreviewBtn.addEventListener('click', () => {
                normalPreviewBtn.classList.add('active');
                modelPreviewBtn.classList.remove('active');
                outputCanvasContainer.style.display = 'flex';
                outputPreviewTitleContainer.style.display = 'flex';
                preview3dContainer.style.display = 'none';
                is3dPreviewActive = false;
            });

            // 修改modelPreviewBtn事件监听器
            modelPreviewBtn.addEventListener('click', () => {
                if(currentMapType !== 'normal') return;

                modelPreviewBtn.classList.add('active');
                normalPreviewBtn.classList.remove('active');
                outputCanvasContainer.style.display = 'none';
                outputPreviewTitleContainer.style.display = 'none';
                preview3dContainer.style.display = 'block';
                is3dPreviewActive = true;
                
                // 如果尚未初始化Three.js，则初始化
                if (!isThreeInitialized) {
                    initThreeScene();
                    animate(); // 启动动画循环
                } else {
                    // 确保动画循环正在运行
                    if (!animationId) {
                        animate();
                    }
                }
                
                // 强制更新渲染器尺寸
                updateRendererSize();
                
                // 如果已有法线图，更新3D预览
                if (outputCanvas.style.display !== 'none') {
                    update3dPreview();
                    previewHint.style.display = 'none';
                } else {
                    previewHint.style.display = 'block';
                }
            });
            
            // 几何体切换事件
            shapeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    shapeButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    createMesh(btn.dataset.shape);
                });
            });
            
            // 初始化3D预览容器
            preview3dContainer.style.display = 'none';
            // 初始化时更新一次UI
            updateUIAfterTabSwitch();
        });
    </script>
</body>
</html>