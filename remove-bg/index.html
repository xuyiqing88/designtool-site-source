<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>离线一键抠图工具（轻量版）</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
      background-color: #f0f0f0;
    }
    canvas, img {
      max-width: 100%;
      margin-top: 20px;
    }
    #download {
      display: none;
      margin-top: 15px;
      padding: 10px 20px;
      background: #007bff;
      color: white;
      text-decoration: none;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <h1>离线一键抠图工具（轻量版，u2netp）</h1>
  <input type="file" id="upload" accept="image/*" />
  <canvas id="canvas" style="display:none;"></canvas>
  <img id="output" />
  <br/>
  <a id="download" download="no-bg.png">下载透明图</a>

  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.1/dist/ort.min.js"></script>
  <script>
    // 设置从 CDN 自动加载 .wasm 文件
    ort.env.wasm.wasmPaths = 'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.1/dist/';
    ort.env.wasm.numThreads = 1;

    const upload = document.getElementById('upload');
    const canvas = document.getElementById('canvas');
    const output = document.getElementById('output');
    const download = document.getElementById('download');

    let session = null; // 将 session 定义在外部，避免重复加载模型

    async function loadModel() {
      if (!session) { // 如果 session 未加载，则加载
        session = await ort.InferenceSession.create('model/u2netp.onnx');
      }
      return session;
    }

    function imageToTensor(img, size = 320) {
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, size, size);
      const imgData = ctx.getImageData(0, 0, size, size).data;

      const float32Data = new Float32Array(size * size * 3);
      for (let i = 0; i < size * size; i++) {
        // 归一化到 [0, 1] 范围
        float32Data[i] = imgData[i * 4] / 255;
        float32Data[i + size * size] = imgData[i * 4 + 1] / 255;
        float32Data[i + size * size * 2] = imgData[i * 4 + 2] / 255;
      }

      return new ort.Tensor('float32', float32Data, [1, 3, size, size]);
    }

    // 调整蒙版尺寸以匹配原始图片尺寸
    function resizeMask(mask, fromSize, toW, toH) {
      const canvas = document.createElement('canvas');
      canvas.width = fromSize;
      canvas.height = fromSize;
      const ctx = canvas.getContext('2d');

      const imageData = ctx.createImageData(fromSize, fromSize);
      for (let i = 0; i < fromSize * fromSize; i++) {
        // 将浮点数蒙版值转换为 0-255 的整数值
        const value = Math.floor(mask[i] * 255);
        imageData.data[i * 4 + 0] = value;
        imageData.data[i * 4 + 1] = value;
        imageData.data[i * 4 + 2] = value;
        imageData.data[i * 4 + 3] = 255; // 完全不透明，因为这是蒙版数据本身
      }
      ctx.putImageData(imageData, 0, 0);

      // resize 到原始尺寸
      const outputCanvas = document.createElement('canvas');
      outputCanvas.width = toW;
      outputCanvas.height = toH;
      const outCtx = outputCanvas.getContext('2d');
      outCtx.drawImage(canvas, 0, 0, toW, toH);

      const resized = outCtx.getImageData(0, 0, toW, toH).data;
      const resizedMask = new Float32Array(toW * toH);
      for (let i = 0; i < toW * toH; i++) {
        // 重新归一化到 [0, 1] 范围
        resizedMask[i] = resized[i * 4] / 255;
      }

      return resizedMask;
    }

    function applyAlphaMask(originalImg, mask, width, height) {
      canvas.style.display = 'block';
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(originalImg, 0, 0, width, height);
      const imgData = ctx.getImageData(0, 0, width, height);
      const data = imgData.data;

      for (let i = 0; i < width * height; i++) {
        // 将蒙版值应用于原始图像的alpha通道
        const alpha = Math.floor(mask[i] * 255);
        data[i * 4 + 3] = alpha; // 设置alpha通道
      }

      ctx.putImageData(imgData, 0, 0);
    }

    upload.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const img = new Image();
      img.src = URL.createObjectURL(file);
      await img.decode();

      const width = img.width;
      const height = img.height;

      const modelSession = await loadModel(); // 获取模型 session
      const inputTensor = imageToTensor(img);
      const inputName = modelSession.inputNames[0];
      const feeds = { [inputName]: inputTensor };
      const results = await modelSession.run(feeds);

      const outputData = results[modelSession.outputNames[0]].data;

      // 关键修复：调整蒙版尺寸以匹配原始图片尺寸
      const resizedMask = resizeMask(outputData, 320, width, height); 

      applyAlphaMask(img, resizedMask, width, height); // 使用调整后的蒙版

      canvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        output.src = url;
        download.href = url;
        download.style.display = 'inline-block';
      }, 'image/png');
    });
  </script>
</body>
</html>